import { DEFAULT_SEGMENT_KEY } from "../../../shared/lib/segment";
import { matchSegment } from "../match-segments";
<<<<<<< HEAD
/**
 * Deep merge of the two router states. Parallel route keys are preserved if the patch doesn't have them.
 */ function applyPatch(initialTree, patchTree, applyPatchToDefaultSegment) {
    if (applyPatchToDefaultSegment === void 0) applyPatchToDefaultSegment = false;
=======
import { addRefreshMarkerToActiveParallelSegments } from "./refetch-inactive-parallel-segments";
/**
 * Deep merge of the two router states. Parallel route keys are preserved if the patch doesn't have them.
 */ function applyPatch(initialTree, patchTree, flightSegmentPath) {
>>>>>>> 4f9d35bd5c5bf095848f6fc99f7e7bfe5212365f
    const [initialSegment, initialParallelRoutes] = initialTree;
    const [patchSegment, patchParallelRoutes] = patchTree;
    // if the applied patch segment is __DEFAULT__ then it can be ignored in favor of the initial tree
    // this is because the __DEFAULT__ segment is used as a placeholder on navigation
<<<<<<< HEAD
    // however, there are cases where we _do_ want to apply the patch to the default segment,
    // such as when revalidating the router cache with router.refresh/revalidatePath
    if (!applyPatchToDefaultSegment && patchSegment === DEFAULT_SEGMENT_KEY && initialSegment !== DEFAULT_SEGMENT_KEY) {
=======
    if (patchSegment === DEFAULT_SEGMENT_KEY && initialSegment !== DEFAULT_SEGMENT_KEY) {
>>>>>>> 4f9d35bd5c5bf095848f6fc99f7e7bfe5212365f
        return initialTree;
    }
    if (matchSegment(initialSegment, patchSegment)) {
        const newParallelRoutes = {};
        for(const key in initialParallelRoutes){
            const isInPatchTreeParallelRoutes = typeof patchParallelRoutes[key] !== "undefined";
            if (isInPatchTreeParallelRoutes) {
<<<<<<< HEAD
                newParallelRoutes[key] = applyPatch(initialParallelRoutes[key], patchParallelRoutes[key], applyPatchToDefaultSegment);
=======
                newParallelRoutes[key] = applyPatch(initialParallelRoutes[key], patchParallelRoutes[key], flightSegmentPath);
>>>>>>> 4f9d35bd5c5bf095848f6fc99f7e7bfe5212365f
            } else {
                newParallelRoutes[key] = initialParallelRoutes[key];
            }
        }
        for(const key in patchParallelRoutes){
            if (newParallelRoutes[key]) {
                continue;
            }
            newParallelRoutes[key] = patchParallelRoutes[key];
        }
        const tree = [
            initialSegment,
            newParallelRoutes
        ];
<<<<<<< HEAD
=======
        // Copy over the existing tree
>>>>>>> 4f9d35bd5c5bf095848f6fc99f7e7bfe5212365f
        if (initialTree[2]) {
            tree[2] = initialTree[2];
        }
        if (initialTree[3]) {
            tree[3] = initialTree[3];
        }
        if (initialTree[4]) {
            tree[4] = initialTree[4];
        }
        return tree;
    }
    return patchTree;
}
<<<<<<< HEAD
function applyRouterStatePatchToTreeImpl(flightSegmentPath, flightRouterState, treePatch, applyPatchDefaultSegment) {
    if (applyPatchDefaultSegment === void 0) applyPatchDefaultSegment = false;
    const [segment, parallelRoutes, , , isRootLayout] = flightRouterState;
    // Root refresh
    if (flightSegmentPath.length === 1) {
        const tree = applyPatch(flightRouterState, treePatch, applyPatchDefaultSegment);
=======
/**
 * Apply the router state from the Flight response, but skip patching default segments.
 * Useful for patching the router cache when navigating, where we persist the existing default segment if there isn't a new one.
 * Creates a new router state tree.
 */ export function applyRouterStatePatchToTree(flightSegmentPath, flightRouterState, treePatch, path) {
    const [segment, parallelRoutes, url, refetch, isRootLayout] = flightRouterState;
    // Root refresh
    if (flightSegmentPath.length === 1) {
        const tree = applyPatch(flightRouterState, treePatch, flightSegmentPath);
        addRefreshMarkerToActiveParallelSegments(tree, path);
>>>>>>> 4f9d35bd5c5bf095848f6fc99f7e7bfe5212365f
        return tree;
    }
    const [currentSegment, parallelRouteKey] = flightSegmentPath;
    // Tree path returned from the server should always match up with the current tree in the browser
    if (!matchSegment(currentSegment, segment)) {
        return null;
    }
    const lastSegment = flightSegmentPath.length === 2;
    let parallelRoutePatch;
    if (lastSegment) {
<<<<<<< HEAD
        parallelRoutePatch = applyPatch(parallelRoutes[parallelRouteKey], treePatch, applyPatchDefaultSegment);
    } else {
        parallelRoutePatch = applyRouterStatePatchToTreeImpl(flightSegmentPath.slice(2), parallelRoutes[parallelRouteKey], treePatch, applyPatchDefaultSegment);
=======
        parallelRoutePatch = applyPatch(parallelRoutes[parallelRouteKey], treePatch, flightSegmentPath);
    } else {
        parallelRoutePatch = applyRouterStatePatchToTree(flightSegmentPath.slice(2), parallelRoutes[parallelRouteKey], treePatch, path);
>>>>>>> 4f9d35bd5c5bf095848f6fc99f7e7bfe5212365f
        if (parallelRoutePatch === null) {
            return null;
        }
    }
    const tree = [
        flightSegmentPath[0],
        {
            ...parallelRoutes,
            [parallelRouteKey]: parallelRoutePatch
<<<<<<< HEAD
        }
=======
        },
        url,
        refetch
>>>>>>> 4f9d35bd5c5bf095848f6fc99f7e7bfe5212365f
    ];
    // Current segment is the root layout
    if (isRootLayout) {
        tree[4] = true;
    }
<<<<<<< HEAD
    return tree;
}
/**
 * Apply the router state from the Flight response to the tree, including default segments.
 * Useful for patching the router cache when we expect to revalidate the full tree, such as with router.refresh or revalidatePath.
 * Creates a new router state tree.
 */ export function applyRouterStatePatchToFullTree(flightSegmentPath, flightRouterState, treePatch) {
    return applyRouterStatePatchToTreeImpl(flightSegmentPath, flightRouterState, treePatch, true);
}
/**
 * Apply the router state from the Flight response, but skip patching default segments.
 * Useful for patching the router cache when navigating, where we persist the existing default segment if there isn't a new one.
 * Creates a new router state tree.
 */ export function applyRouterStatePatchToTreeSkipDefault(flightSegmentPath, flightRouterState, treePatch) {
    return applyRouterStatePatchToTreeImpl(flightSegmentPath, flightRouterState, treePatch, false);
}
=======
    addRefreshMarkerToActiveParallelSegments(tree, path);
    return tree;
}
>>>>>>> 4f9d35bd5c5bf095848f6fc99f7e7bfe5212365f

//# sourceMappingURL=apply-router-state-patch-to-tree.js.map