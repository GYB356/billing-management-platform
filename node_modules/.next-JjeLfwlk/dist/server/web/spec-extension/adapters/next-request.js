"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
<<<<<<< HEAD
    ResponseAbortedName: null,
    ResponseAborted: null,
    createAbortController: null,
    signalFromNodeResponse: null,
    NextRequestAdapter: null
=======
    NextRequestAdapter: null,
    ResponseAborted: null,
    ResponseAbortedName: null,
    createAbortController: null,
    signalFromNodeResponse: null
>>>>>>> 4f9d35bd5c5bf095848f6fc99f7e7bfe5212365f
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
<<<<<<< HEAD
    ResponseAbortedName: function() {
        return ResponseAbortedName;
=======
    NextRequestAdapter: function() {
        return NextRequestAdapter;
>>>>>>> 4f9d35bd5c5bf095848f6fc99f7e7bfe5212365f
    },
    ResponseAborted: function() {
        return ResponseAborted;
    },
<<<<<<< HEAD
=======
    ResponseAbortedName: function() {
        return ResponseAbortedName;
    },
>>>>>>> 4f9d35bd5c5bf095848f6fc99f7e7bfe5212365f
    createAbortController: function() {
        return createAbortController;
    },
    signalFromNodeResponse: function() {
        return signalFromNodeResponse;
<<<<<<< HEAD
    },
    NextRequestAdapter: function() {
        return NextRequestAdapter;
=======
>>>>>>> 4f9d35bd5c5bf095848f6fc99f7e7bfe5212365f
    }
});
const _requestmeta = require("../../../request-meta");
const _utils = require("../../utils");
const _request = require("../request");
const ResponseAbortedName = "ResponseAborted";
class ResponseAborted extends Error {
    constructor(...args){
        super(...args);
        this.name = ResponseAbortedName;
    }
}
function createAbortController(response) {
    const controller = new AbortController();
    // If `finish` fires first, then `res.end()` has been called and the close is
    // just us finishing the stream on our side. If `close` fires first, then we
    // know the client disconnected before we finished.
    response.once("close", ()=>{
        if (response.writableFinished) return;
        controller.abort(new ResponseAborted());
    });
    return controller;
}
function signalFromNodeResponse(response) {
    const { errored, destroyed } = response;
    if (errored || destroyed) {
        return AbortSignal.abort(errored ?? new ResponseAborted());
    }
    const { signal } = createAbortController(response);
    return signal;
}
class NextRequestAdapter {
    static fromBaseNextRequest(request, signal) {
        // TODO: look at refining this check
        if ("request" in request && request.request) {
            return NextRequestAdapter.fromWebNextRequest(request);
        }
        return NextRequestAdapter.fromNodeNextRequest(request, signal);
    }
    static fromNodeNextRequest(request, signal) {
        // HEAD and GET requests can not have a body.
        let body = null;
        if (request.method !== "GET" && request.method !== "HEAD" && request.body) {
            // @ts-expect-error - this is handled by undici, when streams/web land use it instead
            body = request.body;
        }
        let url;
        if (request.url.startsWith("http")) {
            url = new URL(request.url);
        } else {
            // Grab the full URL from the request metadata.
            const base = (0, _requestmeta.getRequestMeta)(request, "initURL");
            if (!base || !base.startsWith("http")) {
                // Because the URL construction relies on the fact that the URL provided
                // is absolute, we need to provide a base URL. We can't use the request
                // URL because it's relative, so we use a dummy URL instead.
                url = new URL(request.url, "http://n");
            } else {
                url = new URL(request.url, base);
            }
        }
        return new _request.NextRequest(url, {
<<<<<<< HEAD
            body,
=======
>>>>>>> 4f9d35bd5c5bf095848f6fc99f7e7bfe5212365f
            method: request.method,
            headers: (0, _utils.fromNodeOutgoingHttpHeaders)(request.headers),
            // @ts-expect-error - see https://github.com/whatwg/fetch/pull/1457
            duplex: "half",
<<<<<<< HEAD
            signal
=======
            signal,
            // geo
            // ip
            // nextConfig
            // body can not be passed if request was aborted
            // or we get a Request body was disturbed error
            ...signal.aborted ? {} : {
                body
            }
>>>>>>> 4f9d35bd5c5bf095848f6fc99f7e7bfe5212365f
        });
    }
    static fromWebNextRequest(request) {
        // HEAD and GET requests can not have a body.
        let body = null;
        if (request.method !== "GET" && request.method !== "HEAD") {
            body = request.body;
        }
        return new _request.NextRequest(request.url, {
<<<<<<< HEAD
            body,
=======
>>>>>>> 4f9d35bd5c5bf095848f6fc99f7e7bfe5212365f
            method: request.method,
            headers: (0, _utils.fromNodeOutgoingHttpHeaders)(request.headers),
            // @ts-expect-error - see https://github.com/whatwg/fetch/pull/1457
            duplex: "half",
<<<<<<< HEAD
            signal: request.request.signal
=======
            signal: request.request.signal,
            // geo
            // ip
            // nextConfig
            // body can not be passed if request was aborted
            // or we get a Request body was disturbed error
            ...request.request.signal.aborted ? {} : {
                body
            }
>>>>>>> 4f9d35bd5c5bf095848f6fc99f7e7bfe5212365f
        });
    }
}

//# sourceMappingURL=next-request.js.map