
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Organization
 * 
 */
export type Organization = $Result.DefaultSelection<Prisma.$OrganizationPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model Subscription
 * 
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model Plan
 * 
 */
export type Plan = $Result.DefaultSelection<Prisma.$PlanPayload>
/**
 * Model PlanFeature
 * 
 */
export type PlanFeature = $Result.DefaultSelection<Prisma.$PlanFeaturePayload>
/**
 * Model UsageLimit
 * 
 */
export type UsageLimit = $Result.DefaultSelection<Prisma.$UsageLimitPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model UsageRecord
 * 
 */
export type UsageRecord = $Result.DefaultSelection<Prisma.$UsageRecordPayload>
/**
 * Model Report
 * 
 */
export type Report = $Result.DefaultSelection<Prisma.$ReportPayload>
/**
 * Model Metric
 * 
 */
export type Metric = $Result.DefaultSelection<Prisma.$MetricPayload>
/**
 * Model EmailNotification
 * 
 */
export type EmailNotification = $Result.DefaultSelection<Prisma.$EmailNotificationPayload>
/**
 * Model Webhook
 * 
 */
export type Webhook = $Result.DefaultSelection<Prisma.$WebhookPayload>
/**
 * Model WebhookDelivery
 * 
 */
export type WebhookDelivery = $Result.DefaultSelection<Prisma.$WebhookDeliveryPayload>
/**
 * Model RefreshToken
 * 
 */
export type RefreshToken = $Result.DefaultSelection<Prisma.$RefreshTokenPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model FinancingOffer
 * 
 */
export type FinancingOffer = $Result.DefaultSelection<Prisma.$FinancingOfferPayload>
/**
 * Model CarbonEstimate
 * 
 */
export type CarbonEstimate = $Result.DefaultSelection<Prisma.$CarbonEstimatePayload>
/**
 * Model BillingRule
 * 
 */
export type BillingRule = $Result.DefaultSelection<Prisma.$BillingRulePayload>
/**
 * Model BillingRuleTemplate
 * 
 */
export type BillingRuleTemplate = $Result.DefaultSelection<Prisma.$BillingRuleTemplatePayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model PriceHistory
 * 
 */
export type PriceHistory = $Result.DefaultSelection<Prisma.$PriceHistoryPayload>
/**
 * Model PriceTest
 * 
 */
export type PriceTest = $Result.DefaultSelection<Prisma.$PriceTestPayload>
/**
 * Model PriceTestVariant
 * 
 */
export type PriceTestVariant = $Result.DefaultSelection<Prisma.$PriceTestVariantPayload>
/**
 * Model MarketBenchmark
 * 
 */
export type MarketBenchmark = $Result.DefaultSelection<Prisma.$MarketBenchmarkPayload>
/**
 * Model RevenueRecognitionRule
 * 
 */
export type RevenueRecognitionRule = $Result.DefaultSelection<Prisma.$RevenueRecognitionRulePayload>
/**
 * Model RevenueLedger
 * 
 */
export type RevenueLedger = $Result.DefaultSelection<Prisma.$RevenueLedgerPayload>
/**
 * Model ChurnPrediction
 * 
 */
export type ChurnPrediction = $Result.DefaultSelection<Prisma.$ChurnPredictionPayload>
/**
 * Model CohortAnalysis
 * 
 */
export type CohortAnalysis = $Result.DefaultSelection<Prisma.$CohortAnalysisPayload>
/**
 * Model ForecastModel
 * 
 */
export type ForecastModel = $Result.DefaultSelection<Prisma.$ForecastModelPayload>
/**
 * Model TimeSeriesData
 * 
 */
export type TimeSeriesData = $Result.DefaultSelection<Prisma.$TimeSeriesDataPayload>
/**
 * Model ForecastResult
 * 
 */
export type ForecastResult = $Result.DefaultSelection<Prisma.$ForecastResultPayload>
/**
 * Model MarketTrend
 * 
 */
export type MarketTrend = $Result.DefaultSelection<Prisma.$MarketTrendPayload>
/**
 * Model PredictionInterval
 * 
 */
export type PredictionInterval = $Result.DefaultSelection<Prisma.$PredictionIntervalPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model ApiKey
 * 
 */
export type ApiKey = $Result.DefaultSelection<Prisma.$ApiKeyPayload>
/**
 * Model TaxCalculation
 * 
 */
export type TaxCalculation = $Result.DefaultSelection<Prisma.$TaxCalculationPayload>
/**
 * Model Alert
 * 
 */
export type Alert = $Result.DefaultSelection<Prisma.$AlertPayload>
/**
 * Model TaxRate
 * 
 */
export type TaxRate = $Result.DefaultSelection<Prisma.$TaxRatePayload>
/**
 * Model Bill
 * 
 */
export type Bill = $Result.DefaultSelection<Prisma.$BillPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model RetryAttempt
 * 
 */
export type RetryAttempt = $Result.DefaultSelection<Prisma.$RetryAttemptPayload>
/**
 * Model RetryLog
 * 
 */
export type RetryLog = $Result.DefaultSelection<Prisma.$RetryLogPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const SubscriptionStatus: {
  ACTIVE: 'ACTIVE',
  TRIALING: 'TRIALING',
  PAST_DUE: 'PAST_DUE',
  CANCELED: 'CANCELED',
  PAUSED: 'PAUSED',
  INCOMPLETE: 'INCOMPLETE',
  INCOMPLETE_EXPIRED: 'INCOMPLETE_EXPIRED'
};

export type SubscriptionStatus = (typeof SubscriptionStatus)[keyof typeof SubscriptionStatus]

}

export type SubscriptionStatus = $Enums.SubscriptionStatus

export const SubscriptionStatus: typeof $Enums.SubscriptionStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.organization`: Exposes CRUD operations for the **Organization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organizations
    * const organizations = await prisma.organization.findMany()
    * ```
    */
  get organization(): Prisma.OrganizationDelegate<ExtArgs>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs>;

  /**
   * `prisma.plan`: Exposes CRUD operations for the **Plan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plans
    * const plans = await prisma.plan.findMany()
    * ```
    */
  get plan(): Prisma.PlanDelegate<ExtArgs>;

  /**
   * `prisma.planFeature`: Exposes CRUD operations for the **PlanFeature** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlanFeatures
    * const planFeatures = await prisma.planFeature.findMany()
    * ```
    */
  get planFeature(): Prisma.PlanFeatureDelegate<ExtArgs>;

  /**
   * `prisma.usageLimit`: Exposes CRUD operations for the **UsageLimit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsageLimits
    * const usageLimits = await prisma.usageLimit.findMany()
    * ```
    */
  get usageLimit(): Prisma.UsageLimitDelegate<ExtArgs>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs>;

  /**
   * `prisma.usageRecord`: Exposes CRUD operations for the **UsageRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsageRecords
    * const usageRecords = await prisma.usageRecord.findMany()
    * ```
    */
  get usageRecord(): Prisma.UsageRecordDelegate<ExtArgs>;

  /**
   * `prisma.report`: Exposes CRUD operations for the **Report** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.report.findMany()
    * ```
    */
  get report(): Prisma.ReportDelegate<ExtArgs>;

  /**
   * `prisma.metric`: Exposes CRUD operations for the **Metric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Metrics
    * const metrics = await prisma.metric.findMany()
    * ```
    */
  get metric(): Prisma.MetricDelegate<ExtArgs>;

  /**
   * `prisma.emailNotification`: Exposes CRUD operations for the **EmailNotification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailNotifications
    * const emailNotifications = await prisma.emailNotification.findMany()
    * ```
    */
  get emailNotification(): Prisma.EmailNotificationDelegate<ExtArgs>;

  /**
   * `prisma.webhook`: Exposes CRUD operations for the **Webhook** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Webhooks
    * const webhooks = await prisma.webhook.findMany()
    * ```
    */
  get webhook(): Prisma.WebhookDelegate<ExtArgs>;

  /**
   * `prisma.webhookDelivery`: Exposes CRUD operations for the **WebhookDelivery** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WebhookDeliveries
    * const webhookDeliveries = await prisma.webhookDelivery.findMany()
    * ```
    */
  get webhookDelivery(): Prisma.WebhookDeliveryDelegate<ExtArgs>;

  /**
   * `prisma.refreshToken`: Exposes CRUD operations for the **RefreshToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefreshTokens
    * const refreshTokens = await prisma.refreshToken.findMany()
    * ```
    */
  get refreshToken(): Prisma.RefreshTokenDelegate<ExtArgs>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs>;

  /**
   * `prisma.financingOffer`: Exposes CRUD operations for the **FinancingOffer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FinancingOffers
    * const financingOffers = await prisma.financingOffer.findMany()
    * ```
    */
  get financingOffer(): Prisma.FinancingOfferDelegate<ExtArgs>;

  /**
   * `prisma.carbonEstimate`: Exposes CRUD operations for the **CarbonEstimate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CarbonEstimates
    * const carbonEstimates = await prisma.carbonEstimate.findMany()
    * ```
    */
  get carbonEstimate(): Prisma.CarbonEstimateDelegate<ExtArgs>;

  /**
   * `prisma.billingRule`: Exposes CRUD operations for the **BillingRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BillingRules
    * const billingRules = await prisma.billingRule.findMany()
    * ```
    */
  get billingRule(): Prisma.BillingRuleDelegate<ExtArgs>;

  /**
   * `prisma.billingRuleTemplate`: Exposes CRUD operations for the **BillingRuleTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BillingRuleTemplates
    * const billingRuleTemplates = await prisma.billingRuleTemplate.findMany()
    * ```
    */
  get billingRuleTemplate(): Prisma.BillingRuleTemplateDelegate<ExtArgs>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs>;

  /**
   * `prisma.priceHistory`: Exposes CRUD operations for the **PriceHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PriceHistories
    * const priceHistories = await prisma.priceHistory.findMany()
    * ```
    */
  get priceHistory(): Prisma.PriceHistoryDelegate<ExtArgs>;

  /**
   * `prisma.priceTest`: Exposes CRUD operations for the **PriceTest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PriceTests
    * const priceTests = await prisma.priceTest.findMany()
    * ```
    */
  get priceTest(): Prisma.PriceTestDelegate<ExtArgs>;

  /**
   * `prisma.priceTestVariant`: Exposes CRUD operations for the **PriceTestVariant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PriceTestVariants
    * const priceTestVariants = await prisma.priceTestVariant.findMany()
    * ```
    */
  get priceTestVariant(): Prisma.PriceTestVariantDelegate<ExtArgs>;

  /**
   * `prisma.marketBenchmark`: Exposes CRUD operations for the **MarketBenchmark** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MarketBenchmarks
    * const marketBenchmarks = await prisma.marketBenchmark.findMany()
    * ```
    */
  get marketBenchmark(): Prisma.MarketBenchmarkDelegate<ExtArgs>;

  /**
   * `prisma.revenueRecognitionRule`: Exposes CRUD operations for the **RevenueRecognitionRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RevenueRecognitionRules
    * const revenueRecognitionRules = await prisma.revenueRecognitionRule.findMany()
    * ```
    */
  get revenueRecognitionRule(): Prisma.RevenueRecognitionRuleDelegate<ExtArgs>;

  /**
   * `prisma.revenueLedger`: Exposes CRUD operations for the **RevenueLedger** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RevenueLedgers
    * const revenueLedgers = await prisma.revenueLedger.findMany()
    * ```
    */
  get revenueLedger(): Prisma.RevenueLedgerDelegate<ExtArgs>;

  /**
   * `prisma.churnPrediction`: Exposes CRUD operations for the **ChurnPrediction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChurnPredictions
    * const churnPredictions = await prisma.churnPrediction.findMany()
    * ```
    */
  get churnPrediction(): Prisma.ChurnPredictionDelegate<ExtArgs>;

  /**
   * `prisma.cohortAnalysis`: Exposes CRUD operations for the **CohortAnalysis** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CohortAnalyses
    * const cohortAnalyses = await prisma.cohortAnalysis.findMany()
    * ```
    */
  get cohortAnalysis(): Prisma.CohortAnalysisDelegate<ExtArgs>;

  /**
   * `prisma.forecastModel`: Exposes CRUD operations for the **ForecastModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ForecastModels
    * const forecastModels = await prisma.forecastModel.findMany()
    * ```
    */
  get forecastModel(): Prisma.ForecastModelDelegate<ExtArgs>;

  /**
   * `prisma.timeSeriesData`: Exposes CRUD operations for the **TimeSeriesData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TimeSeriesData
    * const timeSeriesData = await prisma.timeSeriesData.findMany()
    * ```
    */
  get timeSeriesData(): Prisma.TimeSeriesDataDelegate<ExtArgs>;

  /**
   * `prisma.forecastResult`: Exposes CRUD operations for the **ForecastResult** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ForecastResults
    * const forecastResults = await prisma.forecastResult.findMany()
    * ```
    */
  get forecastResult(): Prisma.ForecastResultDelegate<ExtArgs>;

  /**
   * `prisma.marketTrend`: Exposes CRUD operations for the **MarketTrend** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MarketTrends
    * const marketTrends = await prisma.marketTrend.findMany()
    * ```
    */
  get marketTrend(): Prisma.MarketTrendDelegate<ExtArgs>;

  /**
   * `prisma.predictionInterval`: Exposes CRUD operations for the **PredictionInterval** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PredictionIntervals
    * const predictionIntervals = await prisma.predictionInterval.findMany()
    * ```
    */
  get predictionInterval(): Prisma.PredictionIntervalDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.apiKey`: Exposes CRUD operations for the **ApiKey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApiKeys
    * const apiKeys = await prisma.apiKey.findMany()
    * ```
    */
  get apiKey(): Prisma.ApiKeyDelegate<ExtArgs>;

  /**
   * `prisma.taxCalculation`: Exposes CRUD operations for the **TaxCalculation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaxCalculations
    * const taxCalculations = await prisma.taxCalculation.findMany()
    * ```
    */
  get taxCalculation(): Prisma.TaxCalculationDelegate<ExtArgs>;

  /**
   * `prisma.alert`: Exposes CRUD operations for the **Alert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Alerts
    * const alerts = await prisma.alert.findMany()
    * ```
    */
  get alert(): Prisma.AlertDelegate<ExtArgs>;

  /**
   * `prisma.taxRate`: Exposes CRUD operations for the **TaxRate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaxRates
    * const taxRates = await prisma.taxRate.findMany()
    * ```
    */
  get taxRate(): Prisma.TaxRateDelegate<ExtArgs>;

  /**
   * `prisma.bill`: Exposes CRUD operations for the **Bill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bills
    * const bills = await prisma.bill.findMany()
    * ```
    */
  get bill(): Prisma.BillDelegate<ExtArgs>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs>;

  /**
   * `prisma.retryAttempt`: Exposes CRUD operations for the **RetryAttempt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RetryAttempts
    * const retryAttempts = await prisma.retryAttempt.findMany()
    * ```
    */
  get retryAttempt(): Prisma.RetryAttemptDelegate<ExtArgs>;

  /**
   * `prisma.retryLog`: Exposes CRUD operations for the **RetryLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RetryLogs
    * const retryLogs = await prisma.retryLog.findMany()
    * ```
    */
  get retryLog(): Prisma.RetryLogDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Organization: 'Organization',
    Customer: 'Customer',
    Subscription: 'Subscription',
    Plan: 'Plan',
    PlanFeature: 'PlanFeature',
    UsageLimit: 'UsageLimit',
    Invoice: 'Invoice',
    UsageRecord: 'UsageRecord',
    Report: 'Report',
    Metric: 'Metric',
    EmailNotification: 'EmailNotification',
    Webhook: 'Webhook',
    WebhookDelivery: 'WebhookDelivery',
    RefreshToken: 'RefreshToken',
    Payment: 'Payment',
    FinancingOffer: 'FinancingOffer',
    CarbonEstimate: 'CarbonEstimate',
    BillingRule: 'BillingRule',
    BillingRuleTemplate: 'BillingRuleTemplate',
    Order: 'Order',
    PriceHistory: 'PriceHistory',
    PriceTest: 'PriceTest',
    PriceTestVariant: 'PriceTestVariant',
    MarketBenchmark: 'MarketBenchmark',
    RevenueRecognitionRule: 'RevenueRecognitionRule',
    RevenueLedger: 'RevenueLedger',
    ChurnPrediction: 'ChurnPrediction',
    CohortAnalysis: 'CohortAnalysis',
    ForecastModel: 'ForecastModel',
    TimeSeriesData: 'TimeSeriesData',
    ForecastResult: 'ForecastResult',
    MarketTrend: 'MarketTrend',
    PredictionInterval: 'PredictionInterval',
    Notification: 'Notification',
    ApiKey: 'ApiKey',
    TaxCalculation: 'TaxCalculation',
    Alert: 'Alert',
    TaxRate: 'TaxRate',
    Bill: 'Bill',
    Transaction: 'Transaction',
    RetryAttempt: 'RetryAttempt',
    RetryLog: 'RetryLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "organization" | "customer" | "subscription" | "plan" | "planFeature" | "usageLimit" | "invoice" | "usageRecord" | "report" | "metric" | "emailNotification" | "webhook" | "webhookDelivery" | "refreshToken" | "payment" | "financingOffer" | "carbonEstimate" | "billingRule" | "billingRuleTemplate" | "order" | "priceHistory" | "priceTest" | "priceTestVariant" | "marketBenchmark" | "revenueRecognitionRule" | "revenueLedger" | "churnPrediction" | "cohortAnalysis" | "forecastModel" | "timeSeriesData" | "forecastResult" | "marketTrend" | "predictionInterval" | "notification" | "apiKey" | "taxCalculation" | "alert" | "taxRate" | "bill" | "transaction" | "retryAttempt" | "retryLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Organization: {
        payload: Prisma.$OrganizationPayload<ExtArgs>
        fields: Prisma.OrganizationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findFirst: {
            args: Prisma.OrganizationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findMany: {
            args: Prisma.OrganizationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          create: {
            args: Prisma.OrganizationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          createMany: {
            args: Prisma.OrganizationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrganizationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          delete: {
            args: Prisma.OrganizationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          update: {
            args: Prisma.OrganizationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrganizationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          aggregate: {
            args: Prisma.OrganizationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganization>
          }
          groupBy: {
            args: Prisma.OrganizationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      Plan: {
        payload: Prisma.$PlanPayload<ExtArgs>
        fields: Prisma.PlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          findFirst: {
            args: Prisma.PlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          findMany: {
            args: Prisma.PlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>[]
          }
          create: {
            args: Prisma.PlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          createMany: {
            args: Prisma.PlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>[]
          }
          delete: {
            args: Prisma.PlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          update: {
            args: Prisma.PlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          deleteMany: {
            args: Prisma.PlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          aggregate: {
            args: Prisma.PlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlan>
          }
          groupBy: {
            args: Prisma.PlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanCountArgs<ExtArgs>
            result: $Utils.Optional<PlanCountAggregateOutputType> | number
          }
        }
      }
      PlanFeature: {
        payload: Prisma.$PlanFeaturePayload<ExtArgs>
        fields: Prisma.PlanFeatureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanFeatureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanFeaturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanFeatureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanFeaturePayload>
          }
          findFirst: {
            args: Prisma.PlanFeatureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanFeaturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanFeatureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanFeaturePayload>
          }
          findMany: {
            args: Prisma.PlanFeatureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanFeaturePayload>[]
          }
          create: {
            args: Prisma.PlanFeatureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanFeaturePayload>
          }
          createMany: {
            args: Prisma.PlanFeatureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlanFeatureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanFeaturePayload>[]
          }
          delete: {
            args: Prisma.PlanFeatureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanFeaturePayload>
          }
          update: {
            args: Prisma.PlanFeatureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanFeaturePayload>
          }
          deleteMany: {
            args: Prisma.PlanFeatureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanFeatureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlanFeatureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanFeaturePayload>
          }
          aggregate: {
            args: Prisma.PlanFeatureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlanFeature>
          }
          groupBy: {
            args: Prisma.PlanFeatureGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanFeatureGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanFeatureCountArgs<ExtArgs>
            result: $Utils.Optional<PlanFeatureCountAggregateOutputType> | number
          }
        }
      }
      UsageLimit: {
        payload: Prisma.$UsageLimitPayload<ExtArgs>
        fields: Prisma.UsageLimitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsageLimitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageLimitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsageLimitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageLimitPayload>
          }
          findFirst: {
            args: Prisma.UsageLimitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageLimitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsageLimitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageLimitPayload>
          }
          findMany: {
            args: Prisma.UsageLimitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageLimitPayload>[]
          }
          create: {
            args: Prisma.UsageLimitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageLimitPayload>
          }
          createMany: {
            args: Prisma.UsageLimitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsageLimitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageLimitPayload>[]
          }
          delete: {
            args: Prisma.UsageLimitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageLimitPayload>
          }
          update: {
            args: Prisma.UsageLimitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageLimitPayload>
          }
          deleteMany: {
            args: Prisma.UsageLimitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsageLimitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsageLimitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageLimitPayload>
          }
          aggregate: {
            args: Prisma.UsageLimitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsageLimit>
          }
          groupBy: {
            args: Prisma.UsageLimitGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsageLimitGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsageLimitCountArgs<ExtArgs>
            result: $Utils.Optional<UsageLimitCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      UsageRecord: {
        payload: Prisma.$UsageRecordPayload<ExtArgs>
        fields: Prisma.UsageRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsageRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsageRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageRecordPayload>
          }
          findFirst: {
            args: Prisma.UsageRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsageRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageRecordPayload>
          }
          findMany: {
            args: Prisma.UsageRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageRecordPayload>[]
          }
          create: {
            args: Prisma.UsageRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageRecordPayload>
          }
          createMany: {
            args: Prisma.UsageRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsageRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageRecordPayload>[]
          }
          delete: {
            args: Prisma.UsageRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageRecordPayload>
          }
          update: {
            args: Prisma.UsageRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageRecordPayload>
          }
          deleteMany: {
            args: Prisma.UsageRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsageRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsageRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageRecordPayload>
          }
          aggregate: {
            args: Prisma.UsageRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsageRecord>
          }
          groupBy: {
            args: Prisma.UsageRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsageRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsageRecordCountArgs<ExtArgs>
            result: $Utils.Optional<UsageRecordCountAggregateOutputType> | number
          }
        }
      }
      Report: {
        payload: Prisma.$ReportPayload<ExtArgs>
        fields: Prisma.ReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findFirst: {
            args: Prisma.ReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findMany: {
            args: Prisma.ReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          create: {
            args: Prisma.ReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          createMany: {
            args: Prisma.ReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          delete: {
            args: Prisma.ReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          update: {
            args: Prisma.ReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          deleteMany: {
            args: Prisma.ReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          aggregate: {
            args: Prisma.ReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReport>
          }
          groupBy: {
            args: Prisma.ReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportCountArgs<ExtArgs>
            result: $Utils.Optional<ReportCountAggregateOutputType> | number
          }
        }
      }
      Metric: {
        payload: Prisma.$MetricPayload<ExtArgs>
        fields: Prisma.MetricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MetricFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MetricFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricPayload>
          }
          findFirst: {
            args: Prisma.MetricFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MetricFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricPayload>
          }
          findMany: {
            args: Prisma.MetricFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricPayload>[]
          }
          create: {
            args: Prisma.MetricCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricPayload>
          }
          createMany: {
            args: Prisma.MetricCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MetricCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricPayload>[]
          }
          delete: {
            args: Prisma.MetricDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricPayload>
          }
          update: {
            args: Prisma.MetricUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricPayload>
          }
          deleteMany: {
            args: Prisma.MetricDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MetricUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MetricUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricPayload>
          }
          aggregate: {
            args: Prisma.MetricAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMetric>
          }
          groupBy: {
            args: Prisma.MetricGroupByArgs<ExtArgs>
            result: $Utils.Optional<MetricGroupByOutputType>[]
          }
          count: {
            args: Prisma.MetricCountArgs<ExtArgs>
            result: $Utils.Optional<MetricCountAggregateOutputType> | number
          }
        }
      }
      EmailNotification: {
        payload: Prisma.$EmailNotificationPayload<ExtArgs>
        fields: Prisma.EmailNotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailNotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailNotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailNotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailNotificationPayload>
          }
          findFirst: {
            args: Prisma.EmailNotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailNotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailNotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailNotificationPayload>
          }
          findMany: {
            args: Prisma.EmailNotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailNotificationPayload>[]
          }
          create: {
            args: Prisma.EmailNotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailNotificationPayload>
          }
          createMany: {
            args: Prisma.EmailNotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailNotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailNotificationPayload>[]
          }
          delete: {
            args: Prisma.EmailNotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailNotificationPayload>
          }
          update: {
            args: Prisma.EmailNotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailNotificationPayload>
          }
          deleteMany: {
            args: Prisma.EmailNotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailNotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmailNotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailNotificationPayload>
          }
          aggregate: {
            args: Prisma.EmailNotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailNotification>
          }
          groupBy: {
            args: Prisma.EmailNotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailNotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailNotificationCountArgs<ExtArgs>
            result: $Utils.Optional<EmailNotificationCountAggregateOutputType> | number
          }
        }
      }
      Webhook: {
        payload: Prisma.$WebhookPayload<ExtArgs>
        fields: Prisma.WebhookFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebhookFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebhookFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          findFirst: {
            args: Prisma.WebhookFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebhookFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          findMany: {
            args: Prisma.WebhookFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>[]
          }
          create: {
            args: Prisma.WebhookCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          createMany: {
            args: Prisma.WebhookCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WebhookCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>[]
          }
          delete: {
            args: Prisma.WebhookDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          update: {
            args: Prisma.WebhookUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          deleteMany: {
            args: Prisma.WebhookDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebhookUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WebhookUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          aggregate: {
            args: Prisma.WebhookAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebhook>
          }
          groupBy: {
            args: Prisma.WebhookGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebhookGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebhookCountArgs<ExtArgs>
            result: $Utils.Optional<WebhookCountAggregateOutputType> | number
          }
        }
      }
      WebhookDelivery: {
        payload: Prisma.$WebhookDeliveryPayload<ExtArgs>
        fields: Prisma.WebhookDeliveryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebhookDeliveryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebhookDeliveryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          findFirst: {
            args: Prisma.WebhookDeliveryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebhookDeliveryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          findMany: {
            args: Prisma.WebhookDeliveryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>[]
          }
          create: {
            args: Prisma.WebhookDeliveryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          createMany: {
            args: Prisma.WebhookDeliveryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WebhookDeliveryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>[]
          }
          delete: {
            args: Prisma.WebhookDeliveryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          update: {
            args: Prisma.WebhookDeliveryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          deleteMany: {
            args: Prisma.WebhookDeliveryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebhookDeliveryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WebhookDeliveryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          aggregate: {
            args: Prisma.WebhookDeliveryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebhookDelivery>
          }
          groupBy: {
            args: Prisma.WebhookDeliveryGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebhookDeliveryGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebhookDeliveryCountArgs<ExtArgs>
            result: $Utils.Optional<WebhookDeliveryCountAggregateOutputType> | number
          }
        }
      }
      RefreshToken: {
        payload: Prisma.$RefreshTokenPayload<ExtArgs>
        fields: Prisma.RefreshTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findFirst: {
            args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findMany: {
            args: Prisma.RefreshTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          create: {
            args: Prisma.RefreshTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          createMany: {
            args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefreshTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          delete: {
            args: Prisma.RefreshTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          update: {
            args: Prisma.RefreshTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          deleteMany: {
            args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RefreshTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          aggregate: {
            args: Prisma.RefreshTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefreshToken>
          }
          groupBy: {
            args: Prisma.RefreshTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefreshTokenCountArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      FinancingOffer: {
        payload: Prisma.$FinancingOfferPayload<ExtArgs>
        fields: Prisma.FinancingOfferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FinancingOfferFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancingOfferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FinancingOfferFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancingOfferPayload>
          }
          findFirst: {
            args: Prisma.FinancingOfferFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancingOfferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FinancingOfferFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancingOfferPayload>
          }
          findMany: {
            args: Prisma.FinancingOfferFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancingOfferPayload>[]
          }
          create: {
            args: Prisma.FinancingOfferCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancingOfferPayload>
          }
          createMany: {
            args: Prisma.FinancingOfferCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FinancingOfferCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancingOfferPayload>[]
          }
          delete: {
            args: Prisma.FinancingOfferDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancingOfferPayload>
          }
          update: {
            args: Prisma.FinancingOfferUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancingOfferPayload>
          }
          deleteMany: {
            args: Prisma.FinancingOfferDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FinancingOfferUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FinancingOfferUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancingOfferPayload>
          }
          aggregate: {
            args: Prisma.FinancingOfferAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFinancingOffer>
          }
          groupBy: {
            args: Prisma.FinancingOfferGroupByArgs<ExtArgs>
            result: $Utils.Optional<FinancingOfferGroupByOutputType>[]
          }
          count: {
            args: Prisma.FinancingOfferCountArgs<ExtArgs>
            result: $Utils.Optional<FinancingOfferCountAggregateOutputType> | number
          }
        }
      }
      CarbonEstimate: {
        payload: Prisma.$CarbonEstimatePayload<ExtArgs>
        fields: Prisma.CarbonEstimateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CarbonEstimateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarbonEstimatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CarbonEstimateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarbonEstimatePayload>
          }
          findFirst: {
            args: Prisma.CarbonEstimateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarbonEstimatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CarbonEstimateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarbonEstimatePayload>
          }
          findMany: {
            args: Prisma.CarbonEstimateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarbonEstimatePayload>[]
          }
          create: {
            args: Prisma.CarbonEstimateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarbonEstimatePayload>
          }
          createMany: {
            args: Prisma.CarbonEstimateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CarbonEstimateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarbonEstimatePayload>[]
          }
          delete: {
            args: Prisma.CarbonEstimateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarbonEstimatePayload>
          }
          update: {
            args: Prisma.CarbonEstimateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarbonEstimatePayload>
          }
          deleteMany: {
            args: Prisma.CarbonEstimateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CarbonEstimateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CarbonEstimateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarbonEstimatePayload>
          }
          aggregate: {
            args: Prisma.CarbonEstimateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCarbonEstimate>
          }
          groupBy: {
            args: Prisma.CarbonEstimateGroupByArgs<ExtArgs>
            result: $Utils.Optional<CarbonEstimateGroupByOutputType>[]
          }
          count: {
            args: Prisma.CarbonEstimateCountArgs<ExtArgs>
            result: $Utils.Optional<CarbonEstimateCountAggregateOutputType> | number
          }
        }
      }
      BillingRule: {
        payload: Prisma.$BillingRulePayload<ExtArgs>
        fields: Prisma.BillingRuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BillingRuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingRulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BillingRuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingRulePayload>
          }
          findFirst: {
            args: Prisma.BillingRuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingRulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BillingRuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingRulePayload>
          }
          findMany: {
            args: Prisma.BillingRuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingRulePayload>[]
          }
          create: {
            args: Prisma.BillingRuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingRulePayload>
          }
          createMany: {
            args: Prisma.BillingRuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BillingRuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingRulePayload>[]
          }
          delete: {
            args: Prisma.BillingRuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingRulePayload>
          }
          update: {
            args: Prisma.BillingRuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingRulePayload>
          }
          deleteMany: {
            args: Prisma.BillingRuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BillingRuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BillingRuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingRulePayload>
          }
          aggregate: {
            args: Prisma.BillingRuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBillingRule>
          }
          groupBy: {
            args: Prisma.BillingRuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<BillingRuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.BillingRuleCountArgs<ExtArgs>
            result: $Utils.Optional<BillingRuleCountAggregateOutputType> | number
          }
        }
      }
      BillingRuleTemplate: {
        payload: Prisma.$BillingRuleTemplatePayload<ExtArgs>
        fields: Prisma.BillingRuleTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BillingRuleTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingRuleTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BillingRuleTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingRuleTemplatePayload>
          }
          findFirst: {
            args: Prisma.BillingRuleTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingRuleTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BillingRuleTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingRuleTemplatePayload>
          }
          findMany: {
            args: Prisma.BillingRuleTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingRuleTemplatePayload>[]
          }
          create: {
            args: Prisma.BillingRuleTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingRuleTemplatePayload>
          }
          createMany: {
            args: Prisma.BillingRuleTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BillingRuleTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingRuleTemplatePayload>[]
          }
          delete: {
            args: Prisma.BillingRuleTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingRuleTemplatePayload>
          }
          update: {
            args: Prisma.BillingRuleTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingRuleTemplatePayload>
          }
          deleteMany: {
            args: Prisma.BillingRuleTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BillingRuleTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BillingRuleTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingRuleTemplatePayload>
          }
          aggregate: {
            args: Prisma.BillingRuleTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBillingRuleTemplate>
          }
          groupBy: {
            args: Prisma.BillingRuleTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<BillingRuleTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.BillingRuleTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<BillingRuleTemplateCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      PriceHistory: {
        payload: Prisma.$PriceHistoryPayload<ExtArgs>
        fields: Prisma.PriceHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PriceHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PriceHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload>
          }
          findFirst: {
            args: Prisma.PriceHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PriceHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload>
          }
          findMany: {
            args: Prisma.PriceHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload>[]
          }
          create: {
            args: Prisma.PriceHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload>
          }
          createMany: {
            args: Prisma.PriceHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PriceHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload>[]
          }
          delete: {
            args: Prisma.PriceHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload>
          }
          update: {
            args: Prisma.PriceHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload>
          }
          deleteMany: {
            args: Prisma.PriceHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PriceHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PriceHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload>
          }
          aggregate: {
            args: Prisma.PriceHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePriceHistory>
          }
          groupBy: {
            args: Prisma.PriceHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<PriceHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.PriceHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<PriceHistoryCountAggregateOutputType> | number
          }
        }
      }
      PriceTest: {
        payload: Prisma.$PriceTestPayload<ExtArgs>
        fields: Prisma.PriceTestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PriceTestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceTestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PriceTestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceTestPayload>
          }
          findFirst: {
            args: Prisma.PriceTestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceTestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PriceTestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceTestPayload>
          }
          findMany: {
            args: Prisma.PriceTestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceTestPayload>[]
          }
          create: {
            args: Prisma.PriceTestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceTestPayload>
          }
          createMany: {
            args: Prisma.PriceTestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PriceTestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceTestPayload>[]
          }
          delete: {
            args: Prisma.PriceTestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceTestPayload>
          }
          update: {
            args: Prisma.PriceTestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceTestPayload>
          }
          deleteMany: {
            args: Prisma.PriceTestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PriceTestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PriceTestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceTestPayload>
          }
          aggregate: {
            args: Prisma.PriceTestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePriceTest>
          }
          groupBy: {
            args: Prisma.PriceTestGroupByArgs<ExtArgs>
            result: $Utils.Optional<PriceTestGroupByOutputType>[]
          }
          count: {
            args: Prisma.PriceTestCountArgs<ExtArgs>
            result: $Utils.Optional<PriceTestCountAggregateOutputType> | number
          }
        }
      }
      PriceTestVariant: {
        payload: Prisma.$PriceTestVariantPayload<ExtArgs>
        fields: Prisma.PriceTestVariantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PriceTestVariantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceTestVariantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PriceTestVariantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceTestVariantPayload>
          }
          findFirst: {
            args: Prisma.PriceTestVariantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceTestVariantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PriceTestVariantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceTestVariantPayload>
          }
          findMany: {
            args: Prisma.PriceTestVariantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceTestVariantPayload>[]
          }
          create: {
            args: Prisma.PriceTestVariantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceTestVariantPayload>
          }
          createMany: {
            args: Prisma.PriceTestVariantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PriceTestVariantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceTestVariantPayload>[]
          }
          delete: {
            args: Prisma.PriceTestVariantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceTestVariantPayload>
          }
          update: {
            args: Prisma.PriceTestVariantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceTestVariantPayload>
          }
          deleteMany: {
            args: Prisma.PriceTestVariantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PriceTestVariantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PriceTestVariantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceTestVariantPayload>
          }
          aggregate: {
            args: Prisma.PriceTestVariantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePriceTestVariant>
          }
          groupBy: {
            args: Prisma.PriceTestVariantGroupByArgs<ExtArgs>
            result: $Utils.Optional<PriceTestVariantGroupByOutputType>[]
          }
          count: {
            args: Prisma.PriceTestVariantCountArgs<ExtArgs>
            result: $Utils.Optional<PriceTestVariantCountAggregateOutputType> | number
          }
        }
      }
      MarketBenchmark: {
        payload: Prisma.$MarketBenchmarkPayload<ExtArgs>
        fields: Prisma.MarketBenchmarkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MarketBenchmarkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketBenchmarkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MarketBenchmarkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketBenchmarkPayload>
          }
          findFirst: {
            args: Prisma.MarketBenchmarkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketBenchmarkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MarketBenchmarkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketBenchmarkPayload>
          }
          findMany: {
            args: Prisma.MarketBenchmarkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketBenchmarkPayload>[]
          }
          create: {
            args: Prisma.MarketBenchmarkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketBenchmarkPayload>
          }
          createMany: {
            args: Prisma.MarketBenchmarkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MarketBenchmarkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketBenchmarkPayload>[]
          }
          delete: {
            args: Prisma.MarketBenchmarkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketBenchmarkPayload>
          }
          update: {
            args: Prisma.MarketBenchmarkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketBenchmarkPayload>
          }
          deleteMany: {
            args: Prisma.MarketBenchmarkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MarketBenchmarkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MarketBenchmarkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketBenchmarkPayload>
          }
          aggregate: {
            args: Prisma.MarketBenchmarkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMarketBenchmark>
          }
          groupBy: {
            args: Prisma.MarketBenchmarkGroupByArgs<ExtArgs>
            result: $Utils.Optional<MarketBenchmarkGroupByOutputType>[]
          }
          count: {
            args: Prisma.MarketBenchmarkCountArgs<ExtArgs>
            result: $Utils.Optional<MarketBenchmarkCountAggregateOutputType> | number
          }
        }
      }
      RevenueRecognitionRule: {
        payload: Prisma.$RevenueRecognitionRulePayload<ExtArgs>
        fields: Prisma.RevenueRecognitionRuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RevenueRecognitionRuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueRecognitionRulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RevenueRecognitionRuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueRecognitionRulePayload>
          }
          findFirst: {
            args: Prisma.RevenueRecognitionRuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueRecognitionRulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RevenueRecognitionRuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueRecognitionRulePayload>
          }
          findMany: {
            args: Prisma.RevenueRecognitionRuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueRecognitionRulePayload>[]
          }
          create: {
            args: Prisma.RevenueRecognitionRuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueRecognitionRulePayload>
          }
          createMany: {
            args: Prisma.RevenueRecognitionRuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RevenueRecognitionRuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueRecognitionRulePayload>[]
          }
          delete: {
            args: Prisma.RevenueRecognitionRuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueRecognitionRulePayload>
          }
          update: {
            args: Prisma.RevenueRecognitionRuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueRecognitionRulePayload>
          }
          deleteMany: {
            args: Prisma.RevenueRecognitionRuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RevenueRecognitionRuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RevenueRecognitionRuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueRecognitionRulePayload>
          }
          aggregate: {
            args: Prisma.RevenueRecognitionRuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRevenueRecognitionRule>
          }
          groupBy: {
            args: Prisma.RevenueRecognitionRuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RevenueRecognitionRuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RevenueRecognitionRuleCountArgs<ExtArgs>
            result: $Utils.Optional<RevenueRecognitionRuleCountAggregateOutputType> | number
          }
        }
      }
      RevenueLedger: {
        payload: Prisma.$RevenueLedgerPayload<ExtArgs>
        fields: Prisma.RevenueLedgerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RevenueLedgerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueLedgerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RevenueLedgerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueLedgerPayload>
          }
          findFirst: {
            args: Prisma.RevenueLedgerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueLedgerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RevenueLedgerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueLedgerPayload>
          }
          findMany: {
            args: Prisma.RevenueLedgerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueLedgerPayload>[]
          }
          create: {
            args: Prisma.RevenueLedgerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueLedgerPayload>
          }
          createMany: {
            args: Prisma.RevenueLedgerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RevenueLedgerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueLedgerPayload>[]
          }
          delete: {
            args: Prisma.RevenueLedgerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueLedgerPayload>
          }
          update: {
            args: Prisma.RevenueLedgerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueLedgerPayload>
          }
          deleteMany: {
            args: Prisma.RevenueLedgerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RevenueLedgerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RevenueLedgerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueLedgerPayload>
          }
          aggregate: {
            args: Prisma.RevenueLedgerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRevenueLedger>
          }
          groupBy: {
            args: Prisma.RevenueLedgerGroupByArgs<ExtArgs>
            result: $Utils.Optional<RevenueLedgerGroupByOutputType>[]
          }
          count: {
            args: Prisma.RevenueLedgerCountArgs<ExtArgs>
            result: $Utils.Optional<RevenueLedgerCountAggregateOutputType> | number
          }
        }
      }
      ChurnPrediction: {
        payload: Prisma.$ChurnPredictionPayload<ExtArgs>
        fields: Prisma.ChurnPredictionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChurnPredictionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChurnPredictionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChurnPredictionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChurnPredictionPayload>
          }
          findFirst: {
            args: Prisma.ChurnPredictionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChurnPredictionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChurnPredictionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChurnPredictionPayload>
          }
          findMany: {
            args: Prisma.ChurnPredictionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChurnPredictionPayload>[]
          }
          create: {
            args: Prisma.ChurnPredictionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChurnPredictionPayload>
          }
          createMany: {
            args: Prisma.ChurnPredictionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChurnPredictionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChurnPredictionPayload>[]
          }
          delete: {
            args: Prisma.ChurnPredictionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChurnPredictionPayload>
          }
          update: {
            args: Prisma.ChurnPredictionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChurnPredictionPayload>
          }
          deleteMany: {
            args: Prisma.ChurnPredictionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChurnPredictionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChurnPredictionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChurnPredictionPayload>
          }
          aggregate: {
            args: Prisma.ChurnPredictionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChurnPrediction>
          }
          groupBy: {
            args: Prisma.ChurnPredictionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChurnPredictionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChurnPredictionCountArgs<ExtArgs>
            result: $Utils.Optional<ChurnPredictionCountAggregateOutputType> | number
          }
        }
      }
      CohortAnalysis: {
        payload: Prisma.$CohortAnalysisPayload<ExtArgs>
        fields: Prisma.CohortAnalysisFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CohortAnalysisFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CohortAnalysisPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CohortAnalysisFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CohortAnalysisPayload>
          }
          findFirst: {
            args: Prisma.CohortAnalysisFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CohortAnalysisPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CohortAnalysisFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CohortAnalysisPayload>
          }
          findMany: {
            args: Prisma.CohortAnalysisFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CohortAnalysisPayload>[]
          }
          create: {
            args: Prisma.CohortAnalysisCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CohortAnalysisPayload>
          }
          createMany: {
            args: Prisma.CohortAnalysisCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CohortAnalysisCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CohortAnalysisPayload>[]
          }
          delete: {
            args: Prisma.CohortAnalysisDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CohortAnalysisPayload>
          }
          update: {
            args: Prisma.CohortAnalysisUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CohortAnalysisPayload>
          }
          deleteMany: {
            args: Prisma.CohortAnalysisDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CohortAnalysisUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CohortAnalysisUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CohortAnalysisPayload>
          }
          aggregate: {
            args: Prisma.CohortAnalysisAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCohortAnalysis>
          }
          groupBy: {
            args: Prisma.CohortAnalysisGroupByArgs<ExtArgs>
            result: $Utils.Optional<CohortAnalysisGroupByOutputType>[]
          }
          count: {
            args: Prisma.CohortAnalysisCountArgs<ExtArgs>
            result: $Utils.Optional<CohortAnalysisCountAggregateOutputType> | number
          }
        }
      }
      ForecastModel: {
        payload: Prisma.$ForecastModelPayload<ExtArgs>
        fields: Prisma.ForecastModelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ForecastModelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForecastModelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ForecastModelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForecastModelPayload>
          }
          findFirst: {
            args: Prisma.ForecastModelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForecastModelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ForecastModelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForecastModelPayload>
          }
          findMany: {
            args: Prisma.ForecastModelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForecastModelPayload>[]
          }
          create: {
            args: Prisma.ForecastModelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForecastModelPayload>
          }
          createMany: {
            args: Prisma.ForecastModelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ForecastModelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForecastModelPayload>[]
          }
          delete: {
            args: Prisma.ForecastModelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForecastModelPayload>
          }
          update: {
            args: Prisma.ForecastModelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForecastModelPayload>
          }
          deleteMany: {
            args: Prisma.ForecastModelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ForecastModelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ForecastModelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForecastModelPayload>
          }
          aggregate: {
            args: Prisma.ForecastModelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateForecastModel>
          }
          groupBy: {
            args: Prisma.ForecastModelGroupByArgs<ExtArgs>
            result: $Utils.Optional<ForecastModelGroupByOutputType>[]
          }
          count: {
            args: Prisma.ForecastModelCountArgs<ExtArgs>
            result: $Utils.Optional<ForecastModelCountAggregateOutputType> | number
          }
        }
      }
      TimeSeriesData: {
        payload: Prisma.$TimeSeriesDataPayload<ExtArgs>
        fields: Prisma.TimeSeriesDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TimeSeriesDataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSeriesDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TimeSeriesDataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSeriesDataPayload>
          }
          findFirst: {
            args: Prisma.TimeSeriesDataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSeriesDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TimeSeriesDataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSeriesDataPayload>
          }
          findMany: {
            args: Prisma.TimeSeriesDataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSeriesDataPayload>[]
          }
          create: {
            args: Prisma.TimeSeriesDataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSeriesDataPayload>
          }
          createMany: {
            args: Prisma.TimeSeriesDataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TimeSeriesDataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSeriesDataPayload>[]
          }
          delete: {
            args: Prisma.TimeSeriesDataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSeriesDataPayload>
          }
          update: {
            args: Prisma.TimeSeriesDataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSeriesDataPayload>
          }
          deleteMany: {
            args: Prisma.TimeSeriesDataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TimeSeriesDataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TimeSeriesDataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSeriesDataPayload>
          }
          aggregate: {
            args: Prisma.TimeSeriesDataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTimeSeriesData>
          }
          groupBy: {
            args: Prisma.TimeSeriesDataGroupByArgs<ExtArgs>
            result: $Utils.Optional<TimeSeriesDataGroupByOutputType>[]
          }
          count: {
            args: Prisma.TimeSeriesDataCountArgs<ExtArgs>
            result: $Utils.Optional<TimeSeriesDataCountAggregateOutputType> | number
          }
        }
      }
      ForecastResult: {
        payload: Prisma.$ForecastResultPayload<ExtArgs>
        fields: Prisma.ForecastResultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ForecastResultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForecastResultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ForecastResultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForecastResultPayload>
          }
          findFirst: {
            args: Prisma.ForecastResultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForecastResultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ForecastResultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForecastResultPayload>
          }
          findMany: {
            args: Prisma.ForecastResultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForecastResultPayload>[]
          }
          create: {
            args: Prisma.ForecastResultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForecastResultPayload>
          }
          createMany: {
            args: Prisma.ForecastResultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ForecastResultCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForecastResultPayload>[]
          }
          delete: {
            args: Prisma.ForecastResultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForecastResultPayload>
          }
          update: {
            args: Prisma.ForecastResultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForecastResultPayload>
          }
          deleteMany: {
            args: Prisma.ForecastResultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ForecastResultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ForecastResultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForecastResultPayload>
          }
          aggregate: {
            args: Prisma.ForecastResultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateForecastResult>
          }
          groupBy: {
            args: Prisma.ForecastResultGroupByArgs<ExtArgs>
            result: $Utils.Optional<ForecastResultGroupByOutputType>[]
          }
          count: {
            args: Prisma.ForecastResultCountArgs<ExtArgs>
            result: $Utils.Optional<ForecastResultCountAggregateOutputType> | number
          }
        }
      }
      MarketTrend: {
        payload: Prisma.$MarketTrendPayload<ExtArgs>
        fields: Prisma.MarketTrendFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MarketTrendFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketTrendPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MarketTrendFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketTrendPayload>
          }
          findFirst: {
            args: Prisma.MarketTrendFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketTrendPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MarketTrendFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketTrendPayload>
          }
          findMany: {
            args: Prisma.MarketTrendFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketTrendPayload>[]
          }
          create: {
            args: Prisma.MarketTrendCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketTrendPayload>
          }
          createMany: {
            args: Prisma.MarketTrendCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MarketTrendCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketTrendPayload>[]
          }
          delete: {
            args: Prisma.MarketTrendDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketTrendPayload>
          }
          update: {
            args: Prisma.MarketTrendUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketTrendPayload>
          }
          deleteMany: {
            args: Prisma.MarketTrendDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MarketTrendUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MarketTrendUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketTrendPayload>
          }
          aggregate: {
            args: Prisma.MarketTrendAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMarketTrend>
          }
          groupBy: {
            args: Prisma.MarketTrendGroupByArgs<ExtArgs>
            result: $Utils.Optional<MarketTrendGroupByOutputType>[]
          }
          count: {
            args: Prisma.MarketTrendCountArgs<ExtArgs>
            result: $Utils.Optional<MarketTrendCountAggregateOutputType> | number
          }
        }
      }
      PredictionInterval: {
        payload: Prisma.$PredictionIntervalPayload<ExtArgs>
        fields: Prisma.PredictionIntervalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PredictionIntervalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictionIntervalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PredictionIntervalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictionIntervalPayload>
          }
          findFirst: {
            args: Prisma.PredictionIntervalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictionIntervalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PredictionIntervalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictionIntervalPayload>
          }
          findMany: {
            args: Prisma.PredictionIntervalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictionIntervalPayload>[]
          }
          create: {
            args: Prisma.PredictionIntervalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictionIntervalPayload>
          }
          createMany: {
            args: Prisma.PredictionIntervalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PredictionIntervalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictionIntervalPayload>[]
          }
          delete: {
            args: Prisma.PredictionIntervalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictionIntervalPayload>
          }
          update: {
            args: Prisma.PredictionIntervalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictionIntervalPayload>
          }
          deleteMany: {
            args: Prisma.PredictionIntervalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PredictionIntervalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PredictionIntervalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictionIntervalPayload>
          }
          aggregate: {
            args: Prisma.PredictionIntervalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePredictionInterval>
          }
          groupBy: {
            args: Prisma.PredictionIntervalGroupByArgs<ExtArgs>
            result: $Utils.Optional<PredictionIntervalGroupByOutputType>[]
          }
          count: {
            args: Prisma.PredictionIntervalCountArgs<ExtArgs>
            result: $Utils.Optional<PredictionIntervalCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      ApiKey: {
        payload: Prisma.$ApiKeyPayload<ExtArgs>
        fields: Prisma.ApiKeyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApiKeyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApiKeyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          findFirst: {
            args: Prisma.ApiKeyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApiKeyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          findMany: {
            args: Prisma.ApiKeyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
          }
          create: {
            args: Prisma.ApiKeyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          createMany: {
            args: Prisma.ApiKeyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApiKeyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
          }
          delete: {
            args: Prisma.ApiKeyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          update: {
            args: Prisma.ApiKeyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          deleteMany: {
            args: Prisma.ApiKeyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApiKeyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ApiKeyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          aggregate: {
            args: Prisma.ApiKeyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApiKey>
          }
          groupBy: {
            args: Prisma.ApiKeyGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApiKeyGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApiKeyCountArgs<ExtArgs>
            result: $Utils.Optional<ApiKeyCountAggregateOutputType> | number
          }
        }
      }
      TaxCalculation: {
        payload: Prisma.$TaxCalculationPayload<ExtArgs>
        fields: Prisma.TaxCalculationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaxCalculationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxCalculationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaxCalculationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxCalculationPayload>
          }
          findFirst: {
            args: Prisma.TaxCalculationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxCalculationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaxCalculationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxCalculationPayload>
          }
          findMany: {
            args: Prisma.TaxCalculationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxCalculationPayload>[]
          }
          create: {
            args: Prisma.TaxCalculationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxCalculationPayload>
          }
          createMany: {
            args: Prisma.TaxCalculationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaxCalculationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxCalculationPayload>[]
          }
          delete: {
            args: Prisma.TaxCalculationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxCalculationPayload>
          }
          update: {
            args: Prisma.TaxCalculationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxCalculationPayload>
          }
          deleteMany: {
            args: Prisma.TaxCalculationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaxCalculationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaxCalculationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxCalculationPayload>
          }
          aggregate: {
            args: Prisma.TaxCalculationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaxCalculation>
          }
          groupBy: {
            args: Prisma.TaxCalculationGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaxCalculationGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaxCalculationCountArgs<ExtArgs>
            result: $Utils.Optional<TaxCalculationCountAggregateOutputType> | number
          }
        }
      }
      Alert: {
        payload: Prisma.$AlertPayload<ExtArgs>
        fields: Prisma.AlertFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlertFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlertFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          findFirst: {
            args: Prisma.AlertFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlertFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          findMany: {
            args: Prisma.AlertFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>[]
          }
          create: {
            args: Prisma.AlertCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          createMany: {
            args: Prisma.AlertCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AlertCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>[]
          }
          delete: {
            args: Prisma.AlertDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          update: {
            args: Prisma.AlertUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          deleteMany: {
            args: Prisma.AlertDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AlertUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AlertUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          aggregate: {
            args: Prisma.AlertAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlert>
          }
          groupBy: {
            args: Prisma.AlertGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlertGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlertCountArgs<ExtArgs>
            result: $Utils.Optional<AlertCountAggregateOutputType> | number
          }
        }
      }
      TaxRate: {
        payload: Prisma.$TaxRatePayload<ExtArgs>
        fields: Prisma.TaxRateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaxRateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxRatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaxRateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxRatePayload>
          }
          findFirst: {
            args: Prisma.TaxRateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxRatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaxRateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxRatePayload>
          }
          findMany: {
            args: Prisma.TaxRateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxRatePayload>[]
          }
          create: {
            args: Prisma.TaxRateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxRatePayload>
          }
          createMany: {
            args: Prisma.TaxRateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaxRateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxRatePayload>[]
          }
          delete: {
            args: Prisma.TaxRateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxRatePayload>
          }
          update: {
            args: Prisma.TaxRateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxRatePayload>
          }
          deleteMany: {
            args: Prisma.TaxRateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaxRateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaxRateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxRatePayload>
          }
          aggregate: {
            args: Prisma.TaxRateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaxRate>
          }
          groupBy: {
            args: Prisma.TaxRateGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaxRateGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaxRateCountArgs<ExtArgs>
            result: $Utils.Optional<TaxRateCountAggregateOutputType> | number
          }
        }
      }
      Bill: {
        payload: Prisma.$BillPayload<ExtArgs>
        fields: Prisma.BillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>
          }
          findFirst: {
            args: Prisma.BillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>
          }
          findMany: {
            args: Prisma.BillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>[]
          }
          create: {
            args: Prisma.BillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>
          }
          createMany: {
            args: Prisma.BillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>[]
          }
          delete: {
            args: Prisma.BillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>
          }
          update: {
            args: Prisma.BillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>
          }
          deleteMany: {
            args: Prisma.BillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>
          }
          aggregate: {
            args: Prisma.BillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBill>
          }
          groupBy: {
            args: Prisma.BillGroupByArgs<ExtArgs>
            result: $Utils.Optional<BillGroupByOutputType>[]
          }
          count: {
            args: Prisma.BillCountArgs<ExtArgs>
            result: $Utils.Optional<BillCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      RetryAttempt: {
        payload: Prisma.$RetryAttemptPayload<ExtArgs>
        fields: Prisma.RetryAttemptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RetryAttemptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetryAttemptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RetryAttemptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetryAttemptPayload>
          }
          findFirst: {
            args: Prisma.RetryAttemptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetryAttemptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RetryAttemptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetryAttemptPayload>
          }
          findMany: {
            args: Prisma.RetryAttemptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetryAttemptPayload>[]
          }
          create: {
            args: Prisma.RetryAttemptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetryAttemptPayload>
          }
          createMany: {
            args: Prisma.RetryAttemptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RetryAttemptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetryAttemptPayload>[]
          }
          delete: {
            args: Prisma.RetryAttemptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetryAttemptPayload>
          }
          update: {
            args: Prisma.RetryAttemptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetryAttemptPayload>
          }
          deleteMany: {
            args: Prisma.RetryAttemptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RetryAttemptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RetryAttemptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetryAttemptPayload>
          }
          aggregate: {
            args: Prisma.RetryAttemptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRetryAttempt>
          }
          groupBy: {
            args: Prisma.RetryAttemptGroupByArgs<ExtArgs>
            result: $Utils.Optional<RetryAttemptGroupByOutputType>[]
          }
          count: {
            args: Prisma.RetryAttemptCountArgs<ExtArgs>
            result: $Utils.Optional<RetryAttemptCountAggregateOutputType> | number
          }
        }
      }
      RetryLog: {
        payload: Prisma.$RetryLogPayload<ExtArgs>
        fields: Prisma.RetryLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RetryLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetryLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RetryLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetryLogPayload>
          }
          findFirst: {
            args: Prisma.RetryLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetryLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RetryLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetryLogPayload>
          }
          findMany: {
            args: Prisma.RetryLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetryLogPayload>[]
          }
          create: {
            args: Prisma.RetryLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetryLogPayload>
          }
          createMany: {
            args: Prisma.RetryLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RetryLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetryLogPayload>[]
          }
          delete: {
            args: Prisma.RetryLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetryLogPayload>
          }
          update: {
            args: Prisma.RetryLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetryLogPayload>
          }
          deleteMany: {
            args: Prisma.RetryLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RetryLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RetryLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetryLogPayload>
          }
          aggregate: {
            args: Prisma.RetryLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRetryLog>
          }
          groupBy: {
            args: Prisma.RetryLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<RetryLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.RetryLogCountArgs<ExtArgs>
            result: $Utils.Optional<RetryLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    notifications: number
    refreshTokens: number
    payments: number
    retryAttempts: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    refreshTokens?: boolean | UserCountOutputTypeCountRefreshTokensArgs
    payments?: boolean | UserCountOutputTypeCountPaymentsArgs
    retryAttempts?: boolean | UserCountOutputTypeCountRetryAttemptsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRefreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRetryAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RetryAttemptWhereInput
  }


  /**
   * Count Type OrganizationCountOutputType
   */

  export type OrganizationCountOutputType = {
    notifications: number
    webhooks: number
    apiKeys: number
    carbonEstimates: number
    billingRules: number
    billingTemplates: number
    orders: number
  }

  export type OrganizationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifications?: boolean | OrganizationCountOutputTypeCountNotificationsArgs
    webhooks?: boolean | OrganizationCountOutputTypeCountWebhooksArgs
    apiKeys?: boolean | OrganizationCountOutputTypeCountApiKeysArgs
    carbonEstimates?: boolean | OrganizationCountOutputTypeCountCarbonEstimatesArgs
    billingRules?: boolean | OrganizationCountOutputTypeCountBillingRulesArgs
    billingTemplates?: boolean | OrganizationCountOutputTypeCountBillingTemplatesArgs
    orders?: boolean | OrganizationCountOutputTypeCountOrdersArgs
  }

  // Custom InputTypes
  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationCountOutputType
     */
    select?: OrganizationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountWebhooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountApiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeyWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountCarbonEstimatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CarbonEstimateWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountBillingRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillingRuleWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountBillingTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillingRuleTemplateWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    payments: number
    taxCalculations: number
    orders: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | CustomerCountOutputTypeCountPaymentsArgs
    taxCalculations?: boolean | CustomerCountOutputTypeCountTaxCalculationsArgs
    orders?: boolean | CustomerCountOutputTypeCountOrdersArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountTaxCalculationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaxCalculationWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }


  /**
   * Count Type SubscriptionCountOutputType
   */

  export type SubscriptionCountOutputType = {
    payments: number
    usageRecords: number
  }

  export type SubscriptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | SubscriptionCountOutputTypeCountPaymentsArgs
    usageRecords?: boolean | SubscriptionCountOutputTypeCountUsageRecordsArgs
  }

  // Custom InputTypes
  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionCountOutputType
     */
    select?: SubscriptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeCountUsageRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsageRecordWhereInput
  }


  /**
   * Count Type PlanCountOutputType
   */

  export type PlanCountOutputType = {
    features: number
    usageLimits: number
    priceHistory: number
    priceTests: number
    revenueRules: number
    subscriptions: number
  }

  export type PlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    features?: boolean | PlanCountOutputTypeCountFeaturesArgs
    usageLimits?: boolean | PlanCountOutputTypeCountUsageLimitsArgs
    priceHistory?: boolean | PlanCountOutputTypeCountPriceHistoryArgs
    priceTests?: boolean | PlanCountOutputTypeCountPriceTestsArgs
    revenueRules?: boolean | PlanCountOutputTypeCountRevenueRulesArgs
    subscriptions?: boolean | PlanCountOutputTypeCountSubscriptionsArgs
  }

  // Custom InputTypes
  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanCountOutputType
     */
    select?: PlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeCountFeaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanFeatureWhereInput
  }

  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeCountUsageLimitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsageLimitWhereInput
  }

  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeCountPriceHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PriceHistoryWhereInput
  }

  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeCountPriceTestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PriceTestWhereInput
  }

  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeCountRevenueRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RevenueRecognitionRuleWhereInput
  }

  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
  }


  /**
   * Count Type WebhookCountOutputType
   */

  export type WebhookCountOutputType = {
    deliveries: number
  }

  export type WebhookCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deliveries?: boolean | WebhookCountOutputTypeCountDeliveriesArgs
  }

  // Custom InputTypes
  /**
   * WebhookCountOutputType without action
   */
  export type WebhookCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookCountOutputType
     */
    select?: WebhookCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WebhookCountOutputType without action
   */
  export type WebhookCountOutputTypeCountDeliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookDeliveryWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    payments: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | OrderCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Count Type PriceTestCountOutputType
   */

  export type PriceTestCountOutputType = {
    variants: number
  }

  export type PriceTestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variants?: boolean | PriceTestCountOutputTypeCountVariantsArgs
  }

  // Custom InputTypes
  /**
   * PriceTestCountOutputType without action
   */
  export type PriceTestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceTestCountOutputType
     */
    select?: PriceTestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PriceTestCountOutputType without action
   */
  export type PriceTestCountOutputTypeCountVariantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PriceTestVariantWhereInput
  }


  /**
   * Count Type ForecastModelCountOutputType
   */

  export type ForecastModelCountOutputType = {
    forecasts: number
    timeSeriesData: number
  }

  export type ForecastModelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    forecasts?: boolean | ForecastModelCountOutputTypeCountForecastsArgs
    timeSeriesData?: boolean | ForecastModelCountOutputTypeCountTimeSeriesDataArgs
  }

  // Custom InputTypes
  /**
   * ForecastModelCountOutputType without action
   */
  export type ForecastModelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForecastModelCountOutputType
     */
    select?: ForecastModelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ForecastModelCountOutputType without action
   */
  export type ForecastModelCountOutputTypeCountForecastsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForecastResultWhereInput
  }

  /**
   * ForecastModelCountOutputType without action
   */
  export type ForecastModelCountOutputTypeCountTimeSeriesDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeSeriesDataWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
    role: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
    role: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    createdAt: number
    updatedAt: number
    role: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    role?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    role?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    role?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string | null
    email: string
    password: string | null
    createdAt: Date
    updatedAt: Date
    role: string
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    retryAttempts?: boolean | User$retryAttemptsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    retryAttempts?: boolean | User$retryAttemptsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      refreshTokens: Prisma.$RefreshTokenPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      retryAttempts: Prisma.$RetryAttemptPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      email: string
      password: string | null
      createdAt: Date
      updatedAt: Date
      role: string
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    refreshTokens<T extends User$refreshTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$refreshTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany"> | Null>
    payments<T extends User$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, User$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany"> | Null>
    retryAttempts<T extends User$retryAttemptsArgs<ExtArgs> = {}>(args?: Subset<T, User$retryAttemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RetryAttemptPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly role: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.refreshTokens
   */
  export type User$refreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    cursor?: RefreshTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * User.payments
   */
  export type User$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * User.retryAttempts
   */
  export type User$retryAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetryAttempt
     */
    select?: RetryAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetryAttemptInclude<ExtArgs> | null
    where?: RetryAttemptWhereInput
    orderBy?: RetryAttemptOrderByWithRelationInput | RetryAttemptOrderByWithRelationInput[]
    cursor?: RetryAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RetryAttemptScalarFieldEnum | RetryAttemptScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Organization
   */

  export type AggregateOrganization = {
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  export type OrganizationMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    stripeCustomerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    stripeCustomerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationCountAggregateOutputType = {
    id: number
    name: number
    email: number
    stripeCustomerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrganizationMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    stripeCustomerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    stripeCustomerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    stripeCustomerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrganizationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organization to aggregate.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Organizations
    **/
    _count?: true | OrganizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMaxAggregateInputType
  }

  export type GetOrganizationAggregateType<T extends OrganizationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganization[P]>
      : GetScalarType<T[P], AggregateOrganization[P]>
  }




  export type OrganizationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationWhereInput
    orderBy?: OrganizationOrderByWithAggregationInput | OrganizationOrderByWithAggregationInput[]
    by: OrganizationScalarFieldEnum[] | OrganizationScalarFieldEnum
    having?: OrganizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationCountAggregateInputType | true
    _min?: OrganizationMinAggregateInputType
    _max?: OrganizationMaxAggregateInputType
  }

  export type OrganizationGroupByOutputType = {
    id: string
    name: string
    email: string | null
    stripeCustomerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  type GetOrganizationGroupByPayload<T extends OrganizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    stripeCustomerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    notifications?: boolean | Organization$notificationsArgs<ExtArgs>
    webhooks?: boolean | Organization$webhooksArgs<ExtArgs>
    apiKeys?: boolean | Organization$apiKeysArgs<ExtArgs>
    carbonEstimates?: boolean | Organization$carbonEstimatesArgs<ExtArgs>
    billingRules?: boolean | Organization$billingRulesArgs<ExtArgs>
    billingTemplates?: boolean | Organization$billingTemplatesArgs<ExtArgs>
    orders?: boolean | Organization$ordersArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    stripeCustomerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    stripeCustomerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrganizationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifications?: boolean | Organization$notificationsArgs<ExtArgs>
    webhooks?: boolean | Organization$webhooksArgs<ExtArgs>
    apiKeys?: boolean | Organization$apiKeysArgs<ExtArgs>
    carbonEstimates?: boolean | Organization$carbonEstimatesArgs<ExtArgs>
    billingRules?: boolean | Organization$billingRulesArgs<ExtArgs>
    billingTemplates?: boolean | Organization$billingTemplatesArgs<ExtArgs>
    orders?: boolean | Organization$ordersArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrganizationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OrganizationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Organization"
    objects: {
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      webhooks: Prisma.$WebhookPayload<ExtArgs>[]
      apiKeys: Prisma.$ApiKeyPayload<ExtArgs>[]
      carbonEstimates: Prisma.$CarbonEstimatePayload<ExtArgs>[]
      billingRules: Prisma.$BillingRulePayload<ExtArgs>[]
      billingTemplates: Prisma.$BillingRuleTemplatePayload<ExtArgs>[]
      orders: Prisma.$OrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string | null
      stripeCustomerId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["organization"]>
    composites: {}
  }

  type OrganizationGetPayload<S extends boolean | null | undefined | OrganizationDefaultArgs> = $Result.GetResult<Prisma.$OrganizationPayload, S>

  type OrganizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrganizationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrganizationCountAggregateInputType | true
    }

  export interface OrganizationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Organization'], meta: { name: 'Organization' } }
    /**
     * Find zero or one Organization that matches the filter.
     * @param {OrganizationFindUniqueArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationFindUniqueArgs>(args: SelectSubset<T, OrganizationFindUniqueArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Organization that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrganizationFindUniqueOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Organization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationFindFirstArgs>(args?: SelectSubset<T, OrganizationFindFirstArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Organization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organization.findMany()
     * 
     * // Get first 10 Organizations
     * const organizations = await prisma.organization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationWithIdOnly = await prisma.organization.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganizationFindManyArgs>(args?: SelectSubset<T, OrganizationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Organization.
     * @param {OrganizationCreateArgs} args - Arguments to create a Organization.
     * @example
     * // Create one Organization
     * const Organization = await prisma.organization.create({
     *   data: {
     *     // ... data to create a Organization
     *   }
     * })
     * 
     */
    create<T extends OrganizationCreateArgs>(args: SelectSubset<T, OrganizationCreateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Organizations.
     * @param {OrganizationCreateManyArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizationCreateManyArgs>(args?: SelectSubset<T, OrganizationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Organizations and returns the data saved in the database.
     * @param {OrganizationCreateManyAndReturnArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrganizationCreateManyAndReturnArgs>(args?: SelectSubset<T, OrganizationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Organization.
     * @param {OrganizationDeleteArgs} args - Arguments to delete one Organization.
     * @example
     * // Delete one Organization
     * const Organization = await prisma.organization.delete({
     *   where: {
     *     // ... filter to delete one Organization
     *   }
     * })
     * 
     */
    delete<T extends OrganizationDeleteArgs>(args: SelectSubset<T, OrganizationDeleteArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Organization.
     * @param {OrganizationUpdateArgs} args - Arguments to update one Organization.
     * @example
     * // Update one Organization
     * const organization = await prisma.organization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizationUpdateArgs>(args: SelectSubset<T, OrganizationUpdateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Organizations.
     * @param {OrganizationDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizationDeleteManyArgs>(args?: SelectSubset<T, OrganizationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizationUpdateManyArgs>(args: SelectSubset<T, OrganizationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Organization.
     * @param {OrganizationUpsertArgs} args - Arguments to update or create a Organization.
     * @example
     * // Update or create a Organization
     * const organization = await prisma.organization.upsert({
     *   create: {
     *     // ... data to create a Organization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organization we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationUpsertArgs>(args: SelectSubset<T, OrganizationUpsertArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organization.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
    **/
    count<T extends OrganizationCountArgs>(
      args?: Subset<T, OrganizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationAggregateArgs>(args: Subset<T, OrganizationAggregateArgs>): Prisma.PrismaPromise<GetOrganizationAggregateType<T>>

    /**
     * Group by Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Organization model
   */
  readonly fields: OrganizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    notifications<T extends Organization$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    webhooks<T extends Organization$webhooksArgs<ExtArgs> = {}>(args?: Subset<T, Organization$webhooksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findMany"> | Null>
    apiKeys<T extends Organization$apiKeysArgs<ExtArgs> = {}>(args?: Subset<T, Organization$apiKeysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findMany"> | Null>
    carbonEstimates<T extends Organization$carbonEstimatesArgs<ExtArgs> = {}>(args?: Subset<T, Organization$carbonEstimatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CarbonEstimatePayload<ExtArgs>, T, "findMany"> | Null>
    billingRules<T extends Organization$billingRulesArgs<ExtArgs> = {}>(args?: Subset<T, Organization$billingRulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingRulePayload<ExtArgs>, T, "findMany"> | Null>
    billingTemplates<T extends Organization$billingTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, Organization$billingTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingRuleTemplatePayload<ExtArgs>, T, "findMany"> | Null>
    orders<T extends Organization$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Organization$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Organization model
   */ 
  interface OrganizationFieldRefs {
    readonly id: FieldRef<"Organization", 'String'>
    readonly name: FieldRef<"Organization", 'String'>
    readonly email: FieldRef<"Organization", 'String'>
    readonly stripeCustomerId: FieldRef<"Organization", 'String'>
    readonly createdAt: FieldRef<"Organization", 'DateTime'>
    readonly updatedAt: FieldRef<"Organization", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Organization findUnique
   */
  export type OrganizationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findUniqueOrThrow
   */
  export type OrganizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findFirst
   */
  export type OrganizationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findFirstOrThrow
   */
  export type OrganizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findMany
   */
  export type OrganizationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organizations to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization create
   */
  export type OrganizationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to create a Organization.
     */
    data: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
  }

  /**
   * Organization createMany
   */
  export type OrganizationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization createManyAndReturn
   */
  export type OrganizationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization update
   */
  export type OrganizationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to update a Organization.
     */
    data: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
    /**
     * Choose, which Organization to update.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization updateMany
   */
  export type OrganizationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
  }

  /**
   * Organization upsert
   */
  export type OrganizationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The filter to search for the Organization to update in case it exists.
     */
    where: OrganizationWhereUniqueInput
    /**
     * In case the Organization found by the `where` argument doesn't exist, create a new Organization with this data.
     */
    create: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
    /**
     * In case the Organization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
  }

  /**
   * Organization delete
   */
  export type OrganizationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter which Organization to delete.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization deleteMany
   */
  export type OrganizationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organizations to delete
     */
    where?: OrganizationWhereInput
  }

  /**
   * Organization.notifications
   */
  export type Organization$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Organization.webhooks
   */
  export type Organization$webhooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    where?: WebhookWhereInput
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    cursor?: WebhookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WebhookScalarFieldEnum | WebhookScalarFieldEnum[]
  }

  /**
   * Organization.apiKeys
   */
  export type Organization$apiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    where?: ApiKeyWhereInput
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    cursor?: ApiKeyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * Organization.carbonEstimates
   */
  export type Organization$carbonEstimatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarbonEstimate
     */
    select?: CarbonEstimateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarbonEstimateInclude<ExtArgs> | null
    where?: CarbonEstimateWhereInput
    orderBy?: CarbonEstimateOrderByWithRelationInput | CarbonEstimateOrderByWithRelationInput[]
    cursor?: CarbonEstimateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CarbonEstimateScalarFieldEnum | CarbonEstimateScalarFieldEnum[]
  }

  /**
   * Organization.billingRules
   */
  export type Organization$billingRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingRule
     */
    select?: BillingRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingRuleInclude<ExtArgs> | null
    where?: BillingRuleWhereInput
    orderBy?: BillingRuleOrderByWithRelationInput | BillingRuleOrderByWithRelationInput[]
    cursor?: BillingRuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillingRuleScalarFieldEnum | BillingRuleScalarFieldEnum[]
  }

  /**
   * Organization.billingTemplates
   */
  export type Organization$billingTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingRuleTemplate
     */
    select?: BillingRuleTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingRuleTemplateInclude<ExtArgs> | null
    where?: BillingRuleTemplateWhereInput
    orderBy?: BillingRuleTemplateOrderByWithRelationInput | BillingRuleTemplateOrderByWithRelationInput[]
    cursor?: BillingRuleTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillingRuleTemplateScalarFieldEnum | BillingRuleTemplateScalarFieldEnum[]
  }

  /**
   * Organization.orders
   */
  export type Organization$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Organization without action
   */
  export type OrganizationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    userId: string | null
    stripeCustomerId: string | null
    name: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    stripeCustomerId: string | null
    name: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    userId: number
    stripeCustomerId: number
    name: number
    email: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerMinAggregateInputType = {
    id?: true
    userId?: true
    stripeCustomerId?: true
    name?: true
    email?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    userId?: true
    stripeCustomerId?: true
    name?: true
    email?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    userId?: true
    stripeCustomerId?: true
    name?: true
    email?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: string
    userId: string
    stripeCustomerId: string | null
    name: string | null
    email: string
    createdAt: Date
    updatedAt: Date
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    stripeCustomerId?: boolean
    name?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    payments?: boolean | Customer$paymentsArgs<ExtArgs>
    subscription?: boolean | Customer$subscriptionArgs<ExtArgs>
    taxCalculations?: boolean | Customer$taxCalculationsArgs<ExtArgs>
    orders?: boolean | Customer$ordersArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    stripeCustomerId?: boolean
    name?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    userId?: boolean
    stripeCustomerId?: boolean
    name?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | Customer$paymentsArgs<ExtArgs>
    subscription?: boolean | Customer$subscriptionArgs<ExtArgs>
    taxCalculations?: boolean | Customer$taxCalculationsArgs<ExtArgs>
    orders?: boolean | Customer$ordersArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      subscription: Prisma.$SubscriptionPayload<ExtArgs> | null
      taxCalculations: Prisma.$TaxCalculationPayload<ExtArgs>[]
      orders: Prisma.$OrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      stripeCustomerId: string | null
      name: string | null
      email: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payments<T extends Customer$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany"> | Null>
    subscription<T extends Customer$subscriptionArgs<ExtArgs> = {}>(args?: Subset<T, Customer$subscriptionArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    taxCalculations<T extends Customer$taxCalculationsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$taxCalculationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxCalculationPayload<ExtArgs>, T, "findMany"> | Null>
    orders<T extends Customer$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Customer$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */ 
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'String'>
    readonly userId: FieldRef<"Customer", 'String'>
    readonly stripeCustomerId: FieldRef<"Customer", 'String'>
    readonly name: FieldRef<"Customer", 'String'>
    readonly email: FieldRef<"Customer", 'String'>
    readonly createdAt: FieldRef<"Customer", 'DateTime'>
    readonly updatedAt: FieldRef<"Customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
  }

  /**
   * Customer.payments
   */
  export type Customer$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Customer.subscription
   */
  export type Customer$subscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
  }

  /**
   * Customer.taxCalculations
   */
  export type Customer$taxCalculationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxCalculation
     */
    select?: TaxCalculationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxCalculationInclude<ExtArgs> | null
    where?: TaxCalculationWhereInput
    orderBy?: TaxCalculationOrderByWithRelationInput | TaxCalculationOrderByWithRelationInput[]
    cursor?: TaxCalculationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaxCalculationScalarFieldEnum | TaxCalculationScalarFieldEnum[]
  }

  /**
   * Customer.orders
   */
  export type Customer$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    status: $Enums.SubscriptionStatus | null
    planId: string | null
    stripeSubscriptionId: string | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    cancelAtPeriodEnd: boolean | null
    cancelledAt: Date | null
    pausedAt: Date | null
    resumesAt: Date | null
    trialEndsAt: Date | null
    billingCycleAnchor: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    status: $Enums.SubscriptionStatus | null
    planId: string | null
    stripeSubscriptionId: string | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    cancelAtPeriodEnd: boolean | null
    cancelledAt: Date | null
    pausedAt: Date | null
    resumesAt: Date | null
    trialEndsAt: Date | null
    billingCycleAnchor: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    customerId: number
    status: number
    planId: number
    stripeSubscriptionId: number
    currentPeriodStart: number
    currentPeriodEnd: number
    cancelAtPeriodEnd: number
    cancelledAt: number
    pausedAt: number
    resumesAt: number
    trialEndsAt: number
    billingCycleAnchor: number
    proration: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionMinAggregateInputType = {
    id?: true
    customerId?: true
    status?: true
    planId?: true
    stripeSubscriptionId?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    cancelledAt?: true
    pausedAt?: true
    resumesAt?: true
    trialEndsAt?: true
    billingCycleAnchor?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    customerId?: true
    status?: true
    planId?: true
    stripeSubscriptionId?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    cancelledAt?: true
    pausedAt?: true
    resumesAt?: true
    trialEndsAt?: true
    billingCycleAnchor?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    customerId?: true
    status?: true
    planId?: true
    stripeSubscriptionId?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    cancelledAt?: true
    pausedAt?: true
    resumesAt?: true
    trialEndsAt?: true
    billingCycleAnchor?: true
    proration?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: string
    customerId: string
    status: $Enums.SubscriptionStatus
    planId: string
    stripeSubscriptionId: string | null
    currentPeriodStart: Date
    currentPeriodEnd: Date
    cancelAtPeriodEnd: boolean
    cancelledAt: Date | null
    pausedAt: Date | null
    resumesAt: Date | null
    trialEndsAt: Date | null
    billingCycleAnchor: Date
    proration: JsonValue | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    status?: boolean
    planId?: boolean
    stripeSubscriptionId?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    cancelledAt?: boolean
    pausedAt?: boolean
    resumesAt?: boolean
    trialEndsAt?: boolean
    billingCycleAnchor?: boolean
    proration?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
    payments?: boolean | Subscription$paymentsArgs<ExtArgs>
    usageRecords?: boolean | Subscription$usageRecordsArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    status?: boolean
    planId?: boolean
    stripeSubscriptionId?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    cancelledAt?: boolean
    pausedAt?: boolean
    resumesAt?: boolean
    trialEndsAt?: boolean
    billingCycleAnchor?: boolean
    proration?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectScalar = {
    id?: boolean
    customerId?: boolean
    status?: boolean
    planId?: boolean
    stripeSubscriptionId?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    cancelledAt?: boolean
    pausedAt?: boolean
    resumesAt?: boolean
    trialEndsAt?: boolean
    billingCycleAnchor?: boolean
    proration?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
    payments?: boolean | Subscription$paymentsArgs<ExtArgs>
    usageRecords?: boolean | Subscription$usageRecordsArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }

  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      plan: Prisma.$PlanPayload<ExtArgs>
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      usageRecords: Prisma.$UsageRecordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string
      status: $Enums.SubscriptionStatus
      planId: string
      stripeSubscriptionId: string | null
      currentPeriodStart: Date
      currentPeriodEnd: Date
      cancelAtPeriodEnd: boolean
      cancelledAt: Date | null
      pausedAt: Date | null
      resumesAt: Date | null
      trialEndsAt: Date | null
      billingCycleAnchor: Date
      proration: Prisma.JsonValue | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends SubscriptionCreateArgs>(args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {SubscriptionCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDeleteArgs>(args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUpdateArgs>(args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    plan<T extends PlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlanDefaultArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    payments<T extends Subscription$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany"> | Null>
    usageRecords<T extends Subscription$usageRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$usageRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageRecordPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription model
   */ 
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'String'>
    readonly customerId: FieldRef<"Subscription", 'String'>
    readonly status: FieldRef<"Subscription", 'SubscriptionStatus'>
    readonly planId: FieldRef<"Subscription", 'String'>
    readonly stripeSubscriptionId: FieldRef<"Subscription", 'String'>
    readonly currentPeriodStart: FieldRef<"Subscription", 'DateTime'>
    readonly currentPeriodEnd: FieldRef<"Subscription", 'DateTime'>
    readonly cancelAtPeriodEnd: FieldRef<"Subscription", 'Boolean'>
    readonly cancelledAt: FieldRef<"Subscription", 'DateTime'>
    readonly pausedAt: FieldRef<"Subscription", 'DateTime'>
    readonly resumesAt: FieldRef<"Subscription", 'DateTime'>
    readonly trialEndsAt: FieldRef<"Subscription", 'DateTime'>
    readonly billingCycleAnchor: FieldRef<"Subscription", 'DateTime'>
    readonly proration: FieldRef<"Subscription", 'Json'>
    readonly metadata: FieldRef<"Subscription", 'Json'>
    readonly createdAt: FieldRef<"Subscription", 'DateTime'>
    readonly updatedAt: FieldRef<"Subscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscription createManyAndReturn
   */
  export type SubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
  }

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
  }

  /**
   * Subscription.payments
   */
  export type Subscription$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Subscription.usageRecords
   */
  export type Subscription$usageRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageRecordInclude<ExtArgs> | null
    where?: UsageRecordWhereInput
    orderBy?: UsageRecordOrderByWithRelationInput | UsageRecordOrderByWithRelationInput[]
    cursor?: UsageRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsageRecordScalarFieldEnum | UsageRecordScalarFieldEnum[]
  }

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model Plan
   */

  export type AggregatePlan = {
    _count: PlanCountAggregateOutputType | null
    _avg: PlanAvgAggregateOutputType | null
    _sum: PlanSumAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  export type PlanAvgAggregateOutputType = {
    basePrice: number | null
    currentPrice: number | null
    sortOrder: number | null
    costBasis: number | null
    churnRisk: number | null
  }

  export type PlanSumAggregateOutputType = {
    basePrice: number | null
    currentPrice: number | null
    sortOrder: number | null
    costBasis: number | null
    churnRisk: number | null
  }

  export type PlanMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    basePrice: number | null
    currentPrice: number | null
    currency: string | null
    interval: string | null
    stripePriceId: string | null
    isActive: boolean | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
    marketSegment: string | null
    costBasis: number | null
    churnRisk: number | null
  }

  export type PlanMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    basePrice: number | null
    currentPrice: number | null
    currency: string | null
    interval: string | null
    stripePriceId: string | null
    isActive: boolean | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
    marketSegment: string | null
    costBasis: number | null
    churnRisk: number | null
  }

  export type PlanCountAggregateOutputType = {
    id: number
    name: number
    description: number
    basePrice: number
    currentPrice: number
    currency: number
    interval: number
    stripePriceId: number
    isActive: number
    sortOrder: number
    metadata: number
    createdAt: number
    updatedAt: number
    marketSegment: number
    costBasis: number
    churnRisk: number
    _all: number
  }


  export type PlanAvgAggregateInputType = {
    basePrice?: true
    currentPrice?: true
    sortOrder?: true
    costBasis?: true
    churnRisk?: true
  }

  export type PlanSumAggregateInputType = {
    basePrice?: true
    currentPrice?: true
    sortOrder?: true
    costBasis?: true
    churnRisk?: true
  }

  export type PlanMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    basePrice?: true
    currentPrice?: true
    currency?: true
    interval?: true
    stripePriceId?: true
    isActive?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    marketSegment?: true
    costBasis?: true
    churnRisk?: true
  }

  export type PlanMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    basePrice?: true
    currentPrice?: true
    currency?: true
    interval?: true
    stripePriceId?: true
    isActive?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    marketSegment?: true
    costBasis?: true
    churnRisk?: true
  }

  export type PlanCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    basePrice?: true
    currentPrice?: true
    currency?: true
    interval?: true
    stripePriceId?: true
    isActive?: true
    sortOrder?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    marketSegment?: true
    costBasis?: true
    churnRisk?: true
    _all?: true
  }

  export type PlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plan to aggregate.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Plans
    **/
    _count?: true | PlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanMaxAggregateInputType
  }

  export type GetPlanAggregateType<T extends PlanAggregateArgs> = {
        [P in keyof T & keyof AggregatePlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlan[P]>
      : GetScalarType<T[P], AggregatePlan[P]>
  }




  export type PlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanWhereInput
    orderBy?: PlanOrderByWithAggregationInput | PlanOrderByWithAggregationInput[]
    by: PlanScalarFieldEnum[] | PlanScalarFieldEnum
    having?: PlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanCountAggregateInputType | true
    _avg?: PlanAvgAggregateInputType
    _sum?: PlanSumAggregateInputType
    _min?: PlanMinAggregateInputType
    _max?: PlanMaxAggregateInputType
  }

  export type PlanGroupByOutputType = {
    id: string
    name: string
    description: string | null
    basePrice: number
    currentPrice: number
    currency: string
    interval: string
    stripePriceId: string | null
    isActive: boolean
    sortOrder: number
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    marketSegment: string | null
    costBasis: number | null
    churnRisk: number | null
    _count: PlanCountAggregateOutputType | null
    _avg: PlanAvgAggregateOutputType | null
    _sum: PlanSumAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  type GetPlanGroupByPayload<T extends PlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanGroupByOutputType[P]>
            : GetScalarType<T[P], PlanGroupByOutputType[P]>
        }
      >
    >


  export type PlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    basePrice?: boolean
    currentPrice?: boolean
    currency?: boolean
    interval?: boolean
    stripePriceId?: boolean
    isActive?: boolean
    sortOrder?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    marketSegment?: boolean
    costBasis?: boolean
    churnRisk?: boolean
    features?: boolean | Plan$featuresArgs<ExtArgs>
    usageLimits?: boolean | Plan$usageLimitsArgs<ExtArgs>
    priceHistory?: boolean | Plan$priceHistoryArgs<ExtArgs>
    priceTests?: boolean | Plan$priceTestsArgs<ExtArgs>
    revenueRules?: boolean | Plan$revenueRulesArgs<ExtArgs>
    subscriptions?: boolean | Plan$subscriptionsArgs<ExtArgs>
    _count?: boolean | PlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plan"]>

  export type PlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    basePrice?: boolean
    currentPrice?: boolean
    currency?: boolean
    interval?: boolean
    stripePriceId?: boolean
    isActive?: boolean
    sortOrder?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    marketSegment?: boolean
    costBasis?: boolean
    churnRisk?: boolean
  }, ExtArgs["result"]["plan"]>

  export type PlanSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    basePrice?: boolean
    currentPrice?: boolean
    currency?: boolean
    interval?: boolean
    stripePriceId?: boolean
    isActive?: boolean
    sortOrder?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    marketSegment?: boolean
    costBasis?: boolean
    churnRisk?: boolean
  }

  export type PlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    features?: boolean | Plan$featuresArgs<ExtArgs>
    usageLimits?: boolean | Plan$usageLimitsArgs<ExtArgs>
    priceHistory?: boolean | Plan$priceHistoryArgs<ExtArgs>
    priceTests?: boolean | Plan$priceTestsArgs<ExtArgs>
    revenueRules?: boolean | Plan$revenueRulesArgs<ExtArgs>
    subscriptions?: boolean | Plan$subscriptionsArgs<ExtArgs>
    _count?: boolean | PlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Plan"
    objects: {
      features: Prisma.$PlanFeaturePayload<ExtArgs>[]
      usageLimits: Prisma.$UsageLimitPayload<ExtArgs>[]
      priceHistory: Prisma.$PriceHistoryPayload<ExtArgs>[]
      priceTests: Prisma.$PriceTestPayload<ExtArgs>[]
      revenueRules: Prisma.$RevenueRecognitionRulePayload<ExtArgs>[]
      subscriptions: Prisma.$SubscriptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      basePrice: number
      currentPrice: number
      currency: string
      interval: string
      stripePriceId: string | null
      isActive: boolean
      sortOrder: number
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      marketSegment: string | null
      costBasis: number | null
      churnRisk: number | null
    }, ExtArgs["result"]["plan"]>
    composites: {}
  }

  type PlanGetPayload<S extends boolean | null | undefined | PlanDefaultArgs> = $Result.GetResult<Prisma.$PlanPayload, S>

  type PlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlanCountAggregateInputType | true
    }

  export interface PlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Plan'], meta: { name: 'Plan' } }
    /**
     * Find zero or one Plan that matches the filter.
     * @param {PlanFindUniqueArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanFindUniqueArgs>(args: SelectSubset<T, PlanFindUniqueArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Plan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlanFindUniqueOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Plan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindFirstArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanFindFirstArgs>(args?: SelectSubset<T, PlanFindFirstArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Plan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindFirstOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Plans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plans
     * const plans = await prisma.plan.findMany()
     * 
     * // Get first 10 Plans
     * const plans = await prisma.plan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planWithIdOnly = await prisma.plan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlanFindManyArgs>(args?: SelectSubset<T, PlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Plan.
     * @param {PlanCreateArgs} args - Arguments to create a Plan.
     * @example
     * // Create one Plan
     * const Plan = await prisma.plan.create({
     *   data: {
     *     // ... data to create a Plan
     *   }
     * })
     * 
     */
    create<T extends PlanCreateArgs>(args: SelectSubset<T, PlanCreateArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Plans.
     * @param {PlanCreateManyArgs} args - Arguments to create many Plans.
     * @example
     * // Create many Plans
     * const plan = await prisma.plan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanCreateManyArgs>(args?: SelectSubset<T, PlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Plans and returns the data saved in the database.
     * @param {PlanCreateManyAndReturnArgs} args - Arguments to create many Plans.
     * @example
     * // Create many Plans
     * const plan = await prisma.plan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Plans and only return the `id`
     * const planWithIdOnly = await prisma.plan.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlanCreateManyAndReturnArgs>(args?: SelectSubset<T, PlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Plan.
     * @param {PlanDeleteArgs} args - Arguments to delete one Plan.
     * @example
     * // Delete one Plan
     * const Plan = await prisma.plan.delete({
     *   where: {
     *     // ... filter to delete one Plan
     *   }
     * })
     * 
     */
    delete<T extends PlanDeleteArgs>(args: SelectSubset<T, PlanDeleteArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Plan.
     * @param {PlanUpdateArgs} args - Arguments to update one Plan.
     * @example
     * // Update one Plan
     * const plan = await prisma.plan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanUpdateArgs>(args: SelectSubset<T, PlanUpdateArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Plans.
     * @param {PlanDeleteManyArgs} args - Arguments to filter Plans to delete.
     * @example
     * // Delete a few Plans
     * const { count } = await prisma.plan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanDeleteManyArgs>(args?: SelectSubset<T, PlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plans
     * const plan = await prisma.plan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanUpdateManyArgs>(args: SelectSubset<T, PlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Plan.
     * @param {PlanUpsertArgs} args - Arguments to update or create a Plan.
     * @example
     * // Update or create a Plan
     * const plan = await prisma.plan.upsert({
     *   create: {
     *     // ... data to create a Plan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plan we want to update
     *   }
     * })
     */
    upsert<T extends PlanUpsertArgs>(args: SelectSubset<T, PlanUpsertArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanCountArgs} args - Arguments to filter Plans to count.
     * @example
     * // Count the number of Plans
     * const count = await prisma.plan.count({
     *   where: {
     *     // ... the filter for the Plans we want to count
     *   }
     * })
    **/
    count<T extends PlanCountArgs>(
      args?: Subset<T, PlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanAggregateArgs>(args: Subset<T, PlanAggregateArgs>): Prisma.PrismaPromise<GetPlanAggregateType<T>>

    /**
     * Group by Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanGroupByArgs['orderBy'] }
        : { orderBy?: PlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Plan model
   */
  readonly fields: PlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Plan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    features<T extends Plan$featuresArgs<ExtArgs> = {}>(args?: Subset<T, Plan$featuresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanFeaturePayload<ExtArgs>, T, "findMany"> | Null>
    usageLimits<T extends Plan$usageLimitsArgs<ExtArgs> = {}>(args?: Subset<T, Plan$usageLimitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageLimitPayload<ExtArgs>, T, "findMany"> | Null>
    priceHistory<T extends Plan$priceHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Plan$priceHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    priceTests<T extends Plan$priceTestsArgs<ExtArgs> = {}>(args?: Subset<T, Plan$priceTestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceTestPayload<ExtArgs>, T, "findMany"> | Null>
    revenueRules<T extends Plan$revenueRulesArgs<ExtArgs> = {}>(args?: Subset<T, Plan$revenueRulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RevenueRecognitionRulePayload<ExtArgs>, T, "findMany"> | Null>
    subscriptions<T extends Plan$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Plan$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Plan model
   */ 
  interface PlanFieldRefs {
    readonly id: FieldRef<"Plan", 'String'>
    readonly name: FieldRef<"Plan", 'String'>
    readonly description: FieldRef<"Plan", 'String'>
    readonly basePrice: FieldRef<"Plan", 'Float'>
    readonly currentPrice: FieldRef<"Plan", 'Float'>
    readonly currency: FieldRef<"Plan", 'String'>
    readonly interval: FieldRef<"Plan", 'String'>
    readonly stripePriceId: FieldRef<"Plan", 'String'>
    readonly isActive: FieldRef<"Plan", 'Boolean'>
    readonly sortOrder: FieldRef<"Plan", 'Int'>
    readonly metadata: FieldRef<"Plan", 'Json'>
    readonly createdAt: FieldRef<"Plan", 'DateTime'>
    readonly updatedAt: FieldRef<"Plan", 'DateTime'>
    readonly marketSegment: FieldRef<"Plan", 'String'>
    readonly costBasis: FieldRef<"Plan", 'Float'>
    readonly churnRisk: FieldRef<"Plan", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Plan findUnique
   */
  export type PlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan findUniqueOrThrow
   */
  export type PlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan findFirst
   */
  export type PlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plans.
     */
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan findFirstOrThrow
   */
  export type PlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plans.
     */
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan findMany
   */
  export type PlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plans to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan create
   */
  export type PlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The data needed to create a Plan.
     */
    data: XOR<PlanCreateInput, PlanUncheckedCreateInput>
  }

  /**
   * Plan createMany
   */
  export type PlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Plans.
     */
    data: PlanCreateManyInput | PlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Plan createManyAndReturn
   */
  export type PlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Plans.
     */
    data: PlanCreateManyInput | PlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Plan update
   */
  export type PlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The data needed to update a Plan.
     */
    data: XOR<PlanUpdateInput, PlanUncheckedUpdateInput>
    /**
     * Choose, which Plan to update.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan updateMany
   */
  export type PlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Plans.
     */
    data: XOR<PlanUpdateManyMutationInput, PlanUncheckedUpdateManyInput>
    /**
     * Filter which Plans to update
     */
    where?: PlanWhereInput
  }

  /**
   * Plan upsert
   */
  export type PlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The filter to search for the Plan to update in case it exists.
     */
    where: PlanWhereUniqueInput
    /**
     * In case the Plan found by the `where` argument doesn't exist, create a new Plan with this data.
     */
    create: XOR<PlanCreateInput, PlanUncheckedCreateInput>
    /**
     * In case the Plan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanUpdateInput, PlanUncheckedUpdateInput>
  }

  /**
   * Plan delete
   */
  export type PlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter which Plan to delete.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan deleteMany
   */
  export type PlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plans to delete
     */
    where?: PlanWhereInput
  }

  /**
   * Plan.features
   */
  export type Plan$featuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanFeature
     */
    select?: PlanFeatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanFeatureInclude<ExtArgs> | null
    where?: PlanFeatureWhereInput
    orderBy?: PlanFeatureOrderByWithRelationInput | PlanFeatureOrderByWithRelationInput[]
    cursor?: PlanFeatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanFeatureScalarFieldEnum | PlanFeatureScalarFieldEnum[]
  }

  /**
   * Plan.usageLimits
   */
  export type Plan$usageLimitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLimit
     */
    select?: UsageLimitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageLimitInclude<ExtArgs> | null
    where?: UsageLimitWhereInput
    orderBy?: UsageLimitOrderByWithRelationInput | UsageLimitOrderByWithRelationInput[]
    cursor?: UsageLimitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsageLimitScalarFieldEnum | UsageLimitScalarFieldEnum[]
  }

  /**
   * Plan.priceHistory
   */
  export type Plan$priceHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    where?: PriceHistoryWhereInput
    orderBy?: PriceHistoryOrderByWithRelationInput | PriceHistoryOrderByWithRelationInput[]
    cursor?: PriceHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PriceHistoryScalarFieldEnum | PriceHistoryScalarFieldEnum[]
  }

  /**
   * Plan.priceTests
   */
  export type Plan$priceTestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceTest
     */
    select?: PriceTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceTestInclude<ExtArgs> | null
    where?: PriceTestWhereInput
    orderBy?: PriceTestOrderByWithRelationInput | PriceTestOrderByWithRelationInput[]
    cursor?: PriceTestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PriceTestScalarFieldEnum | PriceTestScalarFieldEnum[]
  }

  /**
   * Plan.revenueRules
   */
  export type Plan$revenueRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueRecognitionRule
     */
    select?: RevenueRecognitionRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueRecognitionRuleInclude<ExtArgs> | null
    where?: RevenueRecognitionRuleWhereInput
    orderBy?: RevenueRecognitionRuleOrderByWithRelationInput | RevenueRecognitionRuleOrderByWithRelationInput[]
    cursor?: RevenueRecognitionRuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RevenueRecognitionRuleScalarFieldEnum | RevenueRecognitionRuleScalarFieldEnum[]
  }

  /**
   * Plan.subscriptions
   */
  export type Plan$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Plan without action
   */
  export type PlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
  }


  /**
   * Model PlanFeature
   */

  export type AggregatePlanFeature = {
    _count: PlanFeatureCountAggregateOutputType | null
    _avg: PlanFeatureAvgAggregateOutputType | null
    _sum: PlanFeatureSumAggregateOutputType | null
    _min: PlanFeatureMinAggregateOutputType | null
    _max: PlanFeatureMaxAggregateOutputType | null
  }

  export type PlanFeatureAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type PlanFeatureSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type PlanFeatureMinAggregateOutputType = {
    id: string | null
    planId: string | null
    name: string | null
    description: string | null
    included: boolean | null
    value: string | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanFeatureMaxAggregateOutputType = {
    id: string | null
    planId: string | null
    name: string | null
    description: string | null
    included: boolean | null
    value: string | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanFeatureCountAggregateOutputType = {
    id: number
    planId: number
    name: number
    description: number
    included: number
    value: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlanFeatureAvgAggregateInputType = {
    sortOrder?: true
  }

  export type PlanFeatureSumAggregateInputType = {
    sortOrder?: true
  }

  export type PlanFeatureMinAggregateInputType = {
    id?: true
    planId?: true
    name?: true
    description?: true
    included?: true
    value?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanFeatureMaxAggregateInputType = {
    id?: true
    planId?: true
    name?: true
    description?: true
    included?: true
    value?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanFeatureCountAggregateInputType = {
    id?: true
    planId?: true
    name?: true
    description?: true
    included?: true
    value?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlanFeatureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanFeature to aggregate.
     */
    where?: PlanFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanFeatures to fetch.
     */
    orderBy?: PlanFeatureOrderByWithRelationInput | PlanFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlanFeatures
    **/
    _count?: true | PlanFeatureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanFeatureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanFeatureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanFeatureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanFeatureMaxAggregateInputType
  }

  export type GetPlanFeatureAggregateType<T extends PlanFeatureAggregateArgs> = {
        [P in keyof T & keyof AggregatePlanFeature]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlanFeature[P]>
      : GetScalarType<T[P], AggregatePlanFeature[P]>
  }




  export type PlanFeatureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanFeatureWhereInput
    orderBy?: PlanFeatureOrderByWithAggregationInput | PlanFeatureOrderByWithAggregationInput[]
    by: PlanFeatureScalarFieldEnum[] | PlanFeatureScalarFieldEnum
    having?: PlanFeatureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanFeatureCountAggregateInputType | true
    _avg?: PlanFeatureAvgAggregateInputType
    _sum?: PlanFeatureSumAggregateInputType
    _min?: PlanFeatureMinAggregateInputType
    _max?: PlanFeatureMaxAggregateInputType
  }

  export type PlanFeatureGroupByOutputType = {
    id: string
    planId: string
    name: string
    description: string | null
    included: boolean
    value: string | null
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    _count: PlanFeatureCountAggregateOutputType | null
    _avg: PlanFeatureAvgAggregateOutputType | null
    _sum: PlanFeatureSumAggregateOutputType | null
    _min: PlanFeatureMinAggregateOutputType | null
    _max: PlanFeatureMaxAggregateOutputType | null
  }

  type GetPlanFeatureGroupByPayload<T extends PlanFeatureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanFeatureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanFeatureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanFeatureGroupByOutputType[P]>
            : GetScalarType<T[P], PlanFeatureGroupByOutputType[P]>
        }
      >
    >


  export type PlanFeatureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    name?: boolean
    description?: boolean
    included?: boolean
    value?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planFeature"]>

  export type PlanFeatureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    name?: boolean
    description?: boolean
    included?: boolean
    value?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planFeature"]>

  export type PlanFeatureSelectScalar = {
    id?: boolean
    planId?: boolean
    name?: boolean
    description?: boolean
    included?: boolean
    value?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlanFeatureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }
  export type PlanFeatureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }

  export type $PlanFeaturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlanFeature"
    objects: {
      plan: Prisma.$PlanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      planId: string
      name: string
      description: string | null
      included: boolean
      value: string | null
      sortOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["planFeature"]>
    composites: {}
  }

  type PlanFeatureGetPayload<S extends boolean | null | undefined | PlanFeatureDefaultArgs> = $Result.GetResult<Prisma.$PlanFeaturePayload, S>

  type PlanFeatureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlanFeatureFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlanFeatureCountAggregateInputType | true
    }

  export interface PlanFeatureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlanFeature'], meta: { name: 'PlanFeature' } }
    /**
     * Find zero or one PlanFeature that matches the filter.
     * @param {PlanFeatureFindUniqueArgs} args - Arguments to find a PlanFeature
     * @example
     * // Get one PlanFeature
     * const planFeature = await prisma.planFeature.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanFeatureFindUniqueArgs>(args: SelectSubset<T, PlanFeatureFindUniqueArgs<ExtArgs>>): Prisma__PlanFeatureClient<$Result.GetResult<Prisma.$PlanFeaturePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PlanFeature that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlanFeatureFindUniqueOrThrowArgs} args - Arguments to find a PlanFeature
     * @example
     * // Get one PlanFeature
     * const planFeature = await prisma.planFeature.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanFeatureFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanFeatureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanFeatureClient<$Result.GetResult<Prisma.$PlanFeaturePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PlanFeature that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFeatureFindFirstArgs} args - Arguments to find a PlanFeature
     * @example
     * // Get one PlanFeature
     * const planFeature = await prisma.planFeature.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanFeatureFindFirstArgs>(args?: SelectSubset<T, PlanFeatureFindFirstArgs<ExtArgs>>): Prisma__PlanFeatureClient<$Result.GetResult<Prisma.$PlanFeaturePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PlanFeature that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFeatureFindFirstOrThrowArgs} args - Arguments to find a PlanFeature
     * @example
     * // Get one PlanFeature
     * const planFeature = await prisma.planFeature.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanFeatureFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanFeatureFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanFeatureClient<$Result.GetResult<Prisma.$PlanFeaturePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PlanFeatures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFeatureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlanFeatures
     * const planFeatures = await prisma.planFeature.findMany()
     * 
     * // Get first 10 PlanFeatures
     * const planFeatures = await prisma.planFeature.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planFeatureWithIdOnly = await prisma.planFeature.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlanFeatureFindManyArgs>(args?: SelectSubset<T, PlanFeatureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanFeaturePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PlanFeature.
     * @param {PlanFeatureCreateArgs} args - Arguments to create a PlanFeature.
     * @example
     * // Create one PlanFeature
     * const PlanFeature = await prisma.planFeature.create({
     *   data: {
     *     // ... data to create a PlanFeature
     *   }
     * })
     * 
     */
    create<T extends PlanFeatureCreateArgs>(args: SelectSubset<T, PlanFeatureCreateArgs<ExtArgs>>): Prisma__PlanFeatureClient<$Result.GetResult<Prisma.$PlanFeaturePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PlanFeatures.
     * @param {PlanFeatureCreateManyArgs} args - Arguments to create many PlanFeatures.
     * @example
     * // Create many PlanFeatures
     * const planFeature = await prisma.planFeature.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanFeatureCreateManyArgs>(args?: SelectSubset<T, PlanFeatureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlanFeatures and returns the data saved in the database.
     * @param {PlanFeatureCreateManyAndReturnArgs} args - Arguments to create many PlanFeatures.
     * @example
     * // Create many PlanFeatures
     * const planFeature = await prisma.planFeature.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlanFeatures and only return the `id`
     * const planFeatureWithIdOnly = await prisma.planFeature.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlanFeatureCreateManyAndReturnArgs>(args?: SelectSubset<T, PlanFeatureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanFeaturePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PlanFeature.
     * @param {PlanFeatureDeleteArgs} args - Arguments to delete one PlanFeature.
     * @example
     * // Delete one PlanFeature
     * const PlanFeature = await prisma.planFeature.delete({
     *   where: {
     *     // ... filter to delete one PlanFeature
     *   }
     * })
     * 
     */
    delete<T extends PlanFeatureDeleteArgs>(args: SelectSubset<T, PlanFeatureDeleteArgs<ExtArgs>>): Prisma__PlanFeatureClient<$Result.GetResult<Prisma.$PlanFeaturePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PlanFeature.
     * @param {PlanFeatureUpdateArgs} args - Arguments to update one PlanFeature.
     * @example
     * // Update one PlanFeature
     * const planFeature = await prisma.planFeature.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanFeatureUpdateArgs>(args: SelectSubset<T, PlanFeatureUpdateArgs<ExtArgs>>): Prisma__PlanFeatureClient<$Result.GetResult<Prisma.$PlanFeaturePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PlanFeatures.
     * @param {PlanFeatureDeleteManyArgs} args - Arguments to filter PlanFeatures to delete.
     * @example
     * // Delete a few PlanFeatures
     * const { count } = await prisma.planFeature.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanFeatureDeleteManyArgs>(args?: SelectSubset<T, PlanFeatureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFeatureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlanFeatures
     * const planFeature = await prisma.planFeature.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanFeatureUpdateManyArgs>(args: SelectSubset<T, PlanFeatureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PlanFeature.
     * @param {PlanFeatureUpsertArgs} args - Arguments to update or create a PlanFeature.
     * @example
     * // Update or create a PlanFeature
     * const planFeature = await prisma.planFeature.upsert({
     *   create: {
     *     // ... data to create a PlanFeature
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlanFeature we want to update
     *   }
     * })
     */
    upsert<T extends PlanFeatureUpsertArgs>(args: SelectSubset<T, PlanFeatureUpsertArgs<ExtArgs>>): Prisma__PlanFeatureClient<$Result.GetResult<Prisma.$PlanFeaturePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PlanFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFeatureCountArgs} args - Arguments to filter PlanFeatures to count.
     * @example
     * // Count the number of PlanFeatures
     * const count = await prisma.planFeature.count({
     *   where: {
     *     // ... the filter for the PlanFeatures we want to count
     *   }
     * })
    **/
    count<T extends PlanFeatureCountArgs>(
      args?: Subset<T, PlanFeatureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanFeatureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlanFeature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFeatureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanFeatureAggregateArgs>(args: Subset<T, PlanFeatureAggregateArgs>): Prisma.PrismaPromise<GetPlanFeatureAggregateType<T>>

    /**
     * Group by PlanFeature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFeatureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanFeatureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanFeatureGroupByArgs['orderBy'] }
        : { orderBy?: PlanFeatureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanFeatureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanFeatureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlanFeature model
   */
  readonly fields: PlanFeatureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlanFeature.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanFeatureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plan<T extends PlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlanDefaultArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlanFeature model
   */ 
  interface PlanFeatureFieldRefs {
    readonly id: FieldRef<"PlanFeature", 'String'>
    readonly planId: FieldRef<"PlanFeature", 'String'>
    readonly name: FieldRef<"PlanFeature", 'String'>
    readonly description: FieldRef<"PlanFeature", 'String'>
    readonly included: FieldRef<"PlanFeature", 'Boolean'>
    readonly value: FieldRef<"PlanFeature", 'String'>
    readonly sortOrder: FieldRef<"PlanFeature", 'Int'>
    readonly createdAt: FieldRef<"PlanFeature", 'DateTime'>
    readonly updatedAt: FieldRef<"PlanFeature", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlanFeature findUnique
   */
  export type PlanFeatureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanFeature
     */
    select?: PlanFeatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanFeatureInclude<ExtArgs> | null
    /**
     * Filter, which PlanFeature to fetch.
     */
    where: PlanFeatureWhereUniqueInput
  }

  /**
   * PlanFeature findUniqueOrThrow
   */
  export type PlanFeatureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanFeature
     */
    select?: PlanFeatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanFeatureInclude<ExtArgs> | null
    /**
     * Filter, which PlanFeature to fetch.
     */
    where: PlanFeatureWhereUniqueInput
  }

  /**
   * PlanFeature findFirst
   */
  export type PlanFeatureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanFeature
     */
    select?: PlanFeatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanFeatureInclude<ExtArgs> | null
    /**
     * Filter, which PlanFeature to fetch.
     */
    where?: PlanFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanFeatures to fetch.
     */
    orderBy?: PlanFeatureOrderByWithRelationInput | PlanFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanFeatures.
     */
    cursor?: PlanFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanFeatures.
     */
    distinct?: PlanFeatureScalarFieldEnum | PlanFeatureScalarFieldEnum[]
  }

  /**
   * PlanFeature findFirstOrThrow
   */
  export type PlanFeatureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanFeature
     */
    select?: PlanFeatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanFeatureInclude<ExtArgs> | null
    /**
     * Filter, which PlanFeature to fetch.
     */
    where?: PlanFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanFeatures to fetch.
     */
    orderBy?: PlanFeatureOrderByWithRelationInput | PlanFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanFeatures.
     */
    cursor?: PlanFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanFeatures.
     */
    distinct?: PlanFeatureScalarFieldEnum | PlanFeatureScalarFieldEnum[]
  }

  /**
   * PlanFeature findMany
   */
  export type PlanFeatureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanFeature
     */
    select?: PlanFeatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanFeatureInclude<ExtArgs> | null
    /**
     * Filter, which PlanFeatures to fetch.
     */
    where?: PlanFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanFeatures to fetch.
     */
    orderBy?: PlanFeatureOrderByWithRelationInput | PlanFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlanFeatures.
     */
    cursor?: PlanFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanFeatures.
     */
    skip?: number
    distinct?: PlanFeatureScalarFieldEnum | PlanFeatureScalarFieldEnum[]
  }

  /**
   * PlanFeature create
   */
  export type PlanFeatureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanFeature
     */
    select?: PlanFeatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanFeatureInclude<ExtArgs> | null
    /**
     * The data needed to create a PlanFeature.
     */
    data: XOR<PlanFeatureCreateInput, PlanFeatureUncheckedCreateInput>
  }

  /**
   * PlanFeature createMany
   */
  export type PlanFeatureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlanFeatures.
     */
    data: PlanFeatureCreateManyInput | PlanFeatureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlanFeature createManyAndReturn
   */
  export type PlanFeatureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanFeature
     */
    select?: PlanFeatureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PlanFeatures.
     */
    data: PlanFeatureCreateManyInput | PlanFeatureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanFeatureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlanFeature update
   */
  export type PlanFeatureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanFeature
     */
    select?: PlanFeatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanFeatureInclude<ExtArgs> | null
    /**
     * The data needed to update a PlanFeature.
     */
    data: XOR<PlanFeatureUpdateInput, PlanFeatureUncheckedUpdateInput>
    /**
     * Choose, which PlanFeature to update.
     */
    where: PlanFeatureWhereUniqueInput
  }

  /**
   * PlanFeature updateMany
   */
  export type PlanFeatureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlanFeatures.
     */
    data: XOR<PlanFeatureUpdateManyMutationInput, PlanFeatureUncheckedUpdateManyInput>
    /**
     * Filter which PlanFeatures to update
     */
    where?: PlanFeatureWhereInput
  }

  /**
   * PlanFeature upsert
   */
  export type PlanFeatureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanFeature
     */
    select?: PlanFeatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanFeatureInclude<ExtArgs> | null
    /**
     * The filter to search for the PlanFeature to update in case it exists.
     */
    where: PlanFeatureWhereUniqueInput
    /**
     * In case the PlanFeature found by the `where` argument doesn't exist, create a new PlanFeature with this data.
     */
    create: XOR<PlanFeatureCreateInput, PlanFeatureUncheckedCreateInput>
    /**
     * In case the PlanFeature was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanFeatureUpdateInput, PlanFeatureUncheckedUpdateInput>
  }

  /**
   * PlanFeature delete
   */
  export type PlanFeatureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanFeature
     */
    select?: PlanFeatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanFeatureInclude<ExtArgs> | null
    /**
     * Filter which PlanFeature to delete.
     */
    where: PlanFeatureWhereUniqueInput
  }

  /**
   * PlanFeature deleteMany
   */
  export type PlanFeatureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanFeatures to delete
     */
    where?: PlanFeatureWhereInput
  }

  /**
   * PlanFeature without action
   */
  export type PlanFeatureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanFeature
     */
    select?: PlanFeatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanFeatureInclude<ExtArgs> | null
  }


  /**
   * Model UsageLimit
   */

  export type AggregateUsageLimit = {
    _count: UsageLimitCountAggregateOutputType | null
    _avg: UsageLimitAvgAggregateOutputType | null
    _sum: UsageLimitSumAggregateOutputType | null
    _min: UsageLimitMinAggregateOutputType | null
    _max: UsageLimitMaxAggregateOutputType | null
  }

  export type UsageLimitAvgAggregateOutputType = {
    limit: number | null
    overagePrice: number | null
  }

  export type UsageLimitSumAggregateOutputType = {
    limit: number | null
    overagePrice: number | null
  }

  export type UsageLimitMinAggregateOutputType = {
    id: string | null
    planId: string | null
    featureKey: string | null
    limit: number | null
    interval: string | null
    overage: boolean | null
    overagePrice: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsageLimitMaxAggregateOutputType = {
    id: string | null
    planId: string | null
    featureKey: string | null
    limit: number | null
    interval: string | null
    overage: boolean | null
    overagePrice: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsageLimitCountAggregateOutputType = {
    id: number
    planId: number
    featureKey: number
    limit: number
    interval: number
    overage: number
    overagePrice: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UsageLimitAvgAggregateInputType = {
    limit?: true
    overagePrice?: true
  }

  export type UsageLimitSumAggregateInputType = {
    limit?: true
    overagePrice?: true
  }

  export type UsageLimitMinAggregateInputType = {
    id?: true
    planId?: true
    featureKey?: true
    limit?: true
    interval?: true
    overage?: true
    overagePrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsageLimitMaxAggregateInputType = {
    id?: true
    planId?: true
    featureKey?: true
    limit?: true
    interval?: true
    overage?: true
    overagePrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsageLimitCountAggregateInputType = {
    id?: true
    planId?: true
    featureKey?: true
    limit?: true
    interval?: true
    overage?: true
    overagePrice?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UsageLimitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsageLimit to aggregate.
     */
    where?: UsageLimitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageLimits to fetch.
     */
    orderBy?: UsageLimitOrderByWithRelationInput | UsageLimitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsageLimitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageLimits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageLimits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UsageLimits
    **/
    _count?: true | UsageLimitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsageLimitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsageLimitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsageLimitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsageLimitMaxAggregateInputType
  }

  export type GetUsageLimitAggregateType<T extends UsageLimitAggregateArgs> = {
        [P in keyof T & keyof AggregateUsageLimit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsageLimit[P]>
      : GetScalarType<T[P], AggregateUsageLimit[P]>
  }




  export type UsageLimitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsageLimitWhereInput
    orderBy?: UsageLimitOrderByWithAggregationInput | UsageLimitOrderByWithAggregationInput[]
    by: UsageLimitScalarFieldEnum[] | UsageLimitScalarFieldEnum
    having?: UsageLimitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsageLimitCountAggregateInputType | true
    _avg?: UsageLimitAvgAggregateInputType
    _sum?: UsageLimitSumAggregateInputType
    _min?: UsageLimitMinAggregateInputType
    _max?: UsageLimitMaxAggregateInputType
  }

  export type UsageLimitGroupByOutputType = {
    id: string
    planId: string
    featureKey: string
    limit: number
    interval: string
    overage: boolean
    overagePrice: number | null
    createdAt: Date
    updatedAt: Date
    _count: UsageLimitCountAggregateOutputType | null
    _avg: UsageLimitAvgAggregateOutputType | null
    _sum: UsageLimitSumAggregateOutputType | null
    _min: UsageLimitMinAggregateOutputType | null
    _max: UsageLimitMaxAggregateOutputType | null
  }

  type GetUsageLimitGroupByPayload<T extends UsageLimitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsageLimitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsageLimitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsageLimitGroupByOutputType[P]>
            : GetScalarType<T[P], UsageLimitGroupByOutputType[P]>
        }
      >
    >


  export type UsageLimitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    featureKey?: boolean
    limit?: boolean
    interval?: boolean
    overage?: boolean
    overagePrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usageLimit"]>

  export type UsageLimitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    featureKey?: boolean
    limit?: boolean
    interval?: boolean
    overage?: boolean
    overagePrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usageLimit"]>

  export type UsageLimitSelectScalar = {
    id?: boolean
    planId?: boolean
    featureKey?: boolean
    limit?: boolean
    interval?: boolean
    overage?: boolean
    overagePrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UsageLimitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }
  export type UsageLimitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }

  export type $UsageLimitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UsageLimit"
    objects: {
      plan: Prisma.$PlanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      planId: string
      featureKey: string
      limit: number
      interval: string
      overage: boolean
      overagePrice: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["usageLimit"]>
    composites: {}
  }

  type UsageLimitGetPayload<S extends boolean | null | undefined | UsageLimitDefaultArgs> = $Result.GetResult<Prisma.$UsageLimitPayload, S>

  type UsageLimitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsageLimitFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsageLimitCountAggregateInputType | true
    }

  export interface UsageLimitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UsageLimit'], meta: { name: 'UsageLimit' } }
    /**
     * Find zero or one UsageLimit that matches the filter.
     * @param {UsageLimitFindUniqueArgs} args - Arguments to find a UsageLimit
     * @example
     * // Get one UsageLimit
     * const usageLimit = await prisma.usageLimit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsageLimitFindUniqueArgs>(args: SelectSubset<T, UsageLimitFindUniqueArgs<ExtArgs>>): Prisma__UsageLimitClient<$Result.GetResult<Prisma.$UsageLimitPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UsageLimit that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UsageLimitFindUniqueOrThrowArgs} args - Arguments to find a UsageLimit
     * @example
     * // Get one UsageLimit
     * const usageLimit = await prisma.usageLimit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsageLimitFindUniqueOrThrowArgs>(args: SelectSubset<T, UsageLimitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsageLimitClient<$Result.GetResult<Prisma.$UsageLimitPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UsageLimit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageLimitFindFirstArgs} args - Arguments to find a UsageLimit
     * @example
     * // Get one UsageLimit
     * const usageLimit = await prisma.usageLimit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsageLimitFindFirstArgs>(args?: SelectSubset<T, UsageLimitFindFirstArgs<ExtArgs>>): Prisma__UsageLimitClient<$Result.GetResult<Prisma.$UsageLimitPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UsageLimit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageLimitFindFirstOrThrowArgs} args - Arguments to find a UsageLimit
     * @example
     * // Get one UsageLimit
     * const usageLimit = await prisma.usageLimit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsageLimitFindFirstOrThrowArgs>(args?: SelectSubset<T, UsageLimitFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsageLimitClient<$Result.GetResult<Prisma.$UsageLimitPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UsageLimits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageLimitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsageLimits
     * const usageLimits = await prisma.usageLimit.findMany()
     * 
     * // Get first 10 UsageLimits
     * const usageLimits = await prisma.usageLimit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usageLimitWithIdOnly = await prisma.usageLimit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsageLimitFindManyArgs>(args?: SelectSubset<T, UsageLimitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageLimitPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UsageLimit.
     * @param {UsageLimitCreateArgs} args - Arguments to create a UsageLimit.
     * @example
     * // Create one UsageLimit
     * const UsageLimit = await prisma.usageLimit.create({
     *   data: {
     *     // ... data to create a UsageLimit
     *   }
     * })
     * 
     */
    create<T extends UsageLimitCreateArgs>(args: SelectSubset<T, UsageLimitCreateArgs<ExtArgs>>): Prisma__UsageLimitClient<$Result.GetResult<Prisma.$UsageLimitPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UsageLimits.
     * @param {UsageLimitCreateManyArgs} args - Arguments to create many UsageLimits.
     * @example
     * // Create many UsageLimits
     * const usageLimit = await prisma.usageLimit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsageLimitCreateManyArgs>(args?: SelectSubset<T, UsageLimitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UsageLimits and returns the data saved in the database.
     * @param {UsageLimitCreateManyAndReturnArgs} args - Arguments to create many UsageLimits.
     * @example
     * // Create many UsageLimits
     * const usageLimit = await prisma.usageLimit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UsageLimits and only return the `id`
     * const usageLimitWithIdOnly = await prisma.usageLimit.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsageLimitCreateManyAndReturnArgs>(args?: SelectSubset<T, UsageLimitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageLimitPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UsageLimit.
     * @param {UsageLimitDeleteArgs} args - Arguments to delete one UsageLimit.
     * @example
     * // Delete one UsageLimit
     * const UsageLimit = await prisma.usageLimit.delete({
     *   where: {
     *     // ... filter to delete one UsageLimit
     *   }
     * })
     * 
     */
    delete<T extends UsageLimitDeleteArgs>(args: SelectSubset<T, UsageLimitDeleteArgs<ExtArgs>>): Prisma__UsageLimitClient<$Result.GetResult<Prisma.$UsageLimitPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UsageLimit.
     * @param {UsageLimitUpdateArgs} args - Arguments to update one UsageLimit.
     * @example
     * // Update one UsageLimit
     * const usageLimit = await prisma.usageLimit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsageLimitUpdateArgs>(args: SelectSubset<T, UsageLimitUpdateArgs<ExtArgs>>): Prisma__UsageLimitClient<$Result.GetResult<Prisma.$UsageLimitPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UsageLimits.
     * @param {UsageLimitDeleteManyArgs} args - Arguments to filter UsageLimits to delete.
     * @example
     * // Delete a few UsageLimits
     * const { count } = await prisma.usageLimit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsageLimitDeleteManyArgs>(args?: SelectSubset<T, UsageLimitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsageLimits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageLimitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsageLimits
     * const usageLimit = await prisma.usageLimit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsageLimitUpdateManyArgs>(args: SelectSubset<T, UsageLimitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UsageLimit.
     * @param {UsageLimitUpsertArgs} args - Arguments to update or create a UsageLimit.
     * @example
     * // Update or create a UsageLimit
     * const usageLimit = await prisma.usageLimit.upsert({
     *   create: {
     *     // ... data to create a UsageLimit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsageLimit we want to update
     *   }
     * })
     */
    upsert<T extends UsageLimitUpsertArgs>(args: SelectSubset<T, UsageLimitUpsertArgs<ExtArgs>>): Prisma__UsageLimitClient<$Result.GetResult<Prisma.$UsageLimitPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UsageLimits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageLimitCountArgs} args - Arguments to filter UsageLimits to count.
     * @example
     * // Count the number of UsageLimits
     * const count = await prisma.usageLimit.count({
     *   where: {
     *     // ... the filter for the UsageLimits we want to count
     *   }
     * })
    **/
    count<T extends UsageLimitCountArgs>(
      args?: Subset<T, UsageLimitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsageLimitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsageLimit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageLimitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsageLimitAggregateArgs>(args: Subset<T, UsageLimitAggregateArgs>): Prisma.PrismaPromise<GetUsageLimitAggregateType<T>>

    /**
     * Group by UsageLimit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageLimitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsageLimitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsageLimitGroupByArgs['orderBy'] }
        : { orderBy?: UsageLimitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsageLimitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsageLimitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UsageLimit model
   */
  readonly fields: UsageLimitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UsageLimit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsageLimitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plan<T extends PlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlanDefaultArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UsageLimit model
   */ 
  interface UsageLimitFieldRefs {
    readonly id: FieldRef<"UsageLimit", 'String'>
    readonly planId: FieldRef<"UsageLimit", 'String'>
    readonly featureKey: FieldRef<"UsageLimit", 'String'>
    readonly limit: FieldRef<"UsageLimit", 'Float'>
    readonly interval: FieldRef<"UsageLimit", 'String'>
    readonly overage: FieldRef<"UsageLimit", 'Boolean'>
    readonly overagePrice: FieldRef<"UsageLimit", 'Float'>
    readonly createdAt: FieldRef<"UsageLimit", 'DateTime'>
    readonly updatedAt: FieldRef<"UsageLimit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UsageLimit findUnique
   */
  export type UsageLimitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLimit
     */
    select?: UsageLimitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageLimitInclude<ExtArgs> | null
    /**
     * Filter, which UsageLimit to fetch.
     */
    where: UsageLimitWhereUniqueInput
  }

  /**
   * UsageLimit findUniqueOrThrow
   */
  export type UsageLimitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLimit
     */
    select?: UsageLimitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageLimitInclude<ExtArgs> | null
    /**
     * Filter, which UsageLimit to fetch.
     */
    where: UsageLimitWhereUniqueInput
  }

  /**
   * UsageLimit findFirst
   */
  export type UsageLimitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLimit
     */
    select?: UsageLimitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageLimitInclude<ExtArgs> | null
    /**
     * Filter, which UsageLimit to fetch.
     */
    where?: UsageLimitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageLimits to fetch.
     */
    orderBy?: UsageLimitOrderByWithRelationInput | UsageLimitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsageLimits.
     */
    cursor?: UsageLimitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageLimits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageLimits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsageLimits.
     */
    distinct?: UsageLimitScalarFieldEnum | UsageLimitScalarFieldEnum[]
  }

  /**
   * UsageLimit findFirstOrThrow
   */
  export type UsageLimitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLimit
     */
    select?: UsageLimitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageLimitInclude<ExtArgs> | null
    /**
     * Filter, which UsageLimit to fetch.
     */
    where?: UsageLimitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageLimits to fetch.
     */
    orderBy?: UsageLimitOrderByWithRelationInput | UsageLimitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsageLimits.
     */
    cursor?: UsageLimitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageLimits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageLimits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsageLimits.
     */
    distinct?: UsageLimitScalarFieldEnum | UsageLimitScalarFieldEnum[]
  }

  /**
   * UsageLimit findMany
   */
  export type UsageLimitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLimit
     */
    select?: UsageLimitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageLimitInclude<ExtArgs> | null
    /**
     * Filter, which UsageLimits to fetch.
     */
    where?: UsageLimitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageLimits to fetch.
     */
    orderBy?: UsageLimitOrderByWithRelationInput | UsageLimitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UsageLimits.
     */
    cursor?: UsageLimitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageLimits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageLimits.
     */
    skip?: number
    distinct?: UsageLimitScalarFieldEnum | UsageLimitScalarFieldEnum[]
  }

  /**
   * UsageLimit create
   */
  export type UsageLimitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLimit
     */
    select?: UsageLimitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageLimitInclude<ExtArgs> | null
    /**
     * The data needed to create a UsageLimit.
     */
    data: XOR<UsageLimitCreateInput, UsageLimitUncheckedCreateInput>
  }

  /**
   * UsageLimit createMany
   */
  export type UsageLimitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UsageLimits.
     */
    data: UsageLimitCreateManyInput | UsageLimitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UsageLimit createManyAndReturn
   */
  export type UsageLimitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLimit
     */
    select?: UsageLimitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UsageLimits.
     */
    data: UsageLimitCreateManyInput | UsageLimitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageLimitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UsageLimit update
   */
  export type UsageLimitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLimit
     */
    select?: UsageLimitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageLimitInclude<ExtArgs> | null
    /**
     * The data needed to update a UsageLimit.
     */
    data: XOR<UsageLimitUpdateInput, UsageLimitUncheckedUpdateInput>
    /**
     * Choose, which UsageLimit to update.
     */
    where: UsageLimitWhereUniqueInput
  }

  /**
   * UsageLimit updateMany
   */
  export type UsageLimitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UsageLimits.
     */
    data: XOR<UsageLimitUpdateManyMutationInput, UsageLimitUncheckedUpdateManyInput>
    /**
     * Filter which UsageLimits to update
     */
    where?: UsageLimitWhereInput
  }

  /**
   * UsageLimit upsert
   */
  export type UsageLimitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLimit
     */
    select?: UsageLimitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageLimitInclude<ExtArgs> | null
    /**
     * The filter to search for the UsageLimit to update in case it exists.
     */
    where: UsageLimitWhereUniqueInput
    /**
     * In case the UsageLimit found by the `where` argument doesn't exist, create a new UsageLimit with this data.
     */
    create: XOR<UsageLimitCreateInput, UsageLimitUncheckedCreateInput>
    /**
     * In case the UsageLimit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsageLimitUpdateInput, UsageLimitUncheckedUpdateInput>
  }

  /**
   * UsageLimit delete
   */
  export type UsageLimitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLimit
     */
    select?: UsageLimitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageLimitInclude<ExtArgs> | null
    /**
     * Filter which UsageLimit to delete.
     */
    where: UsageLimitWhereUniqueInput
  }

  /**
   * UsageLimit deleteMany
   */
  export type UsageLimitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsageLimits to delete
     */
    where?: UsageLimitWhereInput
  }

  /**
   * UsageLimit without action
   */
  export type UsageLimitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLimit
     */
    select?: UsageLimitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageLimitInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    amount: number | null
  }

  export type InvoiceSumAggregateOutputType = {
    amount: number | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    amount: number | null
    currency: string | null
    status: string | null
    stripeInvoiceId: string | null
    pdfUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    amount: number | null
    currency: string | null
    status: string | null
    stripeInvoiceId: string | null
    pdfUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    organizationId: number
    amount: number
    currency: number
    status: number
    stripeInvoiceId: number
    pdfUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    amount?: true
  }

  export type InvoiceSumAggregateInputType = {
    amount?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    organizationId?: true
    amount?: true
    currency?: true
    status?: true
    stripeInvoiceId?: true
    pdfUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    organizationId?: true
    amount?: true
    currency?: true
    status?: true
    stripeInvoiceId?: true
    pdfUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    organizationId?: true
    amount?: true
    currency?: true
    status?: true
    stripeInvoiceId?: true
    pdfUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    organizationId: string
    amount: number
    currency: string
    status: string
    stripeInvoiceId: string | null
    pdfUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    stripeInvoiceId?: boolean
    pdfUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    stripeInvoiceId?: boolean
    pdfUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    organizationId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    stripeInvoiceId?: boolean
    pdfUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string
      amount: number
      currency: string
      status: string
      stripeInvoiceId: string | null
      pdfUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */ 
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly organizationId: FieldRef<"Invoice", 'String'>
    readonly amount: FieldRef<"Invoice", 'Float'>
    readonly currency: FieldRef<"Invoice", 'String'>
    readonly status: FieldRef<"Invoice", 'String'>
    readonly stripeInvoiceId: FieldRef<"Invoice", 'String'>
    readonly pdfUrl: FieldRef<"Invoice", 'String'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
    readonly updatedAt: FieldRef<"Invoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
  }


  /**
   * Model UsageRecord
   */

  export type AggregateUsageRecord = {
    _count: UsageRecordCountAggregateOutputType | null
    _avg: UsageRecordAvgAggregateOutputType | null
    _sum: UsageRecordSumAggregateOutputType | null
    _min: UsageRecordMinAggregateOutputType | null
    _max: UsageRecordMaxAggregateOutputType | null
  }

  export type UsageRecordAvgAggregateOutputType = {
    quantity: number | null
  }

  export type UsageRecordSumAggregateOutputType = {
    quantity: number | null
  }

  export type UsageRecordMinAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    featureKey: string | null
    quantity: number | null
    timestamp: Date | null
    billingPeriodStart: Date | null
    billingPeriodEnd: Date | null
    processed: boolean | null
  }

  export type UsageRecordMaxAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    featureKey: string | null
    quantity: number | null
    timestamp: Date | null
    billingPeriodStart: Date | null
    billingPeriodEnd: Date | null
    processed: boolean | null
  }

  export type UsageRecordCountAggregateOutputType = {
    id: number
    subscriptionId: number
    featureKey: number
    quantity: number
    timestamp: number
    billingPeriodStart: number
    billingPeriodEnd: number
    processed: number
    metadata: number
    _all: number
  }


  export type UsageRecordAvgAggregateInputType = {
    quantity?: true
  }

  export type UsageRecordSumAggregateInputType = {
    quantity?: true
  }

  export type UsageRecordMinAggregateInputType = {
    id?: true
    subscriptionId?: true
    featureKey?: true
    quantity?: true
    timestamp?: true
    billingPeriodStart?: true
    billingPeriodEnd?: true
    processed?: true
  }

  export type UsageRecordMaxAggregateInputType = {
    id?: true
    subscriptionId?: true
    featureKey?: true
    quantity?: true
    timestamp?: true
    billingPeriodStart?: true
    billingPeriodEnd?: true
    processed?: true
  }

  export type UsageRecordCountAggregateInputType = {
    id?: true
    subscriptionId?: true
    featureKey?: true
    quantity?: true
    timestamp?: true
    billingPeriodStart?: true
    billingPeriodEnd?: true
    processed?: true
    metadata?: true
    _all?: true
  }

  export type UsageRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsageRecord to aggregate.
     */
    where?: UsageRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageRecords to fetch.
     */
    orderBy?: UsageRecordOrderByWithRelationInput | UsageRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsageRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UsageRecords
    **/
    _count?: true | UsageRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsageRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsageRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsageRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsageRecordMaxAggregateInputType
  }

  export type GetUsageRecordAggregateType<T extends UsageRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateUsageRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsageRecord[P]>
      : GetScalarType<T[P], AggregateUsageRecord[P]>
  }




  export type UsageRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsageRecordWhereInput
    orderBy?: UsageRecordOrderByWithAggregationInput | UsageRecordOrderByWithAggregationInput[]
    by: UsageRecordScalarFieldEnum[] | UsageRecordScalarFieldEnum
    having?: UsageRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsageRecordCountAggregateInputType | true
    _avg?: UsageRecordAvgAggregateInputType
    _sum?: UsageRecordSumAggregateInputType
    _min?: UsageRecordMinAggregateInputType
    _max?: UsageRecordMaxAggregateInputType
  }

  export type UsageRecordGroupByOutputType = {
    id: string
    subscriptionId: string
    featureKey: string
    quantity: number
    timestamp: Date
    billingPeriodStart: Date
    billingPeriodEnd: Date
    processed: boolean
    metadata: JsonValue | null
    _count: UsageRecordCountAggregateOutputType | null
    _avg: UsageRecordAvgAggregateOutputType | null
    _sum: UsageRecordSumAggregateOutputType | null
    _min: UsageRecordMinAggregateOutputType | null
    _max: UsageRecordMaxAggregateOutputType | null
  }

  type GetUsageRecordGroupByPayload<T extends UsageRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsageRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsageRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsageRecordGroupByOutputType[P]>
            : GetScalarType<T[P], UsageRecordGroupByOutputType[P]>
        }
      >
    >


  export type UsageRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    featureKey?: boolean
    quantity?: boolean
    timestamp?: boolean
    billingPeriodStart?: boolean
    billingPeriodEnd?: boolean
    processed?: boolean
    metadata?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usageRecord"]>

  export type UsageRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    featureKey?: boolean
    quantity?: boolean
    timestamp?: boolean
    billingPeriodStart?: boolean
    billingPeriodEnd?: boolean
    processed?: boolean
    metadata?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usageRecord"]>

  export type UsageRecordSelectScalar = {
    id?: boolean
    subscriptionId?: boolean
    featureKey?: boolean
    quantity?: boolean
    timestamp?: boolean
    billingPeriodStart?: boolean
    billingPeriodEnd?: boolean
    processed?: boolean
    metadata?: boolean
  }

  export type UsageRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }
  export type UsageRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }

  export type $UsageRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UsageRecord"
    objects: {
      subscription: Prisma.$SubscriptionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subscriptionId: string
      featureKey: string
      quantity: number
      timestamp: Date
      billingPeriodStart: Date
      billingPeriodEnd: Date
      processed: boolean
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["usageRecord"]>
    composites: {}
  }

  type UsageRecordGetPayload<S extends boolean | null | undefined | UsageRecordDefaultArgs> = $Result.GetResult<Prisma.$UsageRecordPayload, S>

  type UsageRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsageRecordFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsageRecordCountAggregateInputType | true
    }

  export interface UsageRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UsageRecord'], meta: { name: 'UsageRecord' } }
    /**
     * Find zero or one UsageRecord that matches the filter.
     * @param {UsageRecordFindUniqueArgs} args - Arguments to find a UsageRecord
     * @example
     * // Get one UsageRecord
     * const usageRecord = await prisma.usageRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsageRecordFindUniqueArgs>(args: SelectSubset<T, UsageRecordFindUniqueArgs<ExtArgs>>): Prisma__UsageRecordClient<$Result.GetResult<Prisma.$UsageRecordPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UsageRecord that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UsageRecordFindUniqueOrThrowArgs} args - Arguments to find a UsageRecord
     * @example
     * // Get one UsageRecord
     * const usageRecord = await prisma.usageRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsageRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, UsageRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsageRecordClient<$Result.GetResult<Prisma.$UsageRecordPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UsageRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageRecordFindFirstArgs} args - Arguments to find a UsageRecord
     * @example
     * // Get one UsageRecord
     * const usageRecord = await prisma.usageRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsageRecordFindFirstArgs>(args?: SelectSubset<T, UsageRecordFindFirstArgs<ExtArgs>>): Prisma__UsageRecordClient<$Result.GetResult<Prisma.$UsageRecordPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UsageRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageRecordFindFirstOrThrowArgs} args - Arguments to find a UsageRecord
     * @example
     * // Get one UsageRecord
     * const usageRecord = await prisma.usageRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsageRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, UsageRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsageRecordClient<$Result.GetResult<Prisma.$UsageRecordPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UsageRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsageRecords
     * const usageRecords = await prisma.usageRecord.findMany()
     * 
     * // Get first 10 UsageRecords
     * const usageRecords = await prisma.usageRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usageRecordWithIdOnly = await prisma.usageRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsageRecordFindManyArgs>(args?: SelectSubset<T, UsageRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageRecordPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UsageRecord.
     * @param {UsageRecordCreateArgs} args - Arguments to create a UsageRecord.
     * @example
     * // Create one UsageRecord
     * const UsageRecord = await prisma.usageRecord.create({
     *   data: {
     *     // ... data to create a UsageRecord
     *   }
     * })
     * 
     */
    create<T extends UsageRecordCreateArgs>(args: SelectSubset<T, UsageRecordCreateArgs<ExtArgs>>): Prisma__UsageRecordClient<$Result.GetResult<Prisma.$UsageRecordPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UsageRecords.
     * @param {UsageRecordCreateManyArgs} args - Arguments to create many UsageRecords.
     * @example
     * // Create many UsageRecords
     * const usageRecord = await prisma.usageRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsageRecordCreateManyArgs>(args?: SelectSubset<T, UsageRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UsageRecords and returns the data saved in the database.
     * @param {UsageRecordCreateManyAndReturnArgs} args - Arguments to create many UsageRecords.
     * @example
     * // Create many UsageRecords
     * const usageRecord = await prisma.usageRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UsageRecords and only return the `id`
     * const usageRecordWithIdOnly = await prisma.usageRecord.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsageRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, UsageRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageRecordPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UsageRecord.
     * @param {UsageRecordDeleteArgs} args - Arguments to delete one UsageRecord.
     * @example
     * // Delete one UsageRecord
     * const UsageRecord = await prisma.usageRecord.delete({
     *   where: {
     *     // ... filter to delete one UsageRecord
     *   }
     * })
     * 
     */
    delete<T extends UsageRecordDeleteArgs>(args: SelectSubset<T, UsageRecordDeleteArgs<ExtArgs>>): Prisma__UsageRecordClient<$Result.GetResult<Prisma.$UsageRecordPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UsageRecord.
     * @param {UsageRecordUpdateArgs} args - Arguments to update one UsageRecord.
     * @example
     * // Update one UsageRecord
     * const usageRecord = await prisma.usageRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsageRecordUpdateArgs>(args: SelectSubset<T, UsageRecordUpdateArgs<ExtArgs>>): Prisma__UsageRecordClient<$Result.GetResult<Prisma.$UsageRecordPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UsageRecords.
     * @param {UsageRecordDeleteManyArgs} args - Arguments to filter UsageRecords to delete.
     * @example
     * // Delete a few UsageRecords
     * const { count } = await prisma.usageRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsageRecordDeleteManyArgs>(args?: SelectSubset<T, UsageRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsageRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsageRecords
     * const usageRecord = await prisma.usageRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsageRecordUpdateManyArgs>(args: SelectSubset<T, UsageRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UsageRecord.
     * @param {UsageRecordUpsertArgs} args - Arguments to update or create a UsageRecord.
     * @example
     * // Update or create a UsageRecord
     * const usageRecord = await prisma.usageRecord.upsert({
     *   create: {
     *     // ... data to create a UsageRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsageRecord we want to update
     *   }
     * })
     */
    upsert<T extends UsageRecordUpsertArgs>(args: SelectSubset<T, UsageRecordUpsertArgs<ExtArgs>>): Prisma__UsageRecordClient<$Result.GetResult<Prisma.$UsageRecordPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UsageRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageRecordCountArgs} args - Arguments to filter UsageRecords to count.
     * @example
     * // Count the number of UsageRecords
     * const count = await prisma.usageRecord.count({
     *   where: {
     *     // ... the filter for the UsageRecords we want to count
     *   }
     * })
    **/
    count<T extends UsageRecordCountArgs>(
      args?: Subset<T, UsageRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsageRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsageRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsageRecordAggregateArgs>(args: Subset<T, UsageRecordAggregateArgs>): Prisma.PrismaPromise<GetUsageRecordAggregateType<T>>

    /**
     * Group by UsageRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsageRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsageRecordGroupByArgs['orderBy'] }
        : { orderBy?: UsageRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsageRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsageRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UsageRecord model
   */
  readonly fields: UsageRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UsageRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsageRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscription<T extends SubscriptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionDefaultArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UsageRecord model
   */ 
  interface UsageRecordFieldRefs {
    readonly id: FieldRef<"UsageRecord", 'String'>
    readonly subscriptionId: FieldRef<"UsageRecord", 'String'>
    readonly featureKey: FieldRef<"UsageRecord", 'String'>
    readonly quantity: FieldRef<"UsageRecord", 'Float'>
    readonly timestamp: FieldRef<"UsageRecord", 'DateTime'>
    readonly billingPeriodStart: FieldRef<"UsageRecord", 'DateTime'>
    readonly billingPeriodEnd: FieldRef<"UsageRecord", 'DateTime'>
    readonly processed: FieldRef<"UsageRecord", 'Boolean'>
    readonly metadata: FieldRef<"UsageRecord", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * UsageRecord findUnique
   */
  export type UsageRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageRecordInclude<ExtArgs> | null
    /**
     * Filter, which UsageRecord to fetch.
     */
    where: UsageRecordWhereUniqueInput
  }

  /**
   * UsageRecord findUniqueOrThrow
   */
  export type UsageRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageRecordInclude<ExtArgs> | null
    /**
     * Filter, which UsageRecord to fetch.
     */
    where: UsageRecordWhereUniqueInput
  }

  /**
   * UsageRecord findFirst
   */
  export type UsageRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageRecordInclude<ExtArgs> | null
    /**
     * Filter, which UsageRecord to fetch.
     */
    where?: UsageRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageRecords to fetch.
     */
    orderBy?: UsageRecordOrderByWithRelationInput | UsageRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsageRecords.
     */
    cursor?: UsageRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsageRecords.
     */
    distinct?: UsageRecordScalarFieldEnum | UsageRecordScalarFieldEnum[]
  }

  /**
   * UsageRecord findFirstOrThrow
   */
  export type UsageRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageRecordInclude<ExtArgs> | null
    /**
     * Filter, which UsageRecord to fetch.
     */
    where?: UsageRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageRecords to fetch.
     */
    orderBy?: UsageRecordOrderByWithRelationInput | UsageRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsageRecords.
     */
    cursor?: UsageRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsageRecords.
     */
    distinct?: UsageRecordScalarFieldEnum | UsageRecordScalarFieldEnum[]
  }

  /**
   * UsageRecord findMany
   */
  export type UsageRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageRecordInclude<ExtArgs> | null
    /**
     * Filter, which UsageRecords to fetch.
     */
    where?: UsageRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageRecords to fetch.
     */
    orderBy?: UsageRecordOrderByWithRelationInput | UsageRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UsageRecords.
     */
    cursor?: UsageRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageRecords.
     */
    skip?: number
    distinct?: UsageRecordScalarFieldEnum | UsageRecordScalarFieldEnum[]
  }

  /**
   * UsageRecord create
   */
  export type UsageRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a UsageRecord.
     */
    data: XOR<UsageRecordCreateInput, UsageRecordUncheckedCreateInput>
  }

  /**
   * UsageRecord createMany
   */
  export type UsageRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UsageRecords.
     */
    data: UsageRecordCreateManyInput | UsageRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UsageRecord createManyAndReturn
   */
  export type UsageRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UsageRecords.
     */
    data: UsageRecordCreateManyInput | UsageRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UsageRecord update
   */
  export type UsageRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a UsageRecord.
     */
    data: XOR<UsageRecordUpdateInput, UsageRecordUncheckedUpdateInput>
    /**
     * Choose, which UsageRecord to update.
     */
    where: UsageRecordWhereUniqueInput
  }

  /**
   * UsageRecord updateMany
   */
  export type UsageRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UsageRecords.
     */
    data: XOR<UsageRecordUpdateManyMutationInput, UsageRecordUncheckedUpdateManyInput>
    /**
     * Filter which UsageRecords to update
     */
    where?: UsageRecordWhereInput
  }

  /**
   * UsageRecord upsert
   */
  export type UsageRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the UsageRecord to update in case it exists.
     */
    where: UsageRecordWhereUniqueInput
    /**
     * In case the UsageRecord found by the `where` argument doesn't exist, create a new UsageRecord with this data.
     */
    create: XOR<UsageRecordCreateInput, UsageRecordUncheckedCreateInput>
    /**
     * In case the UsageRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsageRecordUpdateInput, UsageRecordUncheckedUpdateInput>
  }

  /**
   * UsageRecord delete
   */
  export type UsageRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageRecordInclude<ExtArgs> | null
    /**
     * Filter which UsageRecord to delete.
     */
    where: UsageRecordWhereUniqueInput
  }

  /**
   * UsageRecord deleteMany
   */
  export type UsageRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsageRecords to delete
     */
    where?: UsageRecordWhereInput
  }

  /**
   * UsageRecord without action
   */
  export type UsageRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageRecordInclude<ExtArgs> | null
  }


  /**
   * Model Report
   */

  export type AggregateReport = {
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  export type ReportMinAggregateOutputType = {
    id: string | null
    type: string | null
    format: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    downloadUrl: string | null
  }

  export type ReportMaxAggregateOutputType = {
    id: string | null
    type: string | null
    format: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    downloadUrl: string | null
  }

  export type ReportCountAggregateOutputType = {
    id: number
    type: number
    format: number
    status: number
    createdAt: number
    updatedAt: number
    createdBy: number
    downloadUrl: number
    metadata: number
    _all: number
  }


  export type ReportMinAggregateInputType = {
    id?: true
    type?: true
    format?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    downloadUrl?: true
  }

  export type ReportMaxAggregateInputType = {
    id?: true
    type?: true
    format?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    downloadUrl?: true
  }

  export type ReportCountAggregateInputType = {
    id?: true
    type?: true
    format?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    downloadUrl?: true
    metadata?: true
    _all?: true
  }

  export type ReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Report to aggregate.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reports
    **/
    _count?: true | ReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportMaxAggregateInputType
  }

  export type GetReportAggregateType<T extends ReportAggregateArgs> = {
        [P in keyof T & keyof AggregateReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport[P]>
      : GetScalarType<T[P], AggregateReport[P]>
  }




  export type ReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithAggregationInput | ReportOrderByWithAggregationInput[]
    by: ReportScalarFieldEnum[] | ReportScalarFieldEnum
    having?: ReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportCountAggregateInputType | true
    _min?: ReportMinAggregateInputType
    _max?: ReportMaxAggregateInputType
  }

  export type ReportGroupByOutputType = {
    id: string
    type: string
    format: string
    status: string
    createdAt: Date
    updatedAt: Date
    createdBy: string
    downloadUrl: string | null
    metadata: JsonValue | null
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  type GetReportGroupByPayload<T extends ReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportGroupByOutputType[P]>
            : GetScalarType<T[P], ReportGroupByOutputType[P]>
        }
      >
    >


  export type ReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    format?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    downloadUrl?: boolean
    metadata?: boolean
  }, ExtArgs["result"]["report"]>

  export type ReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    format?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    downloadUrl?: boolean
    metadata?: boolean
  }, ExtArgs["result"]["report"]>

  export type ReportSelectScalar = {
    id?: boolean
    type?: boolean
    format?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    downloadUrl?: boolean
    metadata?: boolean
  }


  export type $ReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Report"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      format: string
      status: string
      createdAt: Date
      updatedAt: Date
      createdBy: string
      downloadUrl: string | null
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["report"]>
    composites: {}
  }

  type ReportGetPayload<S extends boolean | null | undefined | ReportDefaultArgs> = $Result.GetResult<Prisma.$ReportPayload, S>

  type ReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReportCountAggregateInputType | true
    }

  export interface ReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Report'], meta: { name: 'Report' } }
    /**
     * Find zero or one Report that matches the filter.
     * @param {ReportFindUniqueArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportFindUniqueArgs>(args: SelectSubset<T, ReportFindUniqueArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Report that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReportFindUniqueOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportFindFirstArgs>(args?: SelectSubset<T, ReportFindFirstArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Report that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.report.findMany()
     * 
     * // Get first 10 Reports
     * const reports = await prisma.report.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportWithIdOnly = await prisma.report.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportFindManyArgs>(args?: SelectSubset<T, ReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Report.
     * @param {ReportCreateArgs} args - Arguments to create a Report.
     * @example
     * // Create one Report
     * const Report = await prisma.report.create({
     *   data: {
     *     // ... data to create a Report
     *   }
     * })
     * 
     */
    create<T extends ReportCreateArgs>(args: SelectSubset<T, ReportCreateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Reports.
     * @param {ReportCreateManyArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportCreateManyArgs>(args?: SelectSubset<T, ReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reports and returns the data saved in the database.
     * @param {ReportCreateManyAndReturnArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reports and only return the `id`
     * const reportWithIdOnly = await prisma.report.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Report.
     * @param {ReportDeleteArgs} args - Arguments to delete one Report.
     * @example
     * // Delete one Report
     * const Report = await prisma.report.delete({
     *   where: {
     *     // ... filter to delete one Report
     *   }
     * })
     * 
     */
    delete<T extends ReportDeleteArgs>(args: SelectSubset<T, ReportDeleteArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Report.
     * @param {ReportUpdateArgs} args - Arguments to update one Report.
     * @example
     * // Update one Report
     * const report = await prisma.report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportUpdateArgs>(args: SelectSubset<T, ReportUpdateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Reports.
     * @param {ReportDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportDeleteManyArgs>(args?: SelectSubset<T, ReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportUpdateManyArgs>(args: SelectSubset<T, ReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Report.
     * @param {ReportUpsertArgs} args - Arguments to update or create a Report.
     * @example
     * // Update or create a Report
     * const report = await prisma.report.upsert({
     *   create: {
     *     // ... data to create a Report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report we want to update
     *   }
     * })
     */
    upsert<T extends ReportUpsertArgs>(args: SelectSubset<T, ReportUpsertArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.report.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
    **/
    count<T extends ReportCountArgs>(
      args?: Subset<T, ReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportAggregateArgs>(args: Subset<T, ReportAggregateArgs>): Prisma.PrismaPromise<GetReportAggregateType<T>>

    /**
     * Group by Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportGroupByArgs['orderBy'] }
        : { orderBy?: ReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Report model
   */
  readonly fields: ReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Report model
   */ 
  interface ReportFieldRefs {
    readonly id: FieldRef<"Report", 'String'>
    readonly type: FieldRef<"Report", 'String'>
    readonly format: FieldRef<"Report", 'String'>
    readonly status: FieldRef<"Report", 'String'>
    readonly createdAt: FieldRef<"Report", 'DateTime'>
    readonly updatedAt: FieldRef<"Report", 'DateTime'>
    readonly createdBy: FieldRef<"Report", 'String'>
    readonly downloadUrl: FieldRef<"Report", 'String'>
    readonly metadata: FieldRef<"Report", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Report findUnique
   */
  export type ReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findUniqueOrThrow
   */
  export type ReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findFirst
   */
  export type ReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findFirstOrThrow
   */
  export type ReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findMany
   */
  export type ReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Filter, which Reports to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report create
   */
  export type ReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * The data needed to create a Report.
     */
    data: XOR<ReportCreateInput, ReportUncheckedCreateInput>
  }

  /**
   * Report createMany
   */
  export type ReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Report createManyAndReturn
   */
  export type ReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Report update
   */
  export type ReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * The data needed to update a Report.
     */
    data: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
    /**
     * Choose, which Report to update.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report updateMany
   */
  export type ReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
  }

  /**
   * Report upsert
   */
  export type ReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * The filter to search for the Report to update in case it exists.
     */
    where: ReportWhereUniqueInput
    /**
     * In case the Report found by the `where` argument doesn't exist, create a new Report with this data.
     */
    create: XOR<ReportCreateInput, ReportUncheckedCreateInput>
    /**
     * In case the Report was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
  }

  /**
   * Report delete
   */
  export type ReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Filter which Report to delete.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report deleteMany
   */
  export type ReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reports to delete
     */
    where?: ReportWhereInput
  }

  /**
   * Report without action
   */
  export type ReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
  }


  /**
   * Model Metric
   */

  export type AggregateMetric = {
    _count: MetricCountAggregateOutputType | null
    _avg: MetricAvgAggregateOutputType | null
    _sum: MetricSumAggregateOutputType | null
    _min: MetricMinAggregateOutputType | null
    _max: MetricMaxAggregateOutputType | null
  }

  export type MetricAvgAggregateOutputType = {
    value: number | null
  }

  export type MetricSumAggregateOutputType = {
    value: number | null
  }

  export type MetricMinAggregateOutputType = {
    id: string | null
    name: string | null
    value: number | null
    timestamp: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MetricMaxAggregateOutputType = {
    id: string | null
    name: string | null
    value: number | null
    timestamp: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MetricCountAggregateOutputType = {
    id: number
    name: number
    value: number
    tags: number
    timestamp: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MetricAvgAggregateInputType = {
    value?: true
  }

  export type MetricSumAggregateInputType = {
    value?: true
  }

  export type MetricMinAggregateInputType = {
    id?: true
    name?: true
    value?: true
    timestamp?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MetricMaxAggregateInputType = {
    id?: true
    name?: true
    value?: true
    timestamp?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MetricCountAggregateInputType = {
    id?: true
    name?: true
    value?: true
    tags?: true
    timestamp?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MetricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Metric to aggregate.
     */
    where?: MetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Metrics to fetch.
     */
    orderBy?: MetricOrderByWithRelationInput | MetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Metrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Metrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Metrics
    **/
    _count?: true | MetricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MetricAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MetricSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MetricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MetricMaxAggregateInputType
  }

  export type GetMetricAggregateType<T extends MetricAggregateArgs> = {
        [P in keyof T & keyof AggregateMetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMetric[P]>
      : GetScalarType<T[P], AggregateMetric[P]>
  }




  export type MetricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MetricWhereInput
    orderBy?: MetricOrderByWithAggregationInput | MetricOrderByWithAggregationInput[]
    by: MetricScalarFieldEnum[] | MetricScalarFieldEnum
    having?: MetricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MetricCountAggregateInputType | true
    _avg?: MetricAvgAggregateInputType
    _sum?: MetricSumAggregateInputType
    _min?: MetricMinAggregateInputType
    _max?: MetricMaxAggregateInputType
  }

  export type MetricGroupByOutputType = {
    id: string
    name: string
    value: number
    tags: JsonValue | null
    timestamp: Date
    createdAt: Date
    updatedAt: Date
    _count: MetricCountAggregateOutputType | null
    _avg: MetricAvgAggregateOutputType | null
    _sum: MetricSumAggregateOutputType | null
    _min: MetricMinAggregateOutputType | null
    _max: MetricMaxAggregateOutputType | null
  }

  type GetMetricGroupByPayload<T extends MetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MetricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MetricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MetricGroupByOutputType[P]>
            : GetScalarType<T[P], MetricGroupByOutputType[P]>
        }
      >
    >


  export type MetricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    value?: boolean
    tags?: boolean
    timestamp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["metric"]>

  export type MetricSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    value?: boolean
    tags?: boolean
    timestamp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["metric"]>

  export type MetricSelectScalar = {
    id?: boolean
    name?: boolean
    value?: boolean
    tags?: boolean
    timestamp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $MetricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Metric"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      value: number
      tags: Prisma.JsonValue | null
      timestamp: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["metric"]>
    composites: {}
  }

  type MetricGetPayload<S extends boolean | null | undefined | MetricDefaultArgs> = $Result.GetResult<Prisma.$MetricPayload, S>

  type MetricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MetricFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MetricCountAggregateInputType | true
    }

  export interface MetricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Metric'], meta: { name: 'Metric' } }
    /**
     * Find zero or one Metric that matches the filter.
     * @param {MetricFindUniqueArgs} args - Arguments to find a Metric
     * @example
     * // Get one Metric
     * const metric = await prisma.metric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MetricFindUniqueArgs>(args: SelectSubset<T, MetricFindUniqueArgs<ExtArgs>>): Prisma__MetricClient<$Result.GetResult<Prisma.$MetricPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Metric that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MetricFindUniqueOrThrowArgs} args - Arguments to find a Metric
     * @example
     * // Get one Metric
     * const metric = await prisma.metric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MetricFindUniqueOrThrowArgs>(args: SelectSubset<T, MetricFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MetricClient<$Result.GetResult<Prisma.$MetricPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Metric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricFindFirstArgs} args - Arguments to find a Metric
     * @example
     * // Get one Metric
     * const metric = await prisma.metric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MetricFindFirstArgs>(args?: SelectSubset<T, MetricFindFirstArgs<ExtArgs>>): Prisma__MetricClient<$Result.GetResult<Prisma.$MetricPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Metric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricFindFirstOrThrowArgs} args - Arguments to find a Metric
     * @example
     * // Get one Metric
     * const metric = await prisma.metric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MetricFindFirstOrThrowArgs>(args?: SelectSubset<T, MetricFindFirstOrThrowArgs<ExtArgs>>): Prisma__MetricClient<$Result.GetResult<Prisma.$MetricPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Metrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Metrics
     * const metrics = await prisma.metric.findMany()
     * 
     * // Get first 10 Metrics
     * const metrics = await prisma.metric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const metricWithIdOnly = await prisma.metric.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MetricFindManyArgs>(args?: SelectSubset<T, MetricFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MetricPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Metric.
     * @param {MetricCreateArgs} args - Arguments to create a Metric.
     * @example
     * // Create one Metric
     * const Metric = await prisma.metric.create({
     *   data: {
     *     // ... data to create a Metric
     *   }
     * })
     * 
     */
    create<T extends MetricCreateArgs>(args: SelectSubset<T, MetricCreateArgs<ExtArgs>>): Prisma__MetricClient<$Result.GetResult<Prisma.$MetricPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Metrics.
     * @param {MetricCreateManyArgs} args - Arguments to create many Metrics.
     * @example
     * // Create many Metrics
     * const metric = await prisma.metric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MetricCreateManyArgs>(args?: SelectSubset<T, MetricCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Metrics and returns the data saved in the database.
     * @param {MetricCreateManyAndReturnArgs} args - Arguments to create many Metrics.
     * @example
     * // Create many Metrics
     * const metric = await prisma.metric.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Metrics and only return the `id`
     * const metricWithIdOnly = await prisma.metric.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MetricCreateManyAndReturnArgs>(args?: SelectSubset<T, MetricCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MetricPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Metric.
     * @param {MetricDeleteArgs} args - Arguments to delete one Metric.
     * @example
     * // Delete one Metric
     * const Metric = await prisma.metric.delete({
     *   where: {
     *     // ... filter to delete one Metric
     *   }
     * })
     * 
     */
    delete<T extends MetricDeleteArgs>(args: SelectSubset<T, MetricDeleteArgs<ExtArgs>>): Prisma__MetricClient<$Result.GetResult<Prisma.$MetricPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Metric.
     * @param {MetricUpdateArgs} args - Arguments to update one Metric.
     * @example
     * // Update one Metric
     * const metric = await prisma.metric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MetricUpdateArgs>(args: SelectSubset<T, MetricUpdateArgs<ExtArgs>>): Prisma__MetricClient<$Result.GetResult<Prisma.$MetricPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Metrics.
     * @param {MetricDeleteManyArgs} args - Arguments to filter Metrics to delete.
     * @example
     * // Delete a few Metrics
     * const { count } = await prisma.metric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MetricDeleteManyArgs>(args?: SelectSubset<T, MetricDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Metrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Metrics
     * const metric = await prisma.metric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MetricUpdateManyArgs>(args: SelectSubset<T, MetricUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Metric.
     * @param {MetricUpsertArgs} args - Arguments to update or create a Metric.
     * @example
     * // Update or create a Metric
     * const metric = await prisma.metric.upsert({
     *   create: {
     *     // ... data to create a Metric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Metric we want to update
     *   }
     * })
     */
    upsert<T extends MetricUpsertArgs>(args: SelectSubset<T, MetricUpsertArgs<ExtArgs>>): Prisma__MetricClient<$Result.GetResult<Prisma.$MetricPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Metrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricCountArgs} args - Arguments to filter Metrics to count.
     * @example
     * // Count the number of Metrics
     * const count = await prisma.metric.count({
     *   where: {
     *     // ... the filter for the Metrics we want to count
     *   }
     * })
    **/
    count<T extends MetricCountArgs>(
      args?: Subset<T, MetricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MetricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Metric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MetricAggregateArgs>(args: Subset<T, MetricAggregateArgs>): Prisma.PrismaPromise<GetMetricAggregateType<T>>

    /**
     * Group by Metric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MetricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MetricGroupByArgs['orderBy'] }
        : { orderBy?: MetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MetricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMetricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Metric model
   */
  readonly fields: MetricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Metric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MetricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Metric model
   */ 
  interface MetricFieldRefs {
    readonly id: FieldRef<"Metric", 'String'>
    readonly name: FieldRef<"Metric", 'String'>
    readonly value: FieldRef<"Metric", 'Float'>
    readonly tags: FieldRef<"Metric", 'Json'>
    readonly timestamp: FieldRef<"Metric", 'DateTime'>
    readonly createdAt: FieldRef<"Metric", 'DateTime'>
    readonly updatedAt: FieldRef<"Metric", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Metric findUnique
   */
  export type MetricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Filter, which Metric to fetch.
     */
    where: MetricWhereUniqueInput
  }

  /**
   * Metric findUniqueOrThrow
   */
  export type MetricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Filter, which Metric to fetch.
     */
    where: MetricWhereUniqueInput
  }

  /**
   * Metric findFirst
   */
  export type MetricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Filter, which Metric to fetch.
     */
    where?: MetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Metrics to fetch.
     */
    orderBy?: MetricOrderByWithRelationInput | MetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Metrics.
     */
    cursor?: MetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Metrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Metrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Metrics.
     */
    distinct?: MetricScalarFieldEnum | MetricScalarFieldEnum[]
  }

  /**
   * Metric findFirstOrThrow
   */
  export type MetricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Filter, which Metric to fetch.
     */
    where?: MetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Metrics to fetch.
     */
    orderBy?: MetricOrderByWithRelationInput | MetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Metrics.
     */
    cursor?: MetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Metrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Metrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Metrics.
     */
    distinct?: MetricScalarFieldEnum | MetricScalarFieldEnum[]
  }

  /**
   * Metric findMany
   */
  export type MetricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Filter, which Metrics to fetch.
     */
    where?: MetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Metrics to fetch.
     */
    orderBy?: MetricOrderByWithRelationInput | MetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Metrics.
     */
    cursor?: MetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Metrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Metrics.
     */
    skip?: number
    distinct?: MetricScalarFieldEnum | MetricScalarFieldEnum[]
  }

  /**
   * Metric create
   */
  export type MetricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * The data needed to create a Metric.
     */
    data: XOR<MetricCreateInput, MetricUncheckedCreateInput>
  }

  /**
   * Metric createMany
   */
  export type MetricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Metrics.
     */
    data: MetricCreateManyInput | MetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Metric createManyAndReturn
   */
  export type MetricCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Metrics.
     */
    data: MetricCreateManyInput | MetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Metric update
   */
  export type MetricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * The data needed to update a Metric.
     */
    data: XOR<MetricUpdateInput, MetricUncheckedUpdateInput>
    /**
     * Choose, which Metric to update.
     */
    where: MetricWhereUniqueInput
  }

  /**
   * Metric updateMany
   */
  export type MetricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Metrics.
     */
    data: XOR<MetricUpdateManyMutationInput, MetricUncheckedUpdateManyInput>
    /**
     * Filter which Metrics to update
     */
    where?: MetricWhereInput
  }

  /**
   * Metric upsert
   */
  export type MetricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * The filter to search for the Metric to update in case it exists.
     */
    where: MetricWhereUniqueInput
    /**
     * In case the Metric found by the `where` argument doesn't exist, create a new Metric with this data.
     */
    create: XOR<MetricCreateInput, MetricUncheckedCreateInput>
    /**
     * In case the Metric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MetricUpdateInput, MetricUncheckedUpdateInput>
  }

  /**
   * Metric delete
   */
  export type MetricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Filter which Metric to delete.
     */
    where: MetricWhereUniqueInput
  }

  /**
   * Metric deleteMany
   */
  export type MetricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Metrics to delete
     */
    where?: MetricWhereInput
  }

  /**
   * Metric without action
   */
  export type MetricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
  }


  /**
   * Model EmailNotification
   */

  export type AggregateEmailNotification = {
    _count: EmailNotificationCountAggregateOutputType | null
    _min: EmailNotificationMinAggregateOutputType | null
    _max: EmailNotificationMaxAggregateOutputType | null
  }

  export type EmailNotificationMinAggregateOutputType = {
    id: string | null
    type: string | null
    status: string | null
    to: string | null
    subject: string | null
    body: string | null
    sentAt: Date | null
    createdAt: Date | null
  }

  export type EmailNotificationMaxAggregateOutputType = {
    id: string | null
    type: string | null
    status: string | null
    to: string | null
    subject: string | null
    body: string | null
    sentAt: Date | null
    createdAt: Date | null
  }

  export type EmailNotificationCountAggregateOutputType = {
    id: number
    type: number
    status: number
    to: number
    subject: number
    body: number
    sentAt: number
    createdAt: number
    metadata: number
    _all: number
  }


  export type EmailNotificationMinAggregateInputType = {
    id?: true
    type?: true
    status?: true
    to?: true
    subject?: true
    body?: true
    sentAt?: true
    createdAt?: true
  }

  export type EmailNotificationMaxAggregateInputType = {
    id?: true
    type?: true
    status?: true
    to?: true
    subject?: true
    body?: true
    sentAt?: true
    createdAt?: true
  }

  export type EmailNotificationCountAggregateInputType = {
    id?: true
    type?: true
    status?: true
    to?: true
    subject?: true
    body?: true
    sentAt?: true
    createdAt?: true
    metadata?: true
    _all?: true
  }

  export type EmailNotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailNotification to aggregate.
     */
    where?: EmailNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailNotifications to fetch.
     */
    orderBy?: EmailNotificationOrderByWithRelationInput | EmailNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailNotifications
    **/
    _count?: true | EmailNotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailNotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailNotificationMaxAggregateInputType
  }

  export type GetEmailNotificationAggregateType<T extends EmailNotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailNotification[P]>
      : GetScalarType<T[P], AggregateEmailNotification[P]>
  }




  export type EmailNotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailNotificationWhereInput
    orderBy?: EmailNotificationOrderByWithAggregationInput | EmailNotificationOrderByWithAggregationInput[]
    by: EmailNotificationScalarFieldEnum[] | EmailNotificationScalarFieldEnum
    having?: EmailNotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailNotificationCountAggregateInputType | true
    _min?: EmailNotificationMinAggregateInputType
    _max?: EmailNotificationMaxAggregateInputType
  }

  export type EmailNotificationGroupByOutputType = {
    id: string
    type: string
    status: string
    to: string
    subject: string
    body: string
    sentAt: Date | null
    createdAt: Date
    metadata: JsonValue | null
    _count: EmailNotificationCountAggregateOutputType | null
    _min: EmailNotificationMinAggregateOutputType | null
    _max: EmailNotificationMaxAggregateOutputType | null
  }

  type GetEmailNotificationGroupByPayload<T extends EmailNotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailNotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailNotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailNotificationGroupByOutputType[P]>
            : GetScalarType<T[P], EmailNotificationGroupByOutputType[P]>
        }
      >
    >


  export type EmailNotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    status?: boolean
    to?: boolean
    subject?: boolean
    body?: boolean
    sentAt?: boolean
    createdAt?: boolean
    metadata?: boolean
  }, ExtArgs["result"]["emailNotification"]>

  export type EmailNotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    status?: boolean
    to?: boolean
    subject?: boolean
    body?: boolean
    sentAt?: boolean
    createdAt?: boolean
    metadata?: boolean
  }, ExtArgs["result"]["emailNotification"]>

  export type EmailNotificationSelectScalar = {
    id?: boolean
    type?: boolean
    status?: boolean
    to?: boolean
    subject?: boolean
    body?: boolean
    sentAt?: boolean
    createdAt?: boolean
    metadata?: boolean
  }


  export type $EmailNotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailNotification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      status: string
      to: string
      subject: string
      body: string
      sentAt: Date | null
      createdAt: Date
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["emailNotification"]>
    composites: {}
  }

  type EmailNotificationGetPayload<S extends boolean | null | undefined | EmailNotificationDefaultArgs> = $Result.GetResult<Prisma.$EmailNotificationPayload, S>

  type EmailNotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmailNotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmailNotificationCountAggregateInputType | true
    }

  export interface EmailNotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailNotification'], meta: { name: 'EmailNotification' } }
    /**
     * Find zero or one EmailNotification that matches the filter.
     * @param {EmailNotificationFindUniqueArgs} args - Arguments to find a EmailNotification
     * @example
     * // Get one EmailNotification
     * const emailNotification = await prisma.emailNotification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailNotificationFindUniqueArgs>(args: SelectSubset<T, EmailNotificationFindUniqueArgs<ExtArgs>>): Prisma__EmailNotificationClient<$Result.GetResult<Prisma.$EmailNotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmailNotification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmailNotificationFindUniqueOrThrowArgs} args - Arguments to find a EmailNotification
     * @example
     * // Get one EmailNotification
     * const emailNotification = await prisma.emailNotification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailNotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailNotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailNotificationClient<$Result.GetResult<Prisma.$EmailNotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmailNotification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailNotificationFindFirstArgs} args - Arguments to find a EmailNotification
     * @example
     * // Get one EmailNotification
     * const emailNotification = await prisma.emailNotification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailNotificationFindFirstArgs>(args?: SelectSubset<T, EmailNotificationFindFirstArgs<ExtArgs>>): Prisma__EmailNotificationClient<$Result.GetResult<Prisma.$EmailNotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmailNotification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailNotificationFindFirstOrThrowArgs} args - Arguments to find a EmailNotification
     * @example
     * // Get one EmailNotification
     * const emailNotification = await prisma.emailNotification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailNotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailNotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailNotificationClient<$Result.GetResult<Prisma.$EmailNotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmailNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailNotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailNotifications
     * const emailNotifications = await prisma.emailNotification.findMany()
     * 
     * // Get first 10 EmailNotifications
     * const emailNotifications = await prisma.emailNotification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailNotificationWithIdOnly = await prisma.emailNotification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailNotificationFindManyArgs>(args?: SelectSubset<T, EmailNotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailNotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmailNotification.
     * @param {EmailNotificationCreateArgs} args - Arguments to create a EmailNotification.
     * @example
     * // Create one EmailNotification
     * const EmailNotification = await prisma.emailNotification.create({
     *   data: {
     *     // ... data to create a EmailNotification
     *   }
     * })
     * 
     */
    create<T extends EmailNotificationCreateArgs>(args: SelectSubset<T, EmailNotificationCreateArgs<ExtArgs>>): Prisma__EmailNotificationClient<$Result.GetResult<Prisma.$EmailNotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmailNotifications.
     * @param {EmailNotificationCreateManyArgs} args - Arguments to create many EmailNotifications.
     * @example
     * // Create many EmailNotifications
     * const emailNotification = await prisma.emailNotification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailNotificationCreateManyArgs>(args?: SelectSubset<T, EmailNotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailNotifications and returns the data saved in the database.
     * @param {EmailNotificationCreateManyAndReturnArgs} args - Arguments to create many EmailNotifications.
     * @example
     * // Create many EmailNotifications
     * const emailNotification = await prisma.emailNotification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailNotifications and only return the `id`
     * const emailNotificationWithIdOnly = await prisma.emailNotification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailNotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailNotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailNotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EmailNotification.
     * @param {EmailNotificationDeleteArgs} args - Arguments to delete one EmailNotification.
     * @example
     * // Delete one EmailNotification
     * const EmailNotification = await prisma.emailNotification.delete({
     *   where: {
     *     // ... filter to delete one EmailNotification
     *   }
     * })
     * 
     */
    delete<T extends EmailNotificationDeleteArgs>(args: SelectSubset<T, EmailNotificationDeleteArgs<ExtArgs>>): Prisma__EmailNotificationClient<$Result.GetResult<Prisma.$EmailNotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmailNotification.
     * @param {EmailNotificationUpdateArgs} args - Arguments to update one EmailNotification.
     * @example
     * // Update one EmailNotification
     * const emailNotification = await prisma.emailNotification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailNotificationUpdateArgs>(args: SelectSubset<T, EmailNotificationUpdateArgs<ExtArgs>>): Prisma__EmailNotificationClient<$Result.GetResult<Prisma.$EmailNotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmailNotifications.
     * @param {EmailNotificationDeleteManyArgs} args - Arguments to filter EmailNotifications to delete.
     * @example
     * // Delete a few EmailNotifications
     * const { count } = await prisma.emailNotification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailNotificationDeleteManyArgs>(args?: SelectSubset<T, EmailNotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailNotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailNotifications
     * const emailNotification = await prisma.emailNotification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailNotificationUpdateManyArgs>(args: SelectSubset<T, EmailNotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmailNotification.
     * @param {EmailNotificationUpsertArgs} args - Arguments to update or create a EmailNotification.
     * @example
     * // Update or create a EmailNotification
     * const emailNotification = await prisma.emailNotification.upsert({
     *   create: {
     *     // ... data to create a EmailNotification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailNotification we want to update
     *   }
     * })
     */
    upsert<T extends EmailNotificationUpsertArgs>(args: SelectSubset<T, EmailNotificationUpsertArgs<ExtArgs>>): Prisma__EmailNotificationClient<$Result.GetResult<Prisma.$EmailNotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EmailNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailNotificationCountArgs} args - Arguments to filter EmailNotifications to count.
     * @example
     * // Count the number of EmailNotifications
     * const count = await prisma.emailNotification.count({
     *   where: {
     *     // ... the filter for the EmailNotifications we want to count
     *   }
     * })
    **/
    count<T extends EmailNotificationCountArgs>(
      args?: Subset<T, EmailNotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailNotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailNotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailNotificationAggregateArgs>(args: Subset<T, EmailNotificationAggregateArgs>): Prisma.PrismaPromise<GetEmailNotificationAggregateType<T>>

    /**
     * Group by EmailNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailNotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailNotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailNotificationGroupByArgs['orderBy'] }
        : { orderBy?: EmailNotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailNotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailNotification model
   */
  readonly fields: EmailNotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailNotification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailNotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailNotification model
   */ 
  interface EmailNotificationFieldRefs {
    readonly id: FieldRef<"EmailNotification", 'String'>
    readonly type: FieldRef<"EmailNotification", 'String'>
    readonly status: FieldRef<"EmailNotification", 'String'>
    readonly to: FieldRef<"EmailNotification", 'String'>
    readonly subject: FieldRef<"EmailNotification", 'String'>
    readonly body: FieldRef<"EmailNotification", 'String'>
    readonly sentAt: FieldRef<"EmailNotification", 'DateTime'>
    readonly createdAt: FieldRef<"EmailNotification", 'DateTime'>
    readonly metadata: FieldRef<"EmailNotification", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * EmailNotification findUnique
   */
  export type EmailNotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailNotification
     */
    select?: EmailNotificationSelect<ExtArgs> | null
    /**
     * Filter, which EmailNotification to fetch.
     */
    where: EmailNotificationWhereUniqueInput
  }

  /**
   * EmailNotification findUniqueOrThrow
   */
  export type EmailNotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailNotification
     */
    select?: EmailNotificationSelect<ExtArgs> | null
    /**
     * Filter, which EmailNotification to fetch.
     */
    where: EmailNotificationWhereUniqueInput
  }

  /**
   * EmailNotification findFirst
   */
  export type EmailNotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailNotification
     */
    select?: EmailNotificationSelect<ExtArgs> | null
    /**
     * Filter, which EmailNotification to fetch.
     */
    where?: EmailNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailNotifications to fetch.
     */
    orderBy?: EmailNotificationOrderByWithRelationInput | EmailNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailNotifications.
     */
    cursor?: EmailNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailNotifications.
     */
    distinct?: EmailNotificationScalarFieldEnum | EmailNotificationScalarFieldEnum[]
  }

  /**
   * EmailNotification findFirstOrThrow
   */
  export type EmailNotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailNotification
     */
    select?: EmailNotificationSelect<ExtArgs> | null
    /**
     * Filter, which EmailNotification to fetch.
     */
    where?: EmailNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailNotifications to fetch.
     */
    orderBy?: EmailNotificationOrderByWithRelationInput | EmailNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailNotifications.
     */
    cursor?: EmailNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailNotifications.
     */
    distinct?: EmailNotificationScalarFieldEnum | EmailNotificationScalarFieldEnum[]
  }

  /**
   * EmailNotification findMany
   */
  export type EmailNotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailNotification
     */
    select?: EmailNotificationSelect<ExtArgs> | null
    /**
     * Filter, which EmailNotifications to fetch.
     */
    where?: EmailNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailNotifications to fetch.
     */
    orderBy?: EmailNotificationOrderByWithRelationInput | EmailNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailNotifications.
     */
    cursor?: EmailNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailNotifications.
     */
    skip?: number
    distinct?: EmailNotificationScalarFieldEnum | EmailNotificationScalarFieldEnum[]
  }

  /**
   * EmailNotification create
   */
  export type EmailNotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailNotification
     */
    select?: EmailNotificationSelect<ExtArgs> | null
    /**
     * The data needed to create a EmailNotification.
     */
    data: XOR<EmailNotificationCreateInput, EmailNotificationUncheckedCreateInput>
  }

  /**
   * EmailNotification createMany
   */
  export type EmailNotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailNotifications.
     */
    data: EmailNotificationCreateManyInput | EmailNotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailNotification createManyAndReturn
   */
  export type EmailNotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailNotification
     */
    select?: EmailNotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EmailNotifications.
     */
    data: EmailNotificationCreateManyInput | EmailNotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailNotification update
   */
  export type EmailNotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailNotification
     */
    select?: EmailNotificationSelect<ExtArgs> | null
    /**
     * The data needed to update a EmailNotification.
     */
    data: XOR<EmailNotificationUpdateInput, EmailNotificationUncheckedUpdateInput>
    /**
     * Choose, which EmailNotification to update.
     */
    where: EmailNotificationWhereUniqueInput
  }

  /**
   * EmailNotification updateMany
   */
  export type EmailNotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailNotifications.
     */
    data: XOR<EmailNotificationUpdateManyMutationInput, EmailNotificationUncheckedUpdateManyInput>
    /**
     * Filter which EmailNotifications to update
     */
    where?: EmailNotificationWhereInput
  }

  /**
   * EmailNotification upsert
   */
  export type EmailNotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailNotification
     */
    select?: EmailNotificationSelect<ExtArgs> | null
    /**
     * The filter to search for the EmailNotification to update in case it exists.
     */
    where: EmailNotificationWhereUniqueInput
    /**
     * In case the EmailNotification found by the `where` argument doesn't exist, create a new EmailNotification with this data.
     */
    create: XOR<EmailNotificationCreateInput, EmailNotificationUncheckedCreateInput>
    /**
     * In case the EmailNotification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailNotificationUpdateInput, EmailNotificationUncheckedUpdateInput>
  }

  /**
   * EmailNotification delete
   */
  export type EmailNotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailNotification
     */
    select?: EmailNotificationSelect<ExtArgs> | null
    /**
     * Filter which EmailNotification to delete.
     */
    where: EmailNotificationWhereUniqueInput
  }

  /**
   * EmailNotification deleteMany
   */
  export type EmailNotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailNotifications to delete
     */
    where?: EmailNotificationWhereInput
  }

  /**
   * EmailNotification without action
   */
  export type EmailNotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailNotification
     */
    select?: EmailNotificationSelect<ExtArgs> | null
  }


  /**
   * Model Webhook
   */

  export type AggregateWebhook = {
    _count: WebhookCountAggregateOutputType | null
    _min: WebhookMinAggregateOutputType | null
    _max: WebhookMaxAggregateOutputType | null
  }

  export type WebhookMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    url: string | null
    secret: string | null
    status: string | null
    lastSuccess: Date | null
    lastFailure: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WebhookMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    url: string | null
    secret: string | null
    status: string | null
    lastSuccess: Date | null
    lastFailure: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WebhookCountAggregateOutputType = {
    id: number
    organizationId: number
    url: number
    secret: number
    events: number
    status: number
    retryConfig: number
    lastSuccess: number
    lastFailure: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WebhookMinAggregateInputType = {
    id?: true
    organizationId?: true
    url?: true
    secret?: true
    status?: true
    lastSuccess?: true
    lastFailure?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WebhookMaxAggregateInputType = {
    id?: true
    organizationId?: true
    url?: true
    secret?: true
    status?: true
    lastSuccess?: true
    lastFailure?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WebhookCountAggregateInputType = {
    id?: true
    organizationId?: true
    url?: true
    secret?: true
    events?: true
    status?: true
    retryConfig?: true
    lastSuccess?: true
    lastFailure?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WebhookAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Webhook to aggregate.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Webhooks
    **/
    _count?: true | WebhookCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebhookMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebhookMaxAggregateInputType
  }

  export type GetWebhookAggregateType<T extends WebhookAggregateArgs> = {
        [P in keyof T & keyof AggregateWebhook]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebhook[P]>
      : GetScalarType<T[P], AggregateWebhook[P]>
  }




  export type WebhookGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookWhereInput
    orderBy?: WebhookOrderByWithAggregationInput | WebhookOrderByWithAggregationInput[]
    by: WebhookScalarFieldEnum[] | WebhookScalarFieldEnum
    having?: WebhookScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebhookCountAggregateInputType | true
    _min?: WebhookMinAggregateInputType
    _max?: WebhookMaxAggregateInputType
  }

  export type WebhookGroupByOutputType = {
    id: string
    organizationId: string
    url: string
    secret: string
    events: string[]
    status: string
    retryConfig: JsonValue
    lastSuccess: Date | null
    lastFailure: Date | null
    createdAt: Date
    updatedAt: Date
    _count: WebhookCountAggregateOutputType | null
    _min: WebhookMinAggregateOutputType | null
    _max: WebhookMaxAggregateOutputType | null
  }

  type GetWebhookGroupByPayload<T extends WebhookGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebhookGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebhookGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebhookGroupByOutputType[P]>
            : GetScalarType<T[P], WebhookGroupByOutputType[P]>
        }
      >
    >


  export type WebhookSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    url?: boolean
    secret?: boolean
    events?: boolean
    status?: boolean
    retryConfig?: boolean
    lastSuccess?: boolean
    lastFailure?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    deliveries?: boolean | Webhook$deliveriesArgs<ExtArgs>
    _count?: boolean | WebhookCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webhook"]>

  export type WebhookSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    url?: boolean
    secret?: boolean
    events?: boolean
    status?: boolean
    retryConfig?: boolean
    lastSuccess?: boolean
    lastFailure?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webhook"]>

  export type WebhookSelectScalar = {
    id?: boolean
    organizationId?: boolean
    url?: boolean
    secret?: boolean
    events?: boolean
    status?: boolean
    retryConfig?: boolean
    lastSuccess?: boolean
    lastFailure?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WebhookInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    deliveries?: boolean | Webhook$deliveriesArgs<ExtArgs>
    _count?: boolean | WebhookCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WebhookIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $WebhookPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Webhook"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      deliveries: Prisma.$WebhookDeliveryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string
      url: string
      secret: string
      events: string[]
      status: string
      retryConfig: Prisma.JsonValue
      lastSuccess: Date | null
      lastFailure: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["webhook"]>
    composites: {}
  }

  type WebhookGetPayload<S extends boolean | null | undefined | WebhookDefaultArgs> = $Result.GetResult<Prisma.$WebhookPayload, S>

  type WebhookCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WebhookFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WebhookCountAggregateInputType | true
    }

  export interface WebhookDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Webhook'], meta: { name: 'Webhook' } }
    /**
     * Find zero or one Webhook that matches the filter.
     * @param {WebhookFindUniqueArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebhookFindUniqueArgs>(args: SelectSubset<T, WebhookFindUniqueArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Webhook that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WebhookFindUniqueOrThrowArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebhookFindUniqueOrThrowArgs>(args: SelectSubset<T, WebhookFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Webhook that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookFindFirstArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebhookFindFirstArgs>(args?: SelectSubset<T, WebhookFindFirstArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Webhook that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookFindFirstOrThrowArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebhookFindFirstOrThrowArgs>(args?: SelectSubset<T, WebhookFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Webhooks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Webhooks
     * const webhooks = await prisma.webhook.findMany()
     * 
     * // Get first 10 Webhooks
     * const webhooks = await prisma.webhook.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webhookWithIdOnly = await prisma.webhook.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WebhookFindManyArgs>(args?: SelectSubset<T, WebhookFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Webhook.
     * @param {WebhookCreateArgs} args - Arguments to create a Webhook.
     * @example
     * // Create one Webhook
     * const Webhook = await prisma.webhook.create({
     *   data: {
     *     // ... data to create a Webhook
     *   }
     * })
     * 
     */
    create<T extends WebhookCreateArgs>(args: SelectSubset<T, WebhookCreateArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Webhooks.
     * @param {WebhookCreateManyArgs} args - Arguments to create many Webhooks.
     * @example
     * // Create many Webhooks
     * const webhook = await prisma.webhook.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebhookCreateManyArgs>(args?: SelectSubset<T, WebhookCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Webhooks and returns the data saved in the database.
     * @param {WebhookCreateManyAndReturnArgs} args - Arguments to create many Webhooks.
     * @example
     * // Create many Webhooks
     * const webhook = await prisma.webhook.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Webhooks and only return the `id`
     * const webhookWithIdOnly = await prisma.webhook.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WebhookCreateManyAndReturnArgs>(args?: SelectSubset<T, WebhookCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Webhook.
     * @param {WebhookDeleteArgs} args - Arguments to delete one Webhook.
     * @example
     * // Delete one Webhook
     * const Webhook = await prisma.webhook.delete({
     *   where: {
     *     // ... filter to delete one Webhook
     *   }
     * })
     * 
     */
    delete<T extends WebhookDeleteArgs>(args: SelectSubset<T, WebhookDeleteArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Webhook.
     * @param {WebhookUpdateArgs} args - Arguments to update one Webhook.
     * @example
     * // Update one Webhook
     * const webhook = await prisma.webhook.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebhookUpdateArgs>(args: SelectSubset<T, WebhookUpdateArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Webhooks.
     * @param {WebhookDeleteManyArgs} args - Arguments to filter Webhooks to delete.
     * @example
     * // Delete a few Webhooks
     * const { count } = await prisma.webhook.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebhookDeleteManyArgs>(args?: SelectSubset<T, WebhookDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Webhooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Webhooks
     * const webhook = await prisma.webhook.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebhookUpdateManyArgs>(args: SelectSubset<T, WebhookUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Webhook.
     * @param {WebhookUpsertArgs} args - Arguments to update or create a Webhook.
     * @example
     * // Update or create a Webhook
     * const webhook = await prisma.webhook.upsert({
     *   create: {
     *     // ... data to create a Webhook
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Webhook we want to update
     *   }
     * })
     */
    upsert<T extends WebhookUpsertArgs>(args: SelectSubset<T, WebhookUpsertArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Webhooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookCountArgs} args - Arguments to filter Webhooks to count.
     * @example
     * // Count the number of Webhooks
     * const count = await prisma.webhook.count({
     *   where: {
     *     // ... the filter for the Webhooks we want to count
     *   }
     * })
    **/
    count<T extends WebhookCountArgs>(
      args?: Subset<T, WebhookCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebhookCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Webhook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebhookAggregateArgs>(args: Subset<T, WebhookAggregateArgs>): Prisma.PrismaPromise<GetWebhookAggregateType<T>>

    /**
     * Group by Webhook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebhookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebhookGroupByArgs['orderBy'] }
        : { orderBy?: WebhookGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebhookGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebhookGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Webhook model
   */
  readonly fields: WebhookFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Webhook.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebhookClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    deliveries<T extends Webhook$deliveriesArgs<ExtArgs> = {}>(args?: Subset<T, Webhook$deliveriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Webhook model
   */ 
  interface WebhookFieldRefs {
    readonly id: FieldRef<"Webhook", 'String'>
    readonly organizationId: FieldRef<"Webhook", 'String'>
    readonly url: FieldRef<"Webhook", 'String'>
    readonly secret: FieldRef<"Webhook", 'String'>
    readonly events: FieldRef<"Webhook", 'String[]'>
    readonly status: FieldRef<"Webhook", 'String'>
    readonly retryConfig: FieldRef<"Webhook", 'Json'>
    readonly lastSuccess: FieldRef<"Webhook", 'DateTime'>
    readonly lastFailure: FieldRef<"Webhook", 'DateTime'>
    readonly createdAt: FieldRef<"Webhook", 'DateTime'>
    readonly updatedAt: FieldRef<"Webhook", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Webhook findUnique
   */
  export type WebhookFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook findUniqueOrThrow
   */
  export type WebhookFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook findFirst
   */
  export type WebhookFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Webhooks.
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Webhooks.
     */
    distinct?: WebhookScalarFieldEnum | WebhookScalarFieldEnum[]
  }

  /**
   * Webhook findFirstOrThrow
   */
  export type WebhookFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Webhooks.
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Webhooks.
     */
    distinct?: WebhookScalarFieldEnum | WebhookScalarFieldEnum[]
  }

  /**
   * Webhook findMany
   */
  export type WebhookFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter, which Webhooks to fetch.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Webhooks.
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    distinct?: WebhookScalarFieldEnum | WebhookScalarFieldEnum[]
  }

  /**
   * Webhook create
   */
  export type WebhookCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * The data needed to create a Webhook.
     */
    data: XOR<WebhookCreateInput, WebhookUncheckedCreateInput>
  }

  /**
   * Webhook createMany
   */
  export type WebhookCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Webhooks.
     */
    data: WebhookCreateManyInput | WebhookCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Webhook createManyAndReturn
   */
  export type WebhookCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Webhooks.
     */
    data: WebhookCreateManyInput | WebhookCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Webhook update
   */
  export type WebhookUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * The data needed to update a Webhook.
     */
    data: XOR<WebhookUpdateInput, WebhookUncheckedUpdateInput>
    /**
     * Choose, which Webhook to update.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook updateMany
   */
  export type WebhookUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Webhooks.
     */
    data: XOR<WebhookUpdateManyMutationInput, WebhookUncheckedUpdateManyInput>
    /**
     * Filter which Webhooks to update
     */
    where?: WebhookWhereInput
  }

  /**
   * Webhook upsert
   */
  export type WebhookUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * The filter to search for the Webhook to update in case it exists.
     */
    where: WebhookWhereUniqueInput
    /**
     * In case the Webhook found by the `where` argument doesn't exist, create a new Webhook with this data.
     */
    create: XOR<WebhookCreateInput, WebhookUncheckedCreateInput>
    /**
     * In case the Webhook was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebhookUpdateInput, WebhookUncheckedUpdateInput>
  }

  /**
   * Webhook delete
   */
  export type WebhookDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter which Webhook to delete.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook deleteMany
   */
  export type WebhookDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Webhooks to delete
     */
    where?: WebhookWhereInput
  }

  /**
   * Webhook.deliveries
   */
  export type Webhook$deliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    where?: WebhookDeliveryWhereInput
    orderBy?: WebhookDeliveryOrderByWithRelationInput | WebhookDeliveryOrderByWithRelationInput[]
    cursor?: WebhookDeliveryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WebhookDeliveryScalarFieldEnum | WebhookDeliveryScalarFieldEnum[]
  }

  /**
   * Webhook without action
   */
  export type WebhookDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
  }


  /**
   * Model WebhookDelivery
   */

  export type AggregateWebhookDelivery = {
    _count: WebhookDeliveryCountAggregateOutputType | null
    _avg: WebhookDeliveryAvgAggregateOutputType | null
    _sum: WebhookDeliverySumAggregateOutputType | null
    _min: WebhookDeliveryMinAggregateOutputType | null
    _max: WebhookDeliveryMaxAggregateOutputType | null
  }

  export type WebhookDeliveryAvgAggregateOutputType = {
    statusCode: number | null
    retries: number | null
  }

  export type WebhookDeliverySumAggregateOutputType = {
    statusCode: number | null
    retries: number | null
  }

  export type WebhookDeliveryMinAggregateOutputType = {
    id: string | null
    webhookId: string | null
    status: string | null
    statusCode: number | null
    response: string | null
    error: string | null
    retries: number | null
    createdAt: Date | null
  }

  export type WebhookDeliveryMaxAggregateOutputType = {
    id: string | null
    webhookId: string | null
    status: string | null
    statusCode: number | null
    response: string | null
    error: string | null
    retries: number | null
    createdAt: Date | null
  }

  export type WebhookDeliveryCountAggregateOutputType = {
    id: number
    webhookId: number
    payload: number
    status: number
    statusCode: number
    response: number
    error: number
    retries: number
    createdAt: number
    _all: number
  }


  export type WebhookDeliveryAvgAggregateInputType = {
    statusCode?: true
    retries?: true
  }

  export type WebhookDeliverySumAggregateInputType = {
    statusCode?: true
    retries?: true
  }

  export type WebhookDeliveryMinAggregateInputType = {
    id?: true
    webhookId?: true
    status?: true
    statusCode?: true
    response?: true
    error?: true
    retries?: true
    createdAt?: true
  }

  export type WebhookDeliveryMaxAggregateInputType = {
    id?: true
    webhookId?: true
    status?: true
    statusCode?: true
    response?: true
    error?: true
    retries?: true
    createdAt?: true
  }

  export type WebhookDeliveryCountAggregateInputType = {
    id?: true
    webhookId?: true
    payload?: true
    status?: true
    statusCode?: true
    response?: true
    error?: true
    retries?: true
    createdAt?: true
    _all?: true
  }

  export type WebhookDeliveryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookDelivery to aggregate.
     */
    where?: WebhookDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookDeliveries to fetch.
     */
    orderBy?: WebhookDeliveryOrderByWithRelationInput | WebhookDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebhookDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookDeliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WebhookDeliveries
    **/
    _count?: true | WebhookDeliveryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WebhookDeliveryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WebhookDeliverySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebhookDeliveryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebhookDeliveryMaxAggregateInputType
  }

  export type GetWebhookDeliveryAggregateType<T extends WebhookDeliveryAggregateArgs> = {
        [P in keyof T & keyof AggregateWebhookDelivery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebhookDelivery[P]>
      : GetScalarType<T[P], AggregateWebhookDelivery[P]>
  }




  export type WebhookDeliveryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookDeliveryWhereInput
    orderBy?: WebhookDeliveryOrderByWithAggregationInput | WebhookDeliveryOrderByWithAggregationInput[]
    by: WebhookDeliveryScalarFieldEnum[] | WebhookDeliveryScalarFieldEnum
    having?: WebhookDeliveryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebhookDeliveryCountAggregateInputType | true
    _avg?: WebhookDeliveryAvgAggregateInputType
    _sum?: WebhookDeliverySumAggregateInputType
    _min?: WebhookDeliveryMinAggregateInputType
    _max?: WebhookDeliveryMaxAggregateInputType
  }

  export type WebhookDeliveryGroupByOutputType = {
    id: string
    webhookId: string
    payload: JsonValue
    status: string
    statusCode: number | null
    response: string | null
    error: string | null
    retries: number
    createdAt: Date
    _count: WebhookDeliveryCountAggregateOutputType | null
    _avg: WebhookDeliveryAvgAggregateOutputType | null
    _sum: WebhookDeliverySumAggregateOutputType | null
    _min: WebhookDeliveryMinAggregateOutputType | null
    _max: WebhookDeliveryMaxAggregateOutputType | null
  }

  type GetWebhookDeliveryGroupByPayload<T extends WebhookDeliveryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebhookDeliveryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebhookDeliveryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebhookDeliveryGroupByOutputType[P]>
            : GetScalarType<T[P], WebhookDeliveryGroupByOutputType[P]>
        }
      >
    >


  export type WebhookDeliverySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    webhookId?: boolean
    payload?: boolean
    status?: boolean
    statusCode?: boolean
    response?: boolean
    error?: boolean
    retries?: boolean
    createdAt?: boolean
    webhook?: boolean | WebhookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webhookDelivery"]>

  export type WebhookDeliverySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    webhookId?: boolean
    payload?: boolean
    status?: boolean
    statusCode?: boolean
    response?: boolean
    error?: boolean
    retries?: boolean
    createdAt?: boolean
    webhook?: boolean | WebhookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webhookDelivery"]>

  export type WebhookDeliverySelectScalar = {
    id?: boolean
    webhookId?: boolean
    payload?: boolean
    status?: boolean
    statusCode?: boolean
    response?: boolean
    error?: boolean
    retries?: boolean
    createdAt?: boolean
  }

  export type WebhookDeliveryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    webhook?: boolean | WebhookDefaultArgs<ExtArgs>
  }
  export type WebhookDeliveryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    webhook?: boolean | WebhookDefaultArgs<ExtArgs>
  }

  export type $WebhookDeliveryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WebhookDelivery"
    objects: {
      webhook: Prisma.$WebhookPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      webhookId: string
      payload: Prisma.JsonValue
      status: string
      statusCode: number | null
      response: string | null
      error: string | null
      retries: number
      createdAt: Date
    }, ExtArgs["result"]["webhookDelivery"]>
    composites: {}
  }

  type WebhookDeliveryGetPayload<S extends boolean | null | undefined | WebhookDeliveryDefaultArgs> = $Result.GetResult<Prisma.$WebhookDeliveryPayload, S>

  type WebhookDeliveryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WebhookDeliveryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WebhookDeliveryCountAggregateInputType | true
    }

  export interface WebhookDeliveryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WebhookDelivery'], meta: { name: 'WebhookDelivery' } }
    /**
     * Find zero or one WebhookDelivery that matches the filter.
     * @param {WebhookDeliveryFindUniqueArgs} args - Arguments to find a WebhookDelivery
     * @example
     * // Get one WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebhookDeliveryFindUniqueArgs>(args: SelectSubset<T, WebhookDeliveryFindUniqueArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WebhookDelivery that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WebhookDeliveryFindUniqueOrThrowArgs} args - Arguments to find a WebhookDelivery
     * @example
     * // Get one WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebhookDeliveryFindUniqueOrThrowArgs>(args: SelectSubset<T, WebhookDeliveryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WebhookDelivery that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryFindFirstArgs} args - Arguments to find a WebhookDelivery
     * @example
     * // Get one WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebhookDeliveryFindFirstArgs>(args?: SelectSubset<T, WebhookDeliveryFindFirstArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WebhookDelivery that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryFindFirstOrThrowArgs} args - Arguments to find a WebhookDelivery
     * @example
     * // Get one WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebhookDeliveryFindFirstOrThrowArgs>(args?: SelectSubset<T, WebhookDeliveryFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WebhookDeliveries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WebhookDeliveries
     * const webhookDeliveries = await prisma.webhookDelivery.findMany()
     * 
     * // Get first 10 WebhookDeliveries
     * const webhookDeliveries = await prisma.webhookDelivery.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webhookDeliveryWithIdOnly = await prisma.webhookDelivery.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WebhookDeliveryFindManyArgs>(args?: SelectSubset<T, WebhookDeliveryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WebhookDelivery.
     * @param {WebhookDeliveryCreateArgs} args - Arguments to create a WebhookDelivery.
     * @example
     * // Create one WebhookDelivery
     * const WebhookDelivery = await prisma.webhookDelivery.create({
     *   data: {
     *     // ... data to create a WebhookDelivery
     *   }
     * })
     * 
     */
    create<T extends WebhookDeliveryCreateArgs>(args: SelectSubset<T, WebhookDeliveryCreateArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WebhookDeliveries.
     * @param {WebhookDeliveryCreateManyArgs} args - Arguments to create many WebhookDeliveries.
     * @example
     * // Create many WebhookDeliveries
     * const webhookDelivery = await prisma.webhookDelivery.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebhookDeliveryCreateManyArgs>(args?: SelectSubset<T, WebhookDeliveryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WebhookDeliveries and returns the data saved in the database.
     * @param {WebhookDeliveryCreateManyAndReturnArgs} args - Arguments to create many WebhookDeliveries.
     * @example
     * // Create many WebhookDeliveries
     * const webhookDelivery = await prisma.webhookDelivery.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WebhookDeliveries and only return the `id`
     * const webhookDeliveryWithIdOnly = await prisma.webhookDelivery.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WebhookDeliveryCreateManyAndReturnArgs>(args?: SelectSubset<T, WebhookDeliveryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WebhookDelivery.
     * @param {WebhookDeliveryDeleteArgs} args - Arguments to delete one WebhookDelivery.
     * @example
     * // Delete one WebhookDelivery
     * const WebhookDelivery = await prisma.webhookDelivery.delete({
     *   where: {
     *     // ... filter to delete one WebhookDelivery
     *   }
     * })
     * 
     */
    delete<T extends WebhookDeliveryDeleteArgs>(args: SelectSubset<T, WebhookDeliveryDeleteArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WebhookDelivery.
     * @param {WebhookDeliveryUpdateArgs} args - Arguments to update one WebhookDelivery.
     * @example
     * // Update one WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebhookDeliveryUpdateArgs>(args: SelectSubset<T, WebhookDeliveryUpdateArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WebhookDeliveries.
     * @param {WebhookDeliveryDeleteManyArgs} args - Arguments to filter WebhookDeliveries to delete.
     * @example
     * // Delete a few WebhookDeliveries
     * const { count } = await prisma.webhookDelivery.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebhookDeliveryDeleteManyArgs>(args?: SelectSubset<T, WebhookDeliveryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebhookDeliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WebhookDeliveries
     * const webhookDelivery = await prisma.webhookDelivery.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebhookDeliveryUpdateManyArgs>(args: SelectSubset<T, WebhookDeliveryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WebhookDelivery.
     * @param {WebhookDeliveryUpsertArgs} args - Arguments to update or create a WebhookDelivery.
     * @example
     * // Update or create a WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.upsert({
     *   create: {
     *     // ... data to create a WebhookDelivery
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WebhookDelivery we want to update
     *   }
     * })
     */
    upsert<T extends WebhookDeliveryUpsertArgs>(args: SelectSubset<T, WebhookDeliveryUpsertArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WebhookDeliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryCountArgs} args - Arguments to filter WebhookDeliveries to count.
     * @example
     * // Count the number of WebhookDeliveries
     * const count = await prisma.webhookDelivery.count({
     *   where: {
     *     // ... the filter for the WebhookDeliveries we want to count
     *   }
     * })
    **/
    count<T extends WebhookDeliveryCountArgs>(
      args?: Subset<T, WebhookDeliveryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebhookDeliveryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WebhookDelivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebhookDeliveryAggregateArgs>(args: Subset<T, WebhookDeliveryAggregateArgs>): Prisma.PrismaPromise<GetWebhookDeliveryAggregateType<T>>

    /**
     * Group by WebhookDelivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebhookDeliveryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebhookDeliveryGroupByArgs['orderBy'] }
        : { orderBy?: WebhookDeliveryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebhookDeliveryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebhookDeliveryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WebhookDelivery model
   */
  readonly fields: WebhookDeliveryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WebhookDelivery.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebhookDeliveryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    webhook<T extends WebhookDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WebhookDefaultArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WebhookDelivery model
   */ 
  interface WebhookDeliveryFieldRefs {
    readonly id: FieldRef<"WebhookDelivery", 'String'>
    readonly webhookId: FieldRef<"WebhookDelivery", 'String'>
    readonly payload: FieldRef<"WebhookDelivery", 'Json'>
    readonly status: FieldRef<"WebhookDelivery", 'String'>
    readonly statusCode: FieldRef<"WebhookDelivery", 'Int'>
    readonly response: FieldRef<"WebhookDelivery", 'String'>
    readonly error: FieldRef<"WebhookDelivery", 'String'>
    readonly retries: FieldRef<"WebhookDelivery", 'Int'>
    readonly createdAt: FieldRef<"WebhookDelivery", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WebhookDelivery findUnique
   */
  export type WebhookDeliveryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which WebhookDelivery to fetch.
     */
    where: WebhookDeliveryWhereUniqueInput
  }

  /**
   * WebhookDelivery findUniqueOrThrow
   */
  export type WebhookDeliveryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which WebhookDelivery to fetch.
     */
    where: WebhookDeliveryWhereUniqueInput
  }

  /**
   * WebhookDelivery findFirst
   */
  export type WebhookDeliveryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which WebhookDelivery to fetch.
     */
    where?: WebhookDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookDeliveries to fetch.
     */
    orderBy?: WebhookDeliveryOrderByWithRelationInput | WebhookDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookDeliveries.
     */
    cursor?: WebhookDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookDeliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookDeliveries.
     */
    distinct?: WebhookDeliveryScalarFieldEnum | WebhookDeliveryScalarFieldEnum[]
  }

  /**
   * WebhookDelivery findFirstOrThrow
   */
  export type WebhookDeliveryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which WebhookDelivery to fetch.
     */
    where?: WebhookDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookDeliveries to fetch.
     */
    orderBy?: WebhookDeliveryOrderByWithRelationInput | WebhookDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookDeliveries.
     */
    cursor?: WebhookDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookDeliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookDeliveries.
     */
    distinct?: WebhookDeliveryScalarFieldEnum | WebhookDeliveryScalarFieldEnum[]
  }

  /**
   * WebhookDelivery findMany
   */
  export type WebhookDeliveryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which WebhookDeliveries to fetch.
     */
    where?: WebhookDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookDeliveries to fetch.
     */
    orderBy?: WebhookDeliveryOrderByWithRelationInput | WebhookDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WebhookDeliveries.
     */
    cursor?: WebhookDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookDeliveries.
     */
    skip?: number
    distinct?: WebhookDeliveryScalarFieldEnum | WebhookDeliveryScalarFieldEnum[]
  }

  /**
   * WebhookDelivery create
   */
  export type WebhookDeliveryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * The data needed to create a WebhookDelivery.
     */
    data: XOR<WebhookDeliveryCreateInput, WebhookDeliveryUncheckedCreateInput>
  }

  /**
   * WebhookDelivery createMany
   */
  export type WebhookDeliveryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WebhookDeliveries.
     */
    data: WebhookDeliveryCreateManyInput | WebhookDeliveryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WebhookDelivery createManyAndReturn
   */
  export type WebhookDeliveryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WebhookDeliveries.
     */
    data: WebhookDeliveryCreateManyInput | WebhookDeliveryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WebhookDelivery update
   */
  export type WebhookDeliveryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * The data needed to update a WebhookDelivery.
     */
    data: XOR<WebhookDeliveryUpdateInput, WebhookDeliveryUncheckedUpdateInput>
    /**
     * Choose, which WebhookDelivery to update.
     */
    where: WebhookDeliveryWhereUniqueInput
  }

  /**
   * WebhookDelivery updateMany
   */
  export type WebhookDeliveryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WebhookDeliveries.
     */
    data: XOR<WebhookDeliveryUpdateManyMutationInput, WebhookDeliveryUncheckedUpdateManyInput>
    /**
     * Filter which WebhookDeliveries to update
     */
    where?: WebhookDeliveryWhereInput
  }

  /**
   * WebhookDelivery upsert
   */
  export type WebhookDeliveryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * The filter to search for the WebhookDelivery to update in case it exists.
     */
    where: WebhookDeliveryWhereUniqueInput
    /**
     * In case the WebhookDelivery found by the `where` argument doesn't exist, create a new WebhookDelivery with this data.
     */
    create: XOR<WebhookDeliveryCreateInput, WebhookDeliveryUncheckedCreateInput>
    /**
     * In case the WebhookDelivery was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebhookDeliveryUpdateInput, WebhookDeliveryUncheckedUpdateInput>
  }

  /**
   * WebhookDelivery delete
   */
  export type WebhookDeliveryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter which WebhookDelivery to delete.
     */
    where: WebhookDeliveryWhereUniqueInput
  }

  /**
   * WebhookDelivery deleteMany
   */
  export type WebhookDeliveryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookDeliveries to delete
     */
    where?: WebhookDeliveryWhereInput
  }

  /**
   * WebhookDelivery without action
   */
  export type WebhookDeliveryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
  }


  /**
   * Model RefreshToken
   */

  export type AggregateRefreshToken = {
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  export type RefreshTokenMinAggregateOutputType = {
    id: string | null
    token: string | null
    userId: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RefreshTokenMaxAggregateOutputType = {
    id: string | null
    token: string | null
    userId: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RefreshTokenCountAggregateOutputType = {
    id: number
    token: number
    userId: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RefreshTokenMinAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RefreshTokenMaxAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RefreshTokenCountAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RefreshTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshToken to aggregate.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefreshTokens
    **/
    _count?: true | RefreshTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefreshTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type GetRefreshTokenAggregateType<T extends RefreshTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefreshToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshToken[P]>
      : GetScalarType<T[P], AggregateRefreshToken[P]>
  }




  export type RefreshTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithAggregationInput | RefreshTokenOrderByWithAggregationInput[]
    by: RefreshTokenScalarFieldEnum[] | RefreshTokenScalarFieldEnum
    having?: RefreshTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefreshTokenCountAggregateInputType | true
    _min?: RefreshTokenMinAggregateInputType
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type RefreshTokenGroupByOutputType = {
    id: string
    token: string
    userId: string
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  type GetRefreshTokenGroupByPayload<T extends RefreshTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefreshTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefreshTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
        }
      >
    >


  export type RefreshTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectScalar = {
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RefreshTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RefreshTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefreshToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      userId: string
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["refreshToken"]>
    composites: {}
  }

  type RefreshTokenGetPayload<S extends boolean | null | undefined | RefreshTokenDefaultArgs> = $Result.GetResult<Prisma.$RefreshTokenPayload, S>

  type RefreshTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RefreshTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RefreshTokenCountAggregateInputType | true
    }

  export interface RefreshTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefreshToken'], meta: { name: 'RefreshToken' } }
    /**
     * Find zero or one RefreshToken that matches the filter.
     * @param {RefreshTokenFindUniqueArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefreshTokenFindUniqueArgs>(args: SelectSubset<T, RefreshTokenFindUniqueArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RefreshToken that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RefreshTokenFindUniqueOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefreshTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, RefreshTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RefreshToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefreshTokenFindFirstArgs>(args?: SelectSubset<T, RefreshTokenFindFirstArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RefreshToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefreshTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, RefreshTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RefreshTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany()
     * 
     * // Get first 10 RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefreshTokenFindManyArgs>(args?: SelectSubset<T, RefreshTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RefreshToken.
     * @param {RefreshTokenCreateArgs} args - Arguments to create a RefreshToken.
     * @example
     * // Create one RefreshToken
     * const RefreshToken = await prisma.refreshToken.create({
     *   data: {
     *     // ... data to create a RefreshToken
     *   }
     * })
     * 
     */
    create<T extends RefreshTokenCreateArgs>(args: SelectSubset<T, RefreshTokenCreateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RefreshTokens.
     * @param {RefreshTokenCreateManyArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefreshTokenCreateManyArgs>(args?: SelectSubset<T, RefreshTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RefreshTokens and returns the data saved in the database.
     * @param {RefreshTokenCreateManyAndReturnArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefreshTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, RefreshTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RefreshToken.
     * @param {RefreshTokenDeleteArgs} args - Arguments to delete one RefreshToken.
     * @example
     * // Delete one RefreshToken
     * const RefreshToken = await prisma.refreshToken.delete({
     *   where: {
     *     // ... filter to delete one RefreshToken
     *   }
     * })
     * 
     */
    delete<T extends RefreshTokenDeleteArgs>(args: SelectSubset<T, RefreshTokenDeleteArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RefreshToken.
     * @param {RefreshTokenUpdateArgs} args - Arguments to update one RefreshToken.
     * @example
     * // Update one RefreshToken
     * const refreshToken = await prisma.refreshToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefreshTokenUpdateArgs>(args: SelectSubset<T, RefreshTokenUpdateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RefreshTokens.
     * @param {RefreshTokenDeleteManyArgs} args - Arguments to filter RefreshTokens to delete.
     * @example
     * // Delete a few RefreshTokens
     * const { count } = await prisma.refreshToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefreshTokenDeleteManyArgs>(args?: SelectSubset<T, RefreshTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefreshTokenUpdateManyArgs>(args: SelectSubset<T, RefreshTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RefreshToken.
     * @param {RefreshTokenUpsertArgs} args - Arguments to update or create a RefreshToken.
     * @example
     * // Update or create a RefreshToken
     * const refreshToken = await prisma.refreshToken.upsert({
     *   create: {
     *     // ... data to create a RefreshToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefreshToken we want to update
     *   }
     * })
     */
    upsert<T extends RefreshTokenUpsertArgs>(args: SelectSubset<T, RefreshTokenUpsertArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenCountArgs} args - Arguments to filter RefreshTokens to count.
     * @example
     * // Count the number of RefreshTokens
     * const count = await prisma.refreshToken.count({
     *   where: {
     *     // ... the filter for the RefreshTokens we want to count
     *   }
     * })
    **/
    count<T extends RefreshTokenCountArgs>(
      args?: Subset<T, RefreshTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefreshTokenAggregateArgs>(args: Subset<T, RefreshTokenAggregateArgs>): Prisma.PrismaPromise<GetRefreshTokenAggregateType<T>>

    /**
     * Group by RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefreshTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefreshTokenGroupByArgs['orderBy'] }
        : { orderBy?: RefreshTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefreshTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefreshTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefreshToken model
   */
  readonly fields: RefreshTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefreshToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefreshTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefreshToken model
   */ 
  interface RefreshTokenFieldRefs {
    readonly id: FieldRef<"RefreshToken", 'String'>
    readonly token: FieldRef<"RefreshToken", 'String'>
    readonly userId: FieldRef<"RefreshToken", 'String'>
    readonly expiresAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly createdAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly updatedAt: FieldRef<"RefreshToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RefreshToken findUnique
   */
  export type RefreshTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findUniqueOrThrow
   */
  export type RefreshTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findFirst
   */
  export type RefreshTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findFirstOrThrow
   */
  export type RefreshTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findMany
   */
  export type RefreshTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshTokens to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken create
   */
  export type RefreshTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a RefreshToken.
     */
    data: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
  }

  /**
   * RefreshToken createMany
   */
  export type RefreshTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RefreshToken createManyAndReturn
   */
  export type RefreshTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken update
   */
  export type RefreshTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a RefreshToken.
     */
    data: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
    /**
     * Choose, which RefreshToken to update.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken updateMany
   */
  export type RefreshTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
  }

  /**
   * RefreshToken upsert
   */
  export type RefreshTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the RefreshToken to update in case it exists.
     */
    where: RefreshTokenWhereUniqueInput
    /**
     * In case the RefreshToken found by the `where` argument doesn't exist, create a new RefreshToken with this data.
     */
    create: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
    /**
     * In case the RefreshToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
  }

  /**
   * RefreshToken delete
   */
  export type RefreshTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter which RefreshToken to delete.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken deleteMany
   */
  export type RefreshTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshTokens to delete
     */
    where?: RefreshTokenWhereInput
  }

  /**
   * RefreshToken without action
   */
  export type RefreshTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    amount: number | null
    currency: string | null
    status: string | null
    stripePaymentId: string | null
    userId: string | null
    customerId: string | null
    subscriptionId: string | null
    orderId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    amount: number | null
    currency: string | null
    status: string | null
    stripePaymentId: string | null
    userId: string | null
    customerId: string | null
    subscriptionId: string | null
    orderId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    amount: number
    currency: number
    status: number
    stripePaymentId: number
    userId: number
    customerId: number
    subscriptionId: number
    orderId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    amount?: true
    currency?: true
    status?: true
    stripePaymentId?: true
    userId?: true
    customerId?: true
    subscriptionId?: true
    orderId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    amount?: true
    currency?: true
    status?: true
    stripePaymentId?: true
    userId?: true
    customerId?: true
    subscriptionId?: true
    orderId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    amount?: true
    currency?: true
    status?: true
    stripePaymentId?: true
    userId?: true
    customerId?: true
    subscriptionId?: true
    orderId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    amount: number
    currency: string
    status: string
    stripePaymentId: string
    userId: string
    customerId: string | null
    subscriptionId: string | null
    orderId: string | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    stripePaymentId?: boolean
    userId?: boolean
    customerId?: boolean
    subscriptionId?: boolean
    orderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | Payment$customerArgs<ExtArgs>
    subscription?: boolean | Payment$subscriptionArgs<ExtArgs>
    order?: boolean | Payment$orderArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    stripePaymentId?: boolean
    userId?: boolean
    customerId?: boolean
    subscriptionId?: boolean
    orderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | Payment$customerArgs<ExtArgs>
    subscription?: boolean | Payment$subscriptionArgs<ExtArgs>
    order?: boolean | Payment$orderArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    stripePaymentId?: boolean
    userId?: boolean
    customerId?: boolean
    subscriptionId?: boolean
    orderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | Payment$customerArgs<ExtArgs>
    subscription?: boolean | Payment$subscriptionArgs<ExtArgs>
    order?: boolean | Payment$orderArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | Payment$customerArgs<ExtArgs>
    subscription?: boolean | Payment$subscriptionArgs<ExtArgs>
    order?: boolean | Payment$orderArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      subscription: Prisma.$SubscriptionPayload<ExtArgs> | null
      order: Prisma.$OrderPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      amount: number
      currency: string
      status: string
      stripePaymentId: string
      userId: string
      customerId: string | null
      subscriptionId: string | null
      orderId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    customer<T extends Payment$customerArgs<ExtArgs> = {}>(args?: Subset<T, Payment$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    subscription<T extends Payment$subscriptionArgs<ExtArgs> = {}>(args?: Subset<T, Payment$subscriptionArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    order<T extends Payment$orderArgs<ExtArgs> = {}>(args?: Subset<T, Payment$orderArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */ 
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Float'>
    readonly currency: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'String'>
    readonly stripePaymentId: FieldRef<"Payment", 'String'>
    readonly userId: FieldRef<"Payment", 'String'>
    readonly customerId: FieldRef<"Payment", 'String'>
    readonly subscriptionId: FieldRef<"Payment", 'String'>
    readonly orderId: FieldRef<"Payment", 'String'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment.customer
   */
  export type Payment$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * Payment.subscription
   */
  export type Payment$subscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
  }

  /**
   * Payment.order
   */
  export type Payment$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model FinancingOffer
   */

  export type AggregateFinancingOffer = {
    _count: FinancingOfferCountAggregateOutputType | null
    _avg: FinancingOfferAvgAggregateOutputType | null
    _sum: FinancingOfferSumAggregateOutputType | null
    _min: FinancingOfferMinAggregateOutputType | null
    _max: FinancingOfferMaxAggregateOutputType | null
  }

  export type FinancingOfferAvgAggregateOutputType = {
    amount: number | null
  }

  export type FinancingOfferSumAggregateOutputType = {
    amount: number | null
  }

  export type FinancingOfferMinAggregateOutputType = {
    id: string | null
    amount: number | null
    currency: string | null
    provider: string | null
    customerId: string | null
    status: string | null
    offerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FinancingOfferMaxAggregateOutputType = {
    id: string | null
    amount: number | null
    currency: string | null
    provider: string | null
    customerId: string | null
    status: string | null
    offerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FinancingOfferCountAggregateOutputType = {
    id: number
    amount: number
    currency: number
    provider: number
    customerId: number
    status: number
    offerId: number
    terms: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FinancingOfferAvgAggregateInputType = {
    amount?: true
  }

  export type FinancingOfferSumAggregateInputType = {
    amount?: true
  }

  export type FinancingOfferMinAggregateInputType = {
    id?: true
    amount?: true
    currency?: true
    provider?: true
    customerId?: true
    status?: true
    offerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FinancingOfferMaxAggregateInputType = {
    id?: true
    amount?: true
    currency?: true
    provider?: true
    customerId?: true
    status?: true
    offerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FinancingOfferCountAggregateInputType = {
    id?: true
    amount?: true
    currency?: true
    provider?: true
    customerId?: true
    status?: true
    offerId?: true
    terms?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FinancingOfferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinancingOffer to aggregate.
     */
    where?: FinancingOfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancingOffers to fetch.
     */
    orderBy?: FinancingOfferOrderByWithRelationInput | FinancingOfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FinancingOfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancingOffers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancingOffers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FinancingOffers
    **/
    _count?: true | FinancingOfferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FinancingOfferAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FinancingOfferSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FinancingOfferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FinancingOfferMaxAggregateInputType
  }

  export type GetFinancingOfferAggregateType<T extends FinancingOfferAggregateArgs> = {
        [P in keyof T & keyof AggregateFinancingOffer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFinancingOffer[P]>
      : GetScalarType<T[P], AggregateFinancingOffer[P]>
  }




  export type FinancingOfferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinancingOfferWhereInput
    orderBy?: FinancingOfferOrderByWithAggregationInput | FinancingOfferOrderByWithAggregationInput[]
    by: FinancingOfferScalarFieldEnum[] | FinancingOfferScalarFieldEnum
    having?: FinancingOfferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FinancingOfferCountAggregateInputType | true
    _avg?: FinancingOfferAvgAggregateInputType
    _sum?: FinancingOfferSumAggregateInputType
    _min?: FinancingOfferMinAggregateInputType
    _max?: FinancingOfferMaxAggregateInputType
  }

  export type FinancingOfferGroupByOutputType = {
    id: string
    amount: number
    currency: string
    provider: string
    customerId: string
    status: string
    offerId: string
    terms: JsonValue
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: FinancingOfferCountAggregateOutputType | null
    _avg: FinancingOfferAvgAggregateOutputType | null
    _sum: FinancingOfferSumAggregateOutputType | null
    _min: FinancingOfferMinAggregateOutputType | null
    _max: FinancingOfferMaxAggregateOutputType | null
  }

  type GetFinancingOfferGroupByPayload<T extends FinancingOfferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FinancingOfferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FinancingOfferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FinancingOfferGroupByOutputType[P]>
            : GetScalarType<T[P], FinancingOfferGroupByOutputType[P]>
        }
      >
    >


  export type FinancingOfferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    currency?: boolean
    provider?: boolean
    customerId?: boolean
    status?: boolean
    offerId?: boolean
    terms?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["financingOffer"]>

  export type FinancingOfferSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    currency?: boolean
    provider?: boolean
    customerId?: boolean
    status?: boolean
    offerId?: boolean
    terms?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["financingOffer"]>

  export type FinancingOfferSelectScalar = {
    id?: boolean
    amount?: boolean
    currency?: boolean
    provider?: boolean
    customerId?: boolean
    status?: boolean
    offerId?: boolean
    terms?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $FinancingOfferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FinancingOffer"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      amount: number
      currency: string
      provider: string
      customerId: string
      status: string
      offerId: string
      terms: Prisma.JsonValue
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["financingOffer"]>
    composites: {}
  }

  type FinancingOfferGetPayload<S extends boolean | null | undefined | FinancingOfferDefaultArgs> = $Result.GetResult<Prisma.$FinancingOfferPayload, S>

  type FinancingOfferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FinancingOfferFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FinancingOfferCountAggregateInputType | true
    }

  export interface FinancingOfferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FinancingOffer'], meta: { name: 'FinancingOffer' } }
    /**
     * Find zero or one FinancingOffer that matches the filter.
     * @param {FinancingOfferFindUniqueArgs} args - Arguments to find a FinancingOffer
     * @example
     * // Get one FinancingOffer
     * const financingOffer = await prisma.financingOffer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FinancingOfferFindUniqueArgs>(args: SelectSubset<T, FinancingOfferFindUniqueArgs<ExtArgs>>): Prisma__FinancingOfferClient<$Result.GetResult<Prisma.$FinancingOfferPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FinancingOffer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FinancingOfferFindUniqueOrThrowArgs} args - Arguments to find a FinancingOffer
     * @example
     * // Get one FinancingOffer
     * const financingOffer = await prisma.financingOffer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FinancingOfferFindUniqueOrThrowArgs>(args: SelectSubset<T, FinancingOfferFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FinancingOfferClient<$Result.GetResult<Prisma.$FinancingOfferPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FinancingOffer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancingOfferFindFirstArgs} args - Arguments to find a FinancingOffer
     * @example
     * // Get one FinancingOffer
     * const financingOffer = await prisma.financingOffer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FinancingOfferFindFirstArgs>(args?: SelectSubset<T, FinancingOfferFindFirstArgs<ExtArgs>>): Prisma__FinancingOfferClient<$Result.GetResult<Prisma.$FinancingOfferPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FinancingOffer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancingOfferFindFirstOrThrowArgs} args - Arguments to find a FinancingOffer
     * @example
     * // Get one FinancingOffer
     * const financingOffer = await prisma.financingOffer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FinancingOfferFindFirstOrThrowArgs>(args?: SelectSubset<T, FinancingOfferFindFirstOrThrowArgs<ExtArgs>>): Prisma__FinancingOfferClient<$Result.GetResult<Prisma.$FinancingOfferPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FinancingOffers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancingOfferFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FinancingOffers
     * const financingOffers = await prisma.financingOffer.findMany()
     * 
     * // Get first 10 FinancingOffers
     * const financingOffers = await prisma.financingOffer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const financingOfferWithIdOnly = await prisma.financingOffer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FinancingOfferFindManyArgs>(args?: SelectSubset<T, FinancingOfferFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancingOfferPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FinancingOffer.
     * @param {FinancingOfferCreateArgs} args - Arguments to create a FinancingOffer.
     * @example
     * // Create one FinancingOffer
     * const FinancingOffer = await prisma.financingOffer.create({
     *   data: {
     *     // ... data to create a FinancingOffer
     *   }
     * })
     * 
     */
    create<T extends FinancingOfferCreateArgs>(args: SelectSubset<T, FinancingOfferCreateArgs<ExtArgs>>): Prisma__FinancingOfferClient<$Result.GetResult<Prisma.$FinancingOfferPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FinancingOffers.
     * @param {FinancingOfferCreateManyArgs} args - Arguments to create many FinancingOffers.
     * @example
     * // Create many FinancingOffers
     * const financingOffer = await prisma.financingOffer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FinancingOfferCreateManyArgs>(args?: SelectSubset<T, FinancingOfferCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FinancingOffers and returns the data saved in the database.
     * @param {FinancingOfferCreateManyAndReturnArgs} args - Arguments to create many FinancingOffers.
     * @example
     * // Create many FinancingOffers
     * const financingOffer = await prisma.financingOffer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FinancingOffers and only return the `id`
     * const financingOfferWithIdOnly = await prisma.financingOffer.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FinancingOfferCreateManyAndReturnArgs>(args?: SelectSubset<T, FinancingOfferCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancingOfferPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FinancingOffer.
     * @param {FinancingOfferDeleteArgs} args - Arguments to delete one FinancingOffer.
     * @example
     * // Delete one FinancingOffer
     * const FinancingOffer = await prisma.financingOffer.delete({
     *   where: {
     *     // ... filter to delete one FinancingOffer
     *   }
     * })
     * 
     */
    delete<T extends FinancingOfferDeleteArgs>(args: SelectSubset<T, FinancingOfferDeleteArgs<ExtArgs>>): Prisma__FinancingOfferClient<$Result.GetResult<Prisma.$FinancingOfferPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FinancingOffer.
     * @param {FinancingOfferUpdateArgs} args - Arguments to update one FinancingOffer.
     * @example
     * // Update one FinancingOffer
     * const financingOffer = await prisma.financingOffer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FinancingOfferUpdateArgs>(args: SelectSubset<T, FinancingOfferUpdateArgs<ExtArgs>>): Prisma__FinancingOfferClient<$Result.GetResult<Prisma.$FinancingOfferPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FinancingOffers.
     * @param {FinancingOfferDeleteManyArgs} args - Arguments to filter FinancingOffers to delete.
     * @example
     * // Delete a few FinancingOffers
     * const { count } = await prisma.financingOffer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FinancingOfferDeleteManyArgs>(args?: SelectSubset<T, FinancingOfferDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FinancingOffers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancingOfferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FinancingOffers
     * const financingOffer = await prisma.financingOffer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FinancingOfferUpdateManyArgs>(args: SelectSubset<T, FinancingOfferUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FinancingOffer.
     * @param {FinancingOfferUpsertArgs} args - Arguments to update or create a FinancingOffer.
     * @example
     * // Update or create a FinancingOffer
     * const financingOffer = await prisma.financingOffer.upsert({
     *   create: {
     *     // ... data to create a FinancingOffer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FinancingOffer we want to update
     *   }
     * })
     */
    upsert<T extends FinancingOfferUpsertArgs>(args: SelectSubset<T, FinancingOfferUpsertArgs<ExtArgs>>): Prisma__FinancingOfferClient<$Result.GetResult<Prisma.$FinancingOfferPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FinancingOffers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancingOfferCountArgs} args - Arguments to filter FinancingOffers to count.
     * @example
     * // Count the number of FinancingOffers
     * const count = await prisma.financingOffer.count({
     *   where: {
     *     // ... the filter for the FinancingOffers we want to count
     *   }
     * })
    **/
    count<T extends FinancingOfferCountArgs>(
      args?: Subset<T, FinancingOfferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FinancingOfferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FinancingOffer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancingOfferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FinancingOfferAggregateArgs>(args: Subset<T, FinancingOfferAggregateArgs>): Prisma.PrismaPromise<GetFinancingOfferAggregateType<T>>

    /**
     * Group by FinancingOffer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancingOfferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FinancingOfferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FinancingOfferGroupByArgs['orderBy'] }
        : { orderBy?: FinancingOfferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FinancingOfferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFinancingOfferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FinancingOffer model
   */
  readonly fields: FinancingOfferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FinancingOffer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FinancingOfferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FinancingOffer model
   */ 
  interface FinancingOfferFieldRefs {
    readonly id: FieldRef<"FinancingOffer", 'String'>
    readonly amount: FieldRef<"FinancingOffer", 'Float'>
    readonly currency: FieldRef<"FinancingOffer", 'String'>
    readonly provider: FieldRef<"FinancingOffer", 'String'>
    readonly customerId: FieldRef<"FinancingOffer", 'String'>
    readonly status: FieldRef<"FinancingOffer", 'String'>
    readonly offerId: FieldRef<"FinancingOffer", 'String'>
    readonly terms: FieldRef<"FinancingOffer", 'Json'>
    readonly metadata: FieldRef<"FinancingOffer", 'Json'>
    readonly createdAt: FieldRef<"FinancingOffer", 'DateTime'>
    readonly updatedAt: FieldRef<"FinancingOffer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FinancingOffer findUnique
   */
  export type FinancingOfferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancingOffer
     */
    select?: FinancingOfferSelect<ExtArgs> | null
    /**
     * Filter, which FinancingOffer to fetch.
     */
    where: FinancingOfferWhereUniqueInput
  }

  /**
   * FinancingOffer findUniqueOrThrow
   */
  export type FinancingOfferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancingOffer
     */
    select?: FinancingOfferSelect<ExtArgs> | null
    /**
     * Filter, which FinancingOffer to fetch.
     */
    where: FinancingOfferWhereUniqueInput
  }

  /**
   * FinancingOffer findFirst
   */
  export type FinancingOfferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancingOffer
     */
    select?: FinancingOfferSelect<ExtArgs> | null
    /**
     * Filter, which FinancingOffer to fetch.
     */
    where?: FinancingOfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancingOffers to fetch.
     */
    orderBy?: FinancingOfferOrderByWithRelationInput | FinancingOfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinancingOffers.
     */
    cursor?: FinancingOfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancingOffers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancingOffers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinancingOffers.
     */
    distinct?: FinancingOfferScalarFieldEnum | FinancingOfferScalarFieldEnum[]
  }

  /**
   * FinancingOffer findFirstOrThrow
   */
  export type FinancingOfferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancingOffer
     */
    select?: FinancingOfferSelect<ExtArgs> | null
    /**
     * Filter, which FinancingOffer to fetch.
     */
    where?: FinancingOfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancingOffers to fetch.
     */
    orderBy?: FinancingOfferOrderByWithRelationInput | FinancingOfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinancingOffers.
     */
    cursor?: FinancingOfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancingOffers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancingOffers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinancingOffers.
     */
    distinct?: FinancingOfferScalarFieldEnum | FinancingOfferScalarFieldEnum[]
  }

  /**
   * FinancingOffer findMany
   */
  export type FinancingOfferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancingOffer
     */
    select?: FinancingOfferSelect<ExtArgs> | null
    /**
     * Filter, which FinancingOffers to fetch.
     */
    where?: FinancingOfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancingOffers to fetch.
     */
    orderBy?: FinancingOfferOrderByWithRelationInput | FinancingOfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FinancingOffers.
     */
    cursor?: FinancingOfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancingOffers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancingOffers.
     */
    skip?: number
    distinct?: FinancingOfferScalarFieldEnum | FinancingOfferScalarFieldEnum[]
  }

  /**
   * FinancingOffer create
   */
  export type FinancingOfferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancingOffer
     */
    select?: FinancingOfferSelect<ExtArgs> | null
    /**
     * The data needed to create a FinancingOffer.
     */
    data: XOR<FinancingOfferCreateInput, FinancingOfferUncheckedCreateInput>
  }

  /**
   * FinancingOffer createMany
   */
  export type FinancingOfferCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FinancingOffers.
     */
    data: FinancingOfferCreateManyInput | FinancingOfferCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FinancingOffer createManyAndReturn
   */
  export type FinancingOfferCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancingOffer
     */
    select?: FinancingOfferSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FinancingOffers.
     */
    data: FinancingOfferCreateManyInput | FinancingOfferCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FinancingOffer update
   */
  export type FinancingOfferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancingOffer
     */
    select?: FinancingOfferSelect<ExtArgs> | null
    /**
     * The data needed to update a FinancingOffer.
     */
    data: XOR<FinancingOfferUpdateInput, FinancingOfferUncheckedUpdateInput>
    /**
     * Choose, which FinancingOffer to update.
     */
    where: FinancingOfferWhereUniqueInput
  }

  /**
   * FinancingOffer updateMany
   */
  export type FinancingOfferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FinancingOffers.
     */
    data: XOR<FinancingOfferUpdateManyMutationInput, FinancingOfferUncheckedUpdateManyInput>
    /**
     * Filter which FinancingOffers to update
     */
    where?: FinancingOfferWhereInput
  }

  /**
   * FinancingOffer upsert
   */
  export type FinancingOfferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancingOffer
     */
    select?: FinancingOfferSelect<ExtArgs> | null
    /**
     * The filter to search for the FinancingOffer to update in case it exists.
     */
    where: FinancingOfferWhereUniqueInput
    /**
     * In case the FinancingOffer found by the `where` argument doesn't exist, create a new FinancingOffer with this data.
     */
    create: XOR<FinancingOfferCreateInput, FinancingOfferUncheckedCreateInput>
    /**
     * In case the FinancingOffer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FinancingOfferUpdateInput, FinancingOfferUncheckedUpdateInput>
  }

  /**
   * FinancingOffer delete
   */
  export type FinancingOfferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancingOffer
     */
    select?: FinancingOfferSelect<ExtArgs> | null
    /**
     * Filter which FinancingOffer to delete.
     */
    where: FinancingOfferWhereUniqueInput
  }

  /**
   * FinancingOffer deleteMany
   */
  export type FinancingOfferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinancingOffers to delete
     */
    where?: FinancingOfferWhereInput
  }

  /**
   * FinancingOffer without action
   */
  export type FinancingOfferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancingOffer
     */
    select?: FinancingOfferSelect<ExtArgs> | null
  }


  /**
   * Model CarbonEstimate
   */

  export type AggregateCarbonEstimate = {
    _count: CarbonEstimateCountAggregateOutputType | null
    _avg: CarbonEstimateAvgAggregateOutputType | null
    _sum: CarbonEstimateSumAggregateOutputType | null
    _min: CarbonEstimateMinAggregateOutputType | null
    _max: CarbonEstimateMaxAggregateOutputType | null
  }

  export type CarbonEstimateAvgAggregateOutputType = {
    amount: number | null
  }

  export type CarbonEstimateSumAggregateOutputType = {
    amount: number | null
  }

  export type CarbonEstimateMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    amount: number | null
    unit: string | null
    source: string | null
    category: string | null
    timestamp: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CarbonEstimateMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    amount: number | null
    unit: string | null
    source: string | null
    category: string | null
    timestamp: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CarbonEstimateCountAggregateOutputType = {
    id: number
    organizationId: number
    amount: number
    unit: number
    source: number
    category: number
    timestamp: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CarbonEstimateAvgAggregateInputType = {
    amount?: true
  }

  export type CarbonEstimateSumAggregateInputType = {
    amount?: true
  }

  export type CarbonEstimateMinAggregateInputType = {
    id?: true
    organizationId?: true
    amount?: true
    unit?: true
    source?: true
    category?: true
    timestamp?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CarbonEstimateMaxAggregateInputType = {
    id?: true
    organizationId?: true
    amount?: true
    unit?: true
    source?: true
    category?: true
    timestamp?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CarbonEstimateCountAggregateInputType = {
    id?: true
    organizationId?: true
    amount?: true
    unit?: true
    source?: true
    category?: true
    timestamp?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CarbonEstimateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CarbonEstimate to aggregate.
     */
    where?: CarbonEstimateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CarbonEstimates to fetch.
     */
    orderBy?: CarbonEstimateOrderByWithRelationInput | CarbonEstimateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CarbonEstimateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CarbonEstimates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CarbonEstimates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CarbonEstimates
    **/
    _count?: true | CarbonEstimateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CarbonEstimateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CarbonEstimateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CarbonEstimateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CarbonEstimateMaxAggregateInputType
  }

  export type GetCarbonEstimateAggregateType<T extends CarbonEstimateAggregateArgs> = {
        [P in keyof T & keyof AggregateCarbonEstimate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCarbonEstimate[P]>
      : GetScalarType<T[P], AggregateCarbonEstimate[P]>
  }




  export type CarbonEstimateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CarbonEstimateWhereInput
    orderBy?: CarbonEstimateOrderByWithAggregationInput | CarbonEstimateOrderByWithAggregationInput[]
    by: CarbonEstimateScalarFieldEnum[] | CarbonEstimateScalarFieldEnum
    having?: CarbonEstimateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CarbonEstimateCountAggregateInputType | true
    _avg?: CarbonEstimateAvgAggregateInputType
    _sum?: CarbonEstimateSumAggregateInputType
    _min?: CarbonEstimateMinAggregateInputType
    _max?: CarbonEstimateMaxAggregateInputType
  }

  export type CarbonEstimateGroupByOutputType = {
    id: string
    organizationId: string
    amount: number
    unit: string
    source: string
    category: string
    timestamp: Date
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: CarbonEstimateCountAggregateOutputType | null
    _avg: CarbonEstimateAvgAggregateOutputType | null
    _sum: CarbonEstimateSumAggregateOutputType | null
    _min: CarbonEstimateMinAggregateOutputType | null
    _max: CarbonEstimateMaxAggregateOutputType | null
  }

  type GetCarbonEstimateGroupByPayload<T extends CarbonEstimateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CarbonEstimateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CarbonEstimateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CarbonEstimateGroupByOutputType[P]>
            : GetScalarType<T[P], CarbonEstimateGroupByOutputType[P]>
        }
      >
    >


  export type CarbonEstimateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    amount?: boolean
    unit?: boolean
    source?: boolean
    category?: boolean
    timestamp?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["carbonEstimate"]>

  export type CarbonEstimateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    amount?: boolean
    unit?: boolean
    source?: boolean
    category?: boolean
    timestamp?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["carbonEstimate"]>

  export type CarbonEstimateSelectScalar = {
    id?: boolean
    organizationId?: boolean
    amount?: boolean
    unit?: boolean
    source?: boolean
    category?: boolean
    timestamp?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CarbonEstimateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type CarbonEstimateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $CarbonEstimatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CarbonEstimate"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string
      amount: number
      unit: string
      source: string
      category: string
      timestamp: Date
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["carbonEstimate"]>
    composites: {}
  }

  type CarbonEstimateGetPayload<S extends boolean | null | undefined | CarbonEstimateDefaultArgs> = $Result.GetResult<Prisma.$CarbonEstimatePayload, S>

  type CarbonEstimateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CarbonEstimateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CarbonEstimateCountAggregateInputType | true
    }

  export interface CarbonEstimateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CarbonEstimate'], meta: { name: 'CarbonEstimate' } }
    /**
     * Find zero or one CarbonEstimate that matches the filter.
     * @param {CarbonEstimateFindUniqueArgs} args - Arguments to find a CarbonEstimate
     * @example
     * // Get one CarbonEstimate
     * const carbonEstimate = await prisma.carbonEstimate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CarbonEstimateFindUniqueArgs>(args: SelectSubset<T, CarbonEstimateFindUniqueArgs<ExtArgs>>): Prisma__CarbonEstimateClient<$Result.GetResult<Prisma.$CarbonEstimatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CarbonEstimate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CarbonEstimateFindUniqueOrThrowArgs} args - Arguments to find a CarbonEstimate
     * @example
     * // Get one CarbonEstimate
     * const carbonEstimate = await prisma.carbonEstimate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CarbonEstimateFindUniqueOrThrowArgs>(args: SelectSubset<T, CarbonEstimateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CarbonEstimateClient<$Result.GetResult<Prisma.$CarbonEstimatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CarbonEstimate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarbonEstimateFindFirstArgs} args - Arguments to find a CarbonEstimate
     * @example
     * // Get one CarbonEstimate
     * const carbonEstimate = await prisma.carbonEstimate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CarbonEstimateFindFirstArgs>(args?: SelectSubset<T, CarbonEstimateFindFirstArgs<ExtArgs>>): Prisma__CarbonEstimateClient<$Result.GetResult<Prisma.$CarbonEstimatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CarbonEstimate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarbonEstimateFindFirstOrThrowArgs} args - Arguments to find a CarbonEstimate
     * @example
     * // Get one CarbonEstimate
     * const carbonEstimate = await prisma.carbonEstimate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CarbonEstimateFindFirstOrThrowArgs>(args?: SelectSubset<T, CarbonEstimateFindFirstOrThrowArgs<ExtArgs>>): Prisma__CarbonEstimateClient<$Result.GetResult<Prisma.$CarbonEstimatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CarbonEstimates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarbonEstimateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CarbonEstimates
     * const carbonEstimates = await prisma.carbonEstimate.findMany()
     * 
     * // Get first 10 CarbonEstimates
     * const carbonEstimates = await prisma.carbonEstimate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const carbonEstimateWithIdOnly = await prisma.carbonEstimate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CarbonEstimateFindManyArgs>(args?: SelectSubset<T, CarbonEstimateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CarbonEstimatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CarbonEstimate.
     * @param {CarbonEstimateCreateArgs} args - Arguments to create a CarbonEstimate.
     * @example
     * // Create one CarbonEstimate
     * const CarbonEstimate = await prisma.carbonEstimate.create({
     *   data: {
     *     // ... data to create a CarbonEstimate
     *   }
     * })
     * 
     */
    create<T extends CarbonEstimateCreateArgs>(args: SelectSubset<T, CarbonEstimateCreateArgs<ExtArgs>>): Prisma__CarbonEstimateClient<$Result.GetResult<Prisma.$CarbonEstimatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CarbonEstimates.
     * @param {CarbonEstimateCreateManyArgs} args - Arguments to create many CarbonEstimates.
     * @example
     * // Create many CarbonEstimates
     * const carbonEstimate = await prisma.carbonEstimate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CarbonEstimateCreateManyArgs>(args?: SelectSubset<T, CarbonEstimateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CarbonEstimates and returns the data saved in the database.
     * @param {CarbonEstimateCreateManyAndReturnArgs} args - Arguments to create many CarbonEstimates.
     * @example
     * // Create many CarbonEstimates
     * const carbonEstimate = await prisma.carbonEstimate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CarbonEstimates and only return the `id`
     * const carbonEstimateWithIdOnly = await prisma.carbonEstimate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CarbonEstimateCreateManyAndReturnArgs>(args?: SelectSubset<T, CarbonEstimateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CarbonEstimatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CarbonEstimate.
     * @param {CarbonEstimateDeleteArgs} args - Arguments to delete one CarbonEstimate.
     * @example
     * // Delete one CarbonEstimate
     * const CarbonEstimate = await prisma.carbonEstimate.delete({
     *   where: {
     *     // ... filter to delete one CarbonEstimate
     *   }
     * })
     * 
     */
    delete<T extends CarbonEstimateDeleteArgs>(args: SelectSubset<T, CarbonEstimateDeleteArgs<ExtArgs>>): Prisma__CarbonEstimateClient<$Result.GetResult<Prisma.$CarbonEstimatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CarbonEstimate.
     * @param {CarbonEstimateUpdateArgs} args - Arguments to update one CarbonEstimate.
     * @example
     * // Update one CarbonEstimate
     * const carbonEstimate = await prisma.carbonEstimate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CarbonEstimateUpdateArgs>(args: SelectSubset<T, CarbonEstimateUpdateArgs<ExtArgs>>): Prisma__CarbonEstimateClient<$Result.GetResult<Prisma.$CarbonEstimatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CarbonEstimates.
     * @param {CarbonEstimateDeleteManyArgs} args - Arguments to filter CarbonEstimates to delete.
     * @example
     * // Delete a few CarbonEstimates
     * const { count } = await prisma.carbonEstimate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CarbonEstimateDeleteManyArgs>(args?: SelectSubset<T, CarbonEstimateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CarbonEstimates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarbonEstimateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CarbonEstimates
     * const carbonEstimate = await prisma.carbonEstimate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CarbonEstimateUpdateManyArgs>(args: SelectSubset<T, CarbonEstimateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CarbonEstimate.
     * @param {CarbonEstimateUpsertArgs} args - Arguments to update or create a CarbonEstimate.
     * @example
     * // Update or create a CarbonEstimate
     * const carbonEstimate = await prisma.carbonEstimate.upsert({
     *   create: {
     *     // ... data to create a CarbonEstimate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CarbonEstimate we want to update
     *   }
     * })
     */
    upsert<T extends CarbonEstimateUpsertArgs>(args: SelectSubset<T, CarbonEstimateUpsertArgs<ExtArgs>>): Prisma__CarbonEstimateClient<$Result.GetResult<Prisma.$CarbonEstimatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CarbonEstimates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarbonEstimateCountArgs} args - Arguments to filter CarbonEstimates to count.
     * @example
     * // Count the number of CarbonEstimates
     * const count = await prisma.carbonEstimate.count({
     *   where: {
     *     // ... the filter for the CarbonEstimates we want to count
     *   }
     * })
    **/
    count<T extends CarbonEstimateCountArgs>(
      args?: Subset<T, CarbonEstimateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CarbonEstimateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CarbonEstimate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarbonEstimateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CarbonEstimateAggregateArgs>(args: Subset<T, CarbonEstimateAggregateArgs>): Prisma.PrismaPromise<GetCarbonEstimateAggregateType<T>>

    /**
     * Group by CarbonEstimate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarbonEstimateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CarbonEstimateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CarbonEstimateGroupByArgs['orderBy'] }
        : { orderBy?: CarbonEstimateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CarbonEstimateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCarbonEstimateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CarbonEstimate model
   */
  readonly fields: CarbonEstimateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CarbonEstimate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CarbonEstimateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CarbonEstimate model
   */ 
  interface CarbonEstimateFieldRefs {
    readonly id: FieldRef<"CarbonEstimate", 'String'>
    readonly organizationId: FieldRef<"CarbonEstimate", 'String'>
    readonly amount: FieldRef<"CarbonEstimate", 'Float'>
    readonly unit: FieldRef<"CarbonEstimate", 'String'>
    readonly source: FieldRef<"CarbonEstimate", 'String'>
    readonly category: FieldRef<"CarbonEstimate", 'String'>
    readonly timestamp: FieldRef<"CarbonEstimate", 'DateTime'>
    readonly metadata: FieldRef<"CarbonEstimate", 'Json'>
    readonly createdAt: FieldRef<"CarbonEstimate", 'DateTime'>
    readonly updatedAt: FieldRef<"CarbonEstimate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CarbonEstimate findUnique
   */
  export type CarbonEstimateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarbonEstimate
     */
    select?: CarbonEstimateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarbonEstimateInclude<ExtArgs> | null
    /**
     * Filter, which CarbonEstimate to fetch.
     */
    where: CarbonEstimateWhereUniqueInput
  }

  /**
   * CarbonEstimate findUniqueOrThrow
   */
  export type CarbonEstimateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarbonEstimate
     */
    select?: CarbonEstimateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarbonEstimateInclude<ExtArgs> | null
    /**
     * Filter, which CarbonEstimate to fetch.
     */
    where: CarbonEstimateWhereUniqueInput
  }

  /**
   * CarbonEstimate findFirst
   */
  export type CarbonEstimateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarbonEstimate
     */
    select?: CarbonEstimateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarbonEstimateInclude<ExtArgs> | null
    /**
     * Filter, which CarbonEstimate to fetch.
     */
    where?: CarbonEstimateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CarbonEstimates to fetch.
     */
    orderBy?: CarbonEstimateOrderByWithRelationInput | CarbonEstimateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CarbonEstimates.
     */
    cursor?: CarbonEstimateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CarbonEstimates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CarbonEstimates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CarbonEstimates.
     */
    distinct?: CarbonEstimateScalarFieldEnum | CarbonEstimateScalarFieldEnum[]
  }

  /**
   * CarbonEstimate findFirstOrThrow
   */
  export type CarbonEstimateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarbonEstimate
     */
    select?: CarbonEstimateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarbonEstimateInclude<ExtArgs> | null
    /**
     * Filter, which CarbonEstimate to fetch.
     */
    where?: CarbonEstimateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CarbonEstimates to fetch.
     */
    orderBy?: CarbonEstimateOrderByWithRelationInput | CarbonEstimateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CarbonEstimates.
     */
    cursor?: CarbonEstimateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CarbonEstimates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CarbonEstimates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CarbonEstimates.
     */
    distinct?: CarbonEstimateScalarFieldEnum | CarbonEstimateScalarFieldEnum[]
  }

  /**
   * CarbonEstimate findMany
   */
  export type CarbonEstimateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarbonEstimate
     */
    select?: CarbonEstimateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarbonEstimateInclude<ExtArgs> | null
    /**
     * Filter, which CarbonEstimates to fetch.
     */
    where?: CarbonEstimateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CarbonEstimates to fetch.
     */
    orderBy?: CarbonEstimateOrderByWithRelationInput | CarbonEstimateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CarbonEstimates.
     */
    cursor?: CarbonEstimateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CarbonEstimates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CarbonEstimates.
     */
    skip?: number
    distinct?: CarbonEstimateScalarFieldEnum | CarbonEstimateScalarFieldEnum[]
  }

  /**
   * CarbonEstimate create
   */
  export type CarbonEstimateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarbonEstimate
     */
    select?: CarbonEstimateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarbonEstimateInclude<ExtArgs> | null
    /**
     * The data needed to create a CarbonEstimate.
     */
    data: XOR<CarbonEstimateCreateInput, CarbonEstimateUncheckedCreateInput>
  }

  /**
   * CarbonEstimate createMany
   */
  export type CarbonEstimateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CarbonEstimates.
     */
    data: CarbonEstimateCreateManyInput | CarbonEstimateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CarbonEstimate createManyAndReturn
   */
  export type CarbonEstimateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarbonEstimate
     */
    select?: CarbonEstimateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CarbonEstimates.
     */
    data: CarbonEstimateCreateManyInput | CarbonEstimateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarbonEstimateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CarbonEstimate update
   */
  export type CarbonEstimateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarbonEstimate
     */
    select?: CarbonEstimateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarbonEstimateInclude<ExtArgs> | null
    /**
     * The data needed to update a CarbonEstimate.
     */
    data: XOR<CarbonEstimateUpdateInput, CarbonEstimateUncheckedUpdateInput>
    /**
     * Choose, which CarbonEstimate to update.
     */
    where: CarbonEstimateWhereUniqueInput
  }

  /**
   * CarbonEstimate updateMany
   */
  export type CarbonEstimateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CarbonEstimates.
     */
    data: XOR<CarbonEstimateUpdateManyMutationInput, CarbonEstimateUncheckedUpdateManyInput>
    /**
     * Filter which CarbonEstimates to update
     */
    where?: CarbonEstimateWhereInput
  }

  /**
   * CarbonEstimate upsert
   */
  export type CarbonEstimateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarbonEstimate
     */
    select?: CarbonEstimateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarbonEstimateInclude<ExtArgs> | null
    /**
     * The filter to search for the CarbonEstimate to update in case it exists.
     */
    where: CarbonEstimateWhereUniqueInput
    /**
     * In case the CarbonEstimate found by the `where` argument doesn't exist, create a new CarbonEstimate with this data.
     */
    create: XOR<CarbonEstimateCreateInput, CarbonEstimateUncheckedCreateInput>
    /**
     * In case the CarbonEstimate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CarbonEstimateUpdateInput, CarbonEstimateUncheckedUpdateInput>
  }

  /**
   * CarbonEstimate delete
   */
  export type CarbonEstimateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarbonEstimate
     */
    select?: CarbonEstimateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarbonEstimateInclude<ExtArgs> | null
    /**
     * Filter which CarbonEstimate to delete.
     */
    where: CarbonEstimateWhereUniqueInput
  }

  /**
   * CarbonEstimate deleteMany
   */
  export type CarbonEstimateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CarbonEstimates to delete
     */
    where?: CarbonEstimateWhereInput
  }

  /**
   * CarbonEstimate without action
   */
  export type CarbonEstimateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarbonEstimate
     */
    select?: CarbonEstimateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarbonEstimateInclude<ExtArgs> | null
  }


  /**
   * Model BillingRule
   */

  export type AggregateBillingRule = {
    _count: BillingRuleCountAggregateOutputType | null
    _avg: BillingRuleAvgAggregateOutputType | null
    _sum: BillingRuleSumAggregateOutputType | null
    _min: BillingRuleMinAggregateOutputType | null
    _max: BillingRuleMaxAggregateOutputType | null
  }

  export type BillingRuleAvgAggregateOutputType = {
    priority: number | null
  }

  export type BillingRuleSumAggregateOutputType = {
    priority: number | null
  }

  export type BillingRuleMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: string | null
    priority: number | null
    isActive: boolean | null
    organizationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BillingRuleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: string | null
    priority: number | null
    isActive: boolean | null
    organizationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BillingRuleCountAggregateOutputType = {
    id: number
    name: number
    description: number
    type: number
    conditions: number
    actions: number
    priority: number
    isActive: number
    organizationId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BillingRuleAvgAggregateInputType = {
    priority?: true
  }

  export type BillingRuleSumAggregateInputType = {
    priority?: true
  }

  export type BillingRuleMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    priority?: true
    isActive?: true
    organizationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BillingRuleMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    priority?: true
    isActive?: true
    organizationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BillingRuleCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    conditions?: true
    actions?: true
    priority?: true
    isActive?: true
    organizationId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BillingRuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillingRule to aggregate.
     */
    where?: BillingRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingRules to fetch.
     */
    orderBy?: BillingRuleOrderByWithRelationInput | BillingRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BillingRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BillingRules
    **/
    _count?: true | BillingRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BillingRuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BillingRuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BillingRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BillingRuleMaxAggregateInputType
  }

  export type GetBillingRuleAggregateType<T extends BillingRuleAggregateArgs> = {
        [P in keyof T & keyof AggregateBillingRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBillingRule[P]>
      : GetScalarType<T[P], AggregateBillingRule[P]>
  }




  export type BillingRuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillingRuleWhereInput
    orderBy?: BillingRuleOrderByWithAggregationInput | BillingRuleOrderByWithAggregationInput[]
    by: BillingRuleScalarFieldEnum[] | BillingRuleScalarFieldEnum
    having?: BillingRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BillingRuleCountAggregateInputType | true
    _avg?: BillingRuleAvgAggregateInputType
    _sum?: BillingRuleSumAggregateInputType
    _min?: BillingRuleMinAggregateInputType
    _max?: BillingRuleMaxAggregateInputType
  }

  export type BillingRuleGroupByOutputType = {
    id: string
    name: string
    description: string | null
    type: string
    conditions: JsonValue[]
    actions: JsonValue[]
    priority: number
    isActive: boolean
    organizationId: string
    createdAt: Date
    updatedAt: Date
    _count: BillingRuleCountAggregateOutputType | null
    _avg: BillingRuleAvgAggregateOutputType | null
    _sum: BillingRuleSumAggregateOutputType | null
    _min: BillingRuleMinAggregateOutputType | null
    _max: BillingRuleMaxAggregateOutputType | null
  }

  type GetBillingRuleGroupByPayload<T extends BillingRuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BillingRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BillingRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BillingRuleGroupByOutputType[P]>
            : GetScalarType<T[P], BillingRuleGroupByOutputType[P]>
        }
      >
    >


  export type BillingRuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    conditions?: boolean
    actions?: boolean
    priority?: boolean
    isActive?: boolean
    organizationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["billingRule"]>

  export type BillingRuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    conditions?: boolean
    actions?: boolean
    priority?: boolean
    isActive?: boolean
    organizationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["billingRule"]>

  export type BillingRuleSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    conditions?: boolean
    actions?: boolean
    priority?: boolean
    isActive?: boolean
    organizationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BillingRuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type BillingRuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $BillingRulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BillingRule"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      type: string
      conditions: Prisma.JsonValue[]
      actions: Prisma.JsonValue[]
      priority: number
      isActive: boolean
      organizationId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["billingRule"]>
    composites: {}
  }

  type BillingRuleGetPayload<S extends boolean | null | undefined | BillingRuleDefaultArgs> = $Result.GetResult<Prisma.$BillingRulePayload, S>

  type BillingRuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BillingRuleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BillingRuleCountAggregateInputType | true
    }

  export interface BillingRuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BillingRule'], meta: { name: 'BillingRule' } }
    /**
     * Find zero or one BillingRule that matches the filter.
     * @param {BillingRuleFindUniqueArgs} args - Arguments to find a BillingRule
     * @example
     * // Get one BillingRule
     * const billingRule = await prisma.billingRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BillingRuleFindUniqueArgs>(args: SelectSubset<T, BillingRuleFindUniqueArgs<ExtArgs>>): Prisma__BillingRuleClient<$Result.GetResult<Prisma.$BillingRulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BillingRule that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BillingRuleFindUniqueOrThrowArgs} args - Arguments to find a BillingRule
     * @example
     * // Get one BillingRule
     * const billingRule = await prisma.billingRule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BillingRuleFindUniqueOrThrowArgs>(args: SelectSubset<T, BillingRuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BillingRuleClient<$Result.GetResult<Prisma.$BillingRulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BillingRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingRuleFindFirstArgs} args - Arguments to find a BillingRule
     * @example
     * // Get one BillingRule
     * const billingRule = await prisma.billingRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BillingRuleFindFirstArgs>(args?: SelectSubset<T, BillingRuleFindFirstArgs<ExtArgs>>): Prisma__BillingRuleClient<$Result.GetResult<Prisma.$BillingRulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BillingRule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingRuleFindFirstOrThrowArgs} args - Arguments to find a BillingRule
     * @example
     * // Get one BillingRule
     * const billingRule = await prisma.billingRule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BillingRuleFindFirstOrThrowArgs>(args?: SelectSubset<T, BillingRuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__BillingRuleClient<$Result.GetResult<Prisma.$BillingRulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BillingRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingRuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BillingRules
     * const billingRules = await prisma.billingRule.findMany()
     * 
     * // Get first 10 BillingRules
     * const billingRules = await prisma.billingRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const billingRuleWithIdOnly = await prisma.billingRule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BillingRuleFindManyArgs>(args?: SelectSubset<T, BillingRuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingRulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BillingRule.
     * @param {BillingRuleCreateArgs} args - Arguments to create a BillingRule.
     * @example
     * // Create one BillingRule
     * const BillingRule = await prisma.billingRule.create({
     *   data: {
     *     // ... data to create a BillingRule
     *   }
     * })
     * 
     */
    create<T extends BillingRuleCreateArgs>(args: SelectSubset<T, BillingRuleCreateArgs<ExtArgs>>): Prisma__BillingRuleClient<$Result.GetResult<Prisma.$BillingRulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BillingRules.
     * @param {BillingRuleCreateManyArgs} args - Arguments to create many BillingRules.
     * @example
     * // Create many BillingRules
     * const billingRule = await prisma.billingRule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BillingRuleCreateManyArgs>(args?: SelectSubset<T, BillingRuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BillingRules and returns the data saved in the database.
     * @param {BillingRuleCreateManyAndReturnArgs} args - Arguments to create many BillingRules.
     * @example
     * // Create many BillingRules
     * const billingRule = await prisma.billingRule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BillingRules and only return the `id`
     * const billingRuleWithIdOnly = await prisma.billingRule.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BillingRuleCreateManyAndReturnArgs>(args?: SelectSubset<T, BillingRuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingRulePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BillingRule.
     * @param {BillingRuleDeleteArgs} args - Arguments to delete one BillingRule.
     * @example
     * // Delete one BillingRule
     * const BillingRule = await prisma.billingRule.delete({
     *   where: {
     *     // ... filter to delete one BillingRule
     *   }
     * })
     * 
     */
    delete<T extends BillingRuleDeleteArgs>(args: SelectSubset<T, BillingRuleDeleteArgs<ExtArgs>>): Prisma__BillingRuleClient<$Result.GetResult<Prisma.$BillingRulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BillingRule.
     * @param {BillingRuleUpdateArgs} args - Arguments to update one BillingRule.
     * @example
     * // Update one BillingRule
     * const billingRule = await prisma.billingRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BillingRuleUpdateArgs>(args: SelectSubset<T, BillingRuleUpdateArgs<ExtArgs>>): Prisma__BillingRuleClient<$Result.GetResult<Prisma.$BillingRulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BillingRules.
     * @param {BillingRuleDeleteManyArgs} args - Arguments to filter BillingRules to delete.
     * @example
     * // Delete a few BillingRules
     * const { count } = await prisma.billingRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BillingRuleDeleteManyArgs>(args?: SelectSubset<T, BillingRuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillingRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BillingRules
     * const billingRule = await prisma.billingRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BillingRuleUpdateManyArgs>(args: SelectSubset<T, BillingRuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BillingRule.
     * @param {BillingRuleUpsertArgs} args - Arguments to update or create a BillingRule.
     * @example
     * // Update or create a BillingRule
     * const billingRule = await prisma.billingRule.upsert({
     *   create: {
     *     // ... data to create a BillingRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BillingRule we want to update
     *   }
     * })
     */
    upsert<T extends BillingRuleUpsertArgs>(args: SelectSubset<T, BillingRuleUpsertArgs<ExtArgs>>): Prisma__BillingRuleClient<$Result.GetResult<Prisma.$BillingRulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BillingRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingRuleCountArgs} args - Arguments to filter BillingRules to count.
     * @example
     * // Count the number of BillingRules
     * const count = await prisma.billingRule.count({
     *   where: {
     *     // ... the filter for the BillingRules we want to count
     *   }
     * })
    **/
    count<T extends BillingRuleCountArgs>(
      args?: Subset<T, BillingRuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillingRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BillingRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BillingRuleAggregateArgs>(args: Subset<T, BillingRuleAggregateArgs>): Prisma.PrismaPromise<GetBillingRuleAggregateType<T>>

    /**
     * Group by BillingRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BillingRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BillingRuleGroupByArgs['orderBy'] }
        : { orderBy?: BillingRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BillingRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBillingRuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BillingRule model
   */
  readonly fields: BillingRuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BillingRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BillingRuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BillingRule model
   */ 
  interface BillingRuleFieldRefs {
    readonly id: FieldRef<"BillingRule", 'String'>
    readonly name: FieldRef<"BillingRule", 'String'>
    readonly description: FieldRef<"BillingRule", 'String'>
    readonly type: FieldRef<"BillingRule", 'String'>
    readonly conditions: FieldRef<"BillingRule", 'Json[]'>
    readonly actions: FieldRef<"BillingRule", 'Json[]'>
    readonly priority: FieldRef<"BillingRule", 'Int'>
    readonly isActive: FieldRef<"BillingRule", 'Boolean'>
    readonly organizationId: FieldRef<"BillingRule", 'String'>
    readonly createdAt: FieldRef<"BillingRule", 'DateTime'>
    readonly updatedAt: FieldRef<"BillingRule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BillingRule findUnique
   */
  export type BillingRuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingRule
     */
    select?: BillingRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingRuleInclude<ExtArgs> | null
    /**
     * Filter, which BillingRule to fetch.
     */
    where: BillingRuleWhereUniqueInput
  }

  /**
   * BillingRule findUniqueOrThrow
   */
  export type BillingRuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingRule
     */
    select?: BillingRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingRuleInclude<ExtArgs> | null
    /**
     * Filter, which BillingRule to fetch.
     */
    where: BillingRuleWhereUniqueInput
  }

  /**
   * BillingRule findFirst
   */
  export type BillingRuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingRule
     */
    select?: BillingRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingRuleInclude<ExtArgs> | null
    /**
     * Filter, which BillingRule to fetch.
     */
    where?: BillingRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingRules to fetch.
     */
    orderBy?: BillingRuleOrderByWithRelationInput | BillingRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillingRules.
     */
    cursor?: BillingRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillingRules.
     */
    distinct?: BillingRuleScalarFieldEnum | BillingRuleScalarFieldEnum[]
  }

  /**
   * BillingRule findFirstOrThrow
   */
  export type BillingRuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingRule
     */
    select?: BillingRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingRuleInclude<ExtArgs> | null
    /**
     * Filter, which BillingRule to fetch.
     */
    where?: BillingRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingRules to fetch.
     */
    orderBy?: BillingRuleOrderByWithRelationInput | BillingRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillingRules.
     */
    cursor?: BillingRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillingRules.
     */
    distinct?: BillingRuleScalarFieldEnum | BillingRuleScalarFieldEnum[]
  }

  /**
   * BillingRule findMany
   */
  export type BillingRuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingRule
     */
    select?: BillingRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingRuleInclude<ExtArgs> | null
    /**
     * Filter, which BillingRules to fetch.
     */
    where?: BillingRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingRules to fetch.
     */
    orderBy?: BillingRuleOrderByWithRelationInput | BillingRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BillingRules.
     */
    cursor?: BillingRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingRules.
     */
    skip?: number
    distinct?: BillingRuleScalarFieldEnum | BillingRuleScalarFieldEnum[]
  }

  /**
   * BillingRule create
   */
  export type BillingRuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingRule
     */
    select?: BillingRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingRuleInclude<ExtArgs> | null
    /**
     * The data needed to create a BillingRule.
     */
    data: XOR<BillingRuleCreateInput, BillingRuleUncheckedCreateInput>
  }

  /**
   * BillingRule createMany
   */
  export type BillingRuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BillingRules.
     */
    data: BillingRuleCreateManyInput | BillingRuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BillingRule createManyAndReturn
   */
  export type BillingRuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingRule
     */
    select?: BillingRuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BillingRules.
     */
    data: BillingRuleCreateManyInput | BillingRuleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingRuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BillingRule update
   */
  export type BillingRuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingRule
     */
    select?: BillingRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingRuleInclude<ExtArgs> | null
    /**
     * The data needed to update a BillingRule.
     */
    data: XOR<BillingRuleUpdateInput, BillingRuleUncheckedUpdateInput>
    /**
     * Choose, which BillingRule to update.
     */
    where: BillingRuleWhereUniqueInput
  }

  /**
   * BillingRule updateMany
   */
  export type BillingRuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BillingRules.
     */
    data: XOR<BillingRuleUpdateManyMutationInput, BillingRuleUncheckedUpdateManyInput>
    /**
     * Filter which BillingRules to update
     */
    where?: BillingRuleWhereInput
  }

  /**
   * BillingRule upsert
   */
  export type BillingRuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingRule
     */
    select?: BillingRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingRuleInclude<ExtArgs> | null
    /**
     * The filter to search for the BillingRule to update in case it exists.
     */
    where: BillingRuleWhereUniqueInput
    /**
     * In case the BillingRule found by the `where` argument doesn't exist, create a new BillingRule with this data.
     */
    create: XOR<BillingRuleCreateInput, BillingRuleUncheckedCreateInput>
    /**
     * In case the BillingRule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BillingRuleUpdateInput, BillingRuleUncheckedUpdateInput>
  }

  /**
   * BillingRule delete
   */
  export type BillingRuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingRule
     */
    select?: BillingRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingRuleInclude<ExtArgs> | null
    /**
     * Filter which BillingRule to delete.
     */
    where: BillingRuleWhereUniqueInput
  }

  /**
   * BillingRule deleteMany
   */
  export type BillingRuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillingRules to delete
     */
    where?: BillingRuleWhereInput
  }

  /**
   * BillingRule without action
   */
  export type BillingRuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingRule
     */
    select?: BillingRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingRuleInclude<ExtArgs> | null
  }


  /**
   * Model BillingRuleTemplate
   */

  export type AggregateBillingRuleTemplate = {
    _count: BillingRuleTemplateCountAggregateOutputType | null
    _min: BillingRuleTemplateMinAggregateOutputType | null
    _max: BillingRuleTemplateMaxAggregateOutputType | null
  }

  export type BillingRuleTemplateMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: string | null
    isDefault: boolean | null
    organizationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BillingRuleTemplateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: string | null
    isDefault: boolean | null
    organizationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BillingRuleTemplateCountAggregateOutputType = {
    id: number
    name: number
    description: number
    type: number
    conditions: number
    actions: number
    isDefault: number
    organizationId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BillingRuleTemplateMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    isDefault?: true
    organizationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BillingRuleTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    isDefault?: true
    organizationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BillingRuleTemplateCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    conditions?: true
    actions?: true
    isDefault?: true
    organizationId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BillingRuleTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillingRuleTemplate to aggregate.
     */
    where?: BillingRuleTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingRuleTemplates to fetch.
     */
    orderBy?: BillingRuleTemplateOrderByWithRelationInput | BillingRuleTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BillingRuleTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingRuleTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingRuleTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BillingRuleTemplates
    **/
    _count?: true | BillingRuleTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BillingRuleTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BillingRuleTemplateMaxAggregateInputType
  }

  export type GetBillingRuleTemplateAggregateType<T extends BillingRuleTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateBillingRuleTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBillingRuleTemplate[P]>
      : GetScalarType<T[P], AggregateBillingRuleTemplate[P]>
  }




  export type BillingRuleTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillingRuleTemplateWhereInput
    orderBy?: BillingRuleTemplateOrderByWithAggregationInput | BillingRuleTemplateOrderByWithAggregationInput[]
    by: BillingRuleTemplateScalarFieldEnum[] | BillingRuleTemplateScalarFieldEnum
    having?: BillingRuleTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BillingRuleTemplateCountAggregateInputType | true
    _min?: BillingRuleTemplateMinAggregateInputType
    _max?: BillingRuleTemplateMaxAggregateInputType
  }

  export type BillingRuleTemplateGroupByOutputType = {
    id: string
    name: string
    description: string | null
    type: string
    conditions: JsonValue[]
    actions: JsonValue[]
    isDefault: boolean
    organizationId: string
    createdAt: Date
    updatedAt: Date
    _count: BillingRuleTemplateCountAggregateOutputType | null
    _min: BillingRuleTemplateMinAggregateOutputType | null
    _max: BillingRuleTemplateMaxAggregateOutputType | null
  }

  type GetBillingRuleTemplateGroupByPayload<T extends BillingRuleTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BillingRuleTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BillingRuleTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BillingRuleTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], BillingRuleTemplateGroupByOutputType[P]>
        }
      >
    >


  export type BillingRuleTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    conditions?: boolean
    actions?: boolean
    isDefault?: boolean
    organizationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["billingRuleTemplate"]>

  export type BillingRuleTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    conditions?: boolean
    actions?: boolean
    isDefault?: boolean
    organizationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["billingRuleTemplate"]>

  export type BillingRuleTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    conditions?: boolean
    actions?: boolean
    isDefault?: boolean
    organizationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BillingRuleTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type BillingRuleTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $BillingRuleTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BillingRuleTemplate"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      type: string
      conditions: Prisma.JsonValue[]
      actions: Prisma.JsonValue[]
      isDefault: boolean
      organizationId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["billingRuleTemplate"]>
    composites: {}
  }

  type BillingRuleTemplateGetPayload<S extends boolean | null | undefined | BillingRuleTemplateDefaultArgs> = $Result.GetResult<Prisma.$BillingRuleTemplatePayload, S>

  type BillingRuleTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BillingRuleTemplateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BillingRuleTemplateCountAggregateInputType | true
    }

  export interface BillingRuleTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BillingRuleTemplate'], meta: { name: 'BillingRuleTemplate' } }
    /**
     * Find zero or one BillingRuleTemplate that matches the filter.
     * @param {BillingRuleTemplateFindUniqueArgs} args - Arguments to find a BillingRuleTemplate
     * @example
     * // Get one BillingRuleTemplate
     * const billingRuleTemplate = await prisma.billingRuleTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BillingRuleTemplateFindUniqueArgs>(args: SelectSubset<T, BillingRuleTemplateFindUniqueArgs<ExtArgs>>): Prisma__BillingRuleTemplateClient<$Result.GetResult<Prisma.$BillingRuleTemplatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BillingRuleTemplate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BillingRuleTemplateFindUniqueOrThrowArgs} args - Arguments to find a BillingRuleTemplate
     * @example
     * // Get one BillingRuleTemplate
     * const billingRuleTemplate = await prisma.billingRuleTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BillingRuleTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, BillingRuleTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BillingRuleTemplateClient<$Result.GetResult<Prisma.$BillingRuleTemplatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BillingRuleTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingRuleTemplateFindFirstArgs} args - Arguments to find a BillingRuleTemplate
     * @example
     * // Get one BillingRuleTemplate
     * const billingRuleTemplate = await prisma.billingRuleTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BillingRuleTemplateFindFirstArgs>(args?: SelectSubset<T, BillingRuleTemplateFindFirstArgs<ExtArgs>>): Prisma__BillingRuleTemplateClient<$Result.GetResult<Prisma.$BillingRuleTemplatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BillingRuleTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingRuleTemplateFindFirstOrThrowArgs} args - Arguments to find a BillingRuleTemplate
     * @example
     * // Get one BillingRuleTemplate
     * const billingRuleTemplate = await prisma.billingRuleTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BillingRuleTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, BillingRuleTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__BillingRuleTemplateClient<$Result.GetResult<Prisma.$BillingRuleTemplatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BillingRuleTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingRuleTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BillingRuleTemplates
     * const billingRuleTemplates = await prisma.billingRuleTemplate.findMany()
     * 
     * // Get first 10 BillingRuleTemplates
     * const billingRuleTemplates = await prisma.billingRuleTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const billingRuleTemplateWithIdOnly = await prisma.billingRuleTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BillingRuleTemplateFindManyArgs>(args?: SelectSubset<T, BillingRuleTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingRuleTemplatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BillingRuleTemplate.
     * @param {BillingRuleTemplateCreateArgs} args - Arguments to create a BillingRuleTemplate.
     * @example
     * // Create one BillingRuleTemplate
     * const BillingRuleTemplate = await prisma.billingRuleTemplate.create({
     *   data: {
     *     // ... data to create a BillingRuleTemplate
     *   }
     * })
     * 
     */
    create<T extends BillingRuleTemplateCreateArgs>(args: SelectSubset<T, BillingRuleTemplateCreateArgs<ExtArgs>>): Prisma__BillingRuleTemplateClient<$Result.GetResult<Prisma.$BillingRuleTemplatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BillingRuleTemplates.
     * @param {BillingRuleTemplateCreateManyArgs} args - Arguments to create many BillingRuleTemplates.
     * @example
     * // Create many BillingRuleTemplates
     * const billingRuleTemplate = await prisma.billingRuleTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BillingRuleTemplateCreateManyArgs>(args?: SelectSubset<T, BillingRuleTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BillingRuleTemplates and returns the data saved in the database.
     * @param {BillingRuleTemplateCreateManyAndReturnArgs} args - Arguments to create many BillingRuleTemplates.
     * @example
     * // Create many BillingRuleTemplates
     * const billingRuleTemplate = await prisma.billingRuleTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BillingRuleTemplates and only return the `id`
     * const billingRuleTemplateWithIdOnly = await prisma.billingRuleTemplate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BillingRuleTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, BillingRuleTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingRuleTemplatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BillingRuleTemplate.
     * @param {BillingRuleTemplateDeleteArgs} args - Arguments to delete one BillingRuleTemplate.
     * @example
     * // Delete one BillingRuleTemplate
     * const BillingRuleTemplate = await prisma.billingRuleTemplate.delete({
     *   where: {
     *     // ... filter to delete one BillingRuleTemplate
     *   }
     * })
     * 
     */
    delete<T extends BillingRuleTemplateDeleteArgs>(args: SelectSubset<T, BillingRuleTemplateDeleteArgs<ExtArgs>>): Prisma__BillingRuleTemplateClient<$Result.GetResult<Prisma.$BillingRuleTemplatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BillingRuleTemplate.
     * @param {BillingRuleTemplateUpdateArgs} args - Arguments to update one BillingRuleTemplate.
     * @example
     * // Update one BillingRuleTemplate
     * const billingRuleTemplate = await prisma.billingRuleTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BillingRuleTemplateUpdateArgs>(args: SelectSubset<T, BillingRuleTemplateUpdateArgs<ExtArgs>>): Prisma__BillingRuleTemplateClient<$Result.GetResult<Prisma.$BillingRuleTemplatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BillingRuleTemplates.
     * @param {BillingRuleTemplateDeleteManyArgs} args - Arguments to filter BillingRuleTemplates to delete.
     * @example
     * // Delete a few BillingRuleTemplates
     * const { count } = await prisma.billingRuleTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BillingRuleTemplateDeleteManyArgs>(args?: SelectSubset<T, BillingRuleTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillingRuleTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingRuleTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BillingRuleTemplates
     * const billingRuleTemplate = await prisma.billingRuleTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BillingRuleTemplateUpdateManyArgs>(args: SelectSubset<T, BillingRuleTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BillingRuleTemplate.
     * @param {BillingRuleTemplateUpsertArgs} args - Arguments to update or create a BillingRuleTemplate.
     * @example
     * // Update or create a BillingRuleTemplate
     * const billingRuleTemplate = await prisma.billingRuleTemplate.upsert({
     *   create: {
     *     // ... data to create a BillingRuleTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BillingRuleTemplate we want to update
     *   }
     * })
     */
    upsert<T extends BillingRuleTemplateUpsertArgs>(args: SelectSubset<T, BillingRuleTemplateUpsertArgs<ExtArgs>>): Prisma__BillingRuleTemplateClient<$Result.GetResult<Prisma.$BillingRuleTemplatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BillingRuleTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingRuleTemplateCountArgs} args - Arguments to filter BillingRuleTemplates to count.
     * @example
     * // Count the number of BillingRuleTemplates
     * const count = await prisma.billingRuleTemplate.count({
     *   where: {
     *     // ... the filter for the BillingRuleTemplates we want to count
     *   }
     * })
    **/
    count<T extends BillingRuleTemplateCountArgs>(
      args?: Subset<T, BillingRuleTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillingRuleTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BillingRuleTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingRuleTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BillingRuleTemplateAggregateArgs>(args: Subset<T, BillingRuleTemplateAggregateArgs>): Prisma.PrismaPromise<GetBillingRuleTemplateAggregateType<T>>

    /**
     * Group by BillingRuleTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingRuleTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BillingRuleTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BillingRuleTemplateGroupByArgs['orderBy'] }
        : { orderBy?: BillingRuleTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BillingRuleTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBillingRuleTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BillingRuleTemplate model
   */
  readonly fields: BillingRuleTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BillingRuleTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BillingRuleTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BillingRuleTemplate model
   */ 
  interface BillingRuleTemplateFieldRefs {
    readonly id: FieldRef<"BillingRuleTemplate", 'String'>
    readonly name: FieldRef<"BillingRuleTemplate", 'String'>
    readonly description: FieldRef<"BillingRuleTemplate", 'String'>
    readonly type: FieldRef<"BillingRuleTemplate", 'String'>
    readonly conditions: FieldRef<"BillingRuleTemplate", 'Json[]'>
    readonly actions: FieldRef<"BillingRuleTemplate", 'Json[]'>
    readonly isDefault: FieldRef<"BillingRuleTemplate", 'Boolean'>
    readonly organizationId: FieldRef<"BillingRuleTemplate", 'String'>
    readonly createdAt: FieldRef<"BillingRuleTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"BillingRuleTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BillingRuleTemplate findUnique
   */
  export type BillingRuleTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingRuleTemplate
     */
    select?: BillingRuleTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingRuleTemplateInclude<ExtArgs> | null
    /**
     * Filter, which BillingRuleTemplate to fetch.
     */
    where: BillingRuleTemplateWhereUniqueInput
  }

  /**
   * BillingRuleTemplate findUniqueOrThrow
   */
  export type BillingRuleTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingRuleTemplate
     */
    select?: BillingRuleTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingRuleTemplateInclude<ExtArgs> | null
    /**
     * Filter, which BillingRuleTemplate to fetch.
     */
    where: BillingRuleTemplateWhereUniqueInput
  }

  /**
   * BillingRuleTemplate findFirst
   */
  export type BillingRuleTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingRuleTemplate
     */
    select?: BillingRuleTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingRuleTemplateInclude<ExtArgs> | null
    /**
     * Filter, which BillingRuleTemplate to fetch.
     */
    where?: BillingRuleTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingRuleTemplates to fetch.
     */
    orderBy?: BillingRuleTemplateOrderByWithRelationInput | BillingRuleTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillingRuleTemplates.
     */
    cursor?: BillingRuleTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingRuleTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingRuleTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillingRuleTemplates.
     */
    distinct?: BillingRuleTemplateScalarFieldEnum | BillingRuleTemplateScalarFieldEnum[]
  }

  /**
   * BillingRuleTemplate findFirstOrThrow
   */
  export type BillingRuleTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingRuleTemplate
     */
    select?: BillingRuleTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingRuleTemplateInclude<ExtArgs> | null
    /**
     * Filter, which BillingRuleTemplate to fetch.
     */
    where?: BillingRuleTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingRuleTemplates to fetch.
     */
    orderBy?: BillingRuleTemplateOrderByWithRelationInput | BillingRuleTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillingRuleTemplates.
     */
    cursor?: BillingRuleTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingRuleTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingRuleTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillingRuleTemplates.
     */
    distinct?: BillingRuleTemplateScalarFieldEnum | BillingRuleTemplateScalarFieldEnum[]
  }

  /**
   * BillingRuleTemplate findMany
   */
  export type BillingRuleTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingRuleTemplate
     */
    select?: BillingRuleTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingRuleTemplateInclude<ExtArgs> | null
    /**
     * Filter, which BillingRuleTemplates to fetch.
     */
    where?: BillingRuleTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingRuleTemplates to fetch.
     */
    orderBy?: BillingRuleTemplateOrderByWithRelationInput | BillingRuleTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BillingRuleTemplates.
     */
    cursor?: BillingRuleTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingRuleTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingRuleTemplates.
     */
    skip?: number
    distinct?: BillingRuleTemplateScalarFieldEnum | BillingRuleTemplateScalarFieldEnum[]
  }

  /**
   * BillingRuleTemplate create
   */
  export type BillingRuleTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingRuleTemplate
     */
    select?: BillingRuleTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingRuleTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a BillingRuleTemplate.
     */
    data: XOR<BillingRuleTemplateCreateInput, BillingRuleTemplateUncheckedCreateInput>
  }

  /**
   * BillingRuleTemplate createMany
   */
  export type BillingRuleTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BillingRuleTemplates.
     */
    data: BillingRuleTemplateCreateManyInput | BillingRuleTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BillingRuleTemplate createManyAndReturn
   */
  export type BillingRuleTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingRuleTemplate
     */
    select?: BillingRuleTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BillingRuleTemplates.
     */
    data: BillingRuleTemplateCreateManyInput | BillingRuleTemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingRuleTemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BillingRuleTemplate update
   */
  export type BillingRuleTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingRuleTemplate
     */
    select?: BillingRuleTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingRuleTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a BillingRuleTemplate.
     */
    data: XOR<BillingRuleTemplateUpdateInput, BillingRuleTemplateUncheckedUpdateInput>
    /**
     * Choose, which BillingRuleTemplate to update.
     */
    where: BillingRuleTemplateWhereUniqueInput
  }

  /**
   * BillingRuleTemplate updateMany
   */
  export type BillingRuleTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BillingRuleTemplates.
     */
    data: XOR<BillingRuleTemplateUpdateManyMutationInput, BillingRuleTemplateUncheckedUpdateManyInput>
    /**
     * Filter which BillingRuleTemplates to update
     */
    where?: BillingRuleTemplateWhereInput
  }

  /**
   * BillingRuleTemplate upsert
   */
  export type BillingRuleTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingRuleTemplate
     */
    select?: BillingRuleTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingRuleTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the BillingRuleTemplate to update in case it exists.
     */
    where: BillingRuleTemplateWhereUniqueInput
    /**
     * In case the BillingRuleTemplate found by the `where` argument doesn't exist, create a new BillingRuleTemplate with this data.
     */
    create: XOR<BillingRuleTemplateCreateInput, BillingRuleTemplateUncheckedCreateInput>
    /**
     * In case the BillingRuleTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BillingRuleTemplateUpdateInput, BillingRuleTemplateUncheckedUpdateInput>
  }

  /**
   * BillingRuleTemplate delete
   */
  export type BillingRuleTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingRuleTemplate
     */
    select?: BillingRuleTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingRuleTemplateInclude<ExtArgs> | null
    /**
     * Filter which BillingRuleTemplate to delete.
     */
    where: BillingRuleTemplateWhereUniqueInput
  }

  /**
   * BillingRuleTemplate deleteMany
   */
  export type BillingRuleTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillingRuleTemplates to delete
     */
    where?: BillingRuleTemplateWhereInput
  }

  /**
   * BillingRuleTemplate without action
   */
  export type BillingRuleTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingRuleTemplate
     */
    select?: BillingRuleTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingRuleTemplateInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    amount: number | null
  }

  export type OrderSumAggregateOutputType = {
    amount: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    customerId: string | null
    amount: number | null
    currency: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    customerId: string | null
    amount: number | null
    currency: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    organizationId: number
    customerId: number
    amount: number
    currency: number
    status: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    amount?: true
  }

  export type OrderSumAggregateInputType = {
    amount?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    organizationId?: true
    customerId?: true
    amount?: true
    currency?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    organizationId?: true
    customerId?: true
    amount?: true
    currency?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    organizationId?: true
    customerId?: true
    amount?: true
    currency?: true
    status?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: string
    organizationId: string
    customerId: string
    amount: number
    currency: string
    status: string
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    customerId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    payments?: boolean | Order$paymentsArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    customerId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    organizationId?: boolean
    customerId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    payments?: boolean | Order$paymentsArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      customer: Prisma.$CustomerPayload<ExtArgs>
      payments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string
      customerId: string
      amount: number
      currency: string
      status: string
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    payments<T extends Order$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Order$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */ 
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'String'>
    readonly organizationId: FieldRef<"Order", 'String'>
    readonly customerId: FieldRef<"Order", 'String'>
    readonly amount: FieldRef<"Order", 'Float'>
    readonly currency: FieldRef<"Order", 'String'>
    readonly status: FieldRef<"Order", 'String'>
    readonly metadata: FieldRef<"Order", 'Json'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
  }

  /**
   * Order.payments
   */
  export type Order$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model PriceHistory
   */

  export type AggregatePriceHistory = {
    _count: PriceHistoryCountAggregateOutputType | null
    _avg: PriceHistoryAvgAggregateOutputType | null
    _sum: PriceHistorySumAggregateOutputType | null
    _min: PriceHistoryMinAggregateOutputType | null
    _max: PriceHistoryMaxAggregateOutputType | null
  }

  export type PriceHistoryAvgAggregateOutputType = {
    price: number | null
  }

  export type PriceHistorySumAggregateOutputType = {
    price: number | null
  }

  export type PriceHistoryMinAggregateOutputType = {
    id: string | null
    planId: string | null
    price: number | null
    effectiveFrom: Date | null
    effectiveTo: Date | null
    reason: string | null
    createdAt: Date | null
  }

  export type PriceHistoryMaxAggregateOutputType = {
    id: string | null
    planId: string | null
    price: number | null
    effectiveFrom: Date | null
    effectiveTo: Date | null
    reason: string | null
    createdAt: Date | null
  }

  export type PriceHistoryCountAggregateOutputType = {
    id: number
    planId: number
    price: number
    effectiveFrom: number
    effectiveTo: number
    reason: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type PriceHistoryAvgAggregateInputType = {
    price?: true
  }

  export type PriceHistorySumAggregateInputType = {
    price?: true
  }

  export type PriceHistoryMinAggregateInputType = {
    id?: true
    planId?: true
    price?: true
    effectiveFrom?: true
    effectiveTo?: true
    reason?: true
    createdAt?: true
  }

  export type PriceHistoryMaxAggregateInputType = {
    id?: true
    planId?: true
    price?: true
    effectiveFrom?: true
    effectiveTo?: true
    reason?: true
    createdAt?: true
  }

  export type PriceHistoryCountAggregateInputType = {
    id?: true
    planId?: true
    price?: true
    effectiveFrom?: true
    effectiveTo?: true
    reason?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type PriceHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PriceHistory to aggregate.
     */
    where?: PriceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceHistories to fetch.
     */
    orderBy?: PriceHistoryOrderByWithRelationInput | PriceHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PriceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PriceHistories
    **/
    _count?: true | PriceHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PriceHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PriceHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PriceHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PriceHistoryMaxAggregateInputType
  }

  export type GetPriceHistoryAggregateType<T extends PriceHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregatePriceHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePriceHistory[P]>
      : GetScalarType<T[P], AggregatePriceHistory[P]>
  }




  export type PriceHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PriceHistoryWhereInput
    orderBy?: PriceHistoryOrderByWithAggregationInput | PriceHistoryOrderByWithAggregationInput[]
    by: PriceHistoryScalarFieldEnum[] | PriceHistoryScalarFieldEnum
    having?: PriceHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PriceHistoryCountAggregateInputType | true
    _avg?: PriceHistoryAvgAggregateInputType
    _sum?: PriceHistorySumAggregateInputType
    _min?: PriceHistoryMinAggregateInputType
    _max?: PriceHistoryMaxAggregateInputType
  }

  export type PriceHistoryGroupByOutputType = {
    id: string
    planId: string
    price: number
    effectiveFrom: Date
    effectiveTo: Date | null
    reason: string | null
    metadata: JsonValue | null
    createdAt: Date
    _count: PriceHistoryCountAggregateOutputType | null
    _avg: PriceHistoryAvgAggregateOutputType | null
    _sum: PriceHistorySumAggregateOutputType | null
    _min: PriceHistoryMinAggregateOutputType | null
    _max: PriceHistoryMaxAggregateOutputType | null
  }

  type GetPriceHistoryGroupByPayload<T extends PriceHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PriceHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PriceHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PriceHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], PriceHistoryGroupByOutputType[P]>
        }
      >
    >


  export type PriceHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    price?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    reason?: boolean
    metadata?: boolean
    createdAt?: boolean
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["priceHistory"]>

  export type PriceHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    price?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    reason?: boolean
    metadata?: boolean
    createdAt?: boolean
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["priceHistory"]>

  export type PriceHistorySelectScalar = {
    id?: boolean
    planId?: boolean
    price?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    reason?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type PriceHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }
  export type PriceHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }

  export type $PriceHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PriceHistory"
    objects: {
      plan: Prisma.$PlanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      planId: string
      price: number
      effectiveFrom: Date
      effectiveTo: Date | null
      reason: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["priceHistory"]>
    composites: {}
  }

  type PriceHistoryGetPayload<S extends boolean | null | undefined | PriceHistoryDefaultArgs> = $Result.GetResult<Prisma.$PriceHistoryPayload, S>

  type PriceHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PriceHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PriceHistoryCountAggregateInputType | true
    }

  export interface PriceHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PriceHistory'], meta: { name: 'PriceHistory' } }
    /**
     * Find zero or one PriceHistory that matches the filter.
     * @param {PriceHistoryFindUniqueArgs} args - Arguments to find a PriceHistory
     * @example
     * // Get one PriceHistory
     * const priceHistory = await prisma.priceHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PriceHistoryFindUniqueArgs>(args: SelectSubset<T, PriceHistoryFindUniqueArgs<ExtArgs>>): Prisma__PriceHistoryClient<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PriceHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PriceHistoryFindUniqueOrThrowArgs} args - Arguments to find a PriceHistory
     * @example
     * // Get one PriceHistory
     * const priceHistory = await prisma.priceHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PriceHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, PriceHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PriceHistoryClient<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PriceHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceHistoryFindFirstArgs} args - Arguments to find a PriceHistory
     * @example
     * // Get one PriceHistory
     * const priceHistory = await prisma.priceHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PriceHistoryFindFirstArgs>(args?: SelectSubset<T, PriceHistoryFindFirstArgs<ExtArgs>>): Prisma__PriceHistoryClient<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PriceHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceHistoryFindFirstOrThrowArgs} args - Arguments to find a PriceHistory
     * @example
     * // Get one PriceHistory
     * const priceHistory = await prisma.priceHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PriceHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, PriceHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__PriceHistoryClient<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PriceHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PriceHistories
     * const priceHistories = await prisma.priceHistory.findMany()
     * 
     * // Get first 10 PriceHistories
     * const priceHistories = await prisma.priceHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const priceHistoryWithIdOnly = await prisma.priceHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PriceHistoryFindManyArgs>(args?: SelectSubset<T, PriceHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PriceHistory.
     * @param {PriceHistoryCreateArgs} args - Arguments to create a PriceHistory.
     * @example
     * // Create one PriceHistory
     * const PriceHistory = await prisma.priceHistory.create({
     *   data: {
     *     // ... data to create a PriceHistory
     *   }
     * })
     * 
     */
    create<T extends PriceHistoryCreateArgs>(args: SelectSubset<T, PriceHistoryCreateArgs<ExtArgs>>): Prisma__PriceHistoryClient<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PriceHistories.
     * @param {PriceHistoryCreateManyArgs} args - Arguments to create many PriceHistories.
     * @example
     * // Create many PriceHistories
     * const priceHistory = await prisma.priceHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PriceHistoryCreateManyArgs>(args?: SelectSubset<T, PriceHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PriceHistories and returns the data saved in the database.
     * @param {PriceHistoryCreateManyAndReturnArgs} args - Arguments to create many PriceHistories.
     * @example
     * // Create many PriceHistories
     * const priceHistory = await prisma.priceHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PriceHistories and only return the `id`
     * const priceHistoryWithIdOnly = await prisma.priceHistory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PriceHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, PriceHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PriceHistory.
     * @param {PriceHistoryDeleteArgs} args - Arguments to delete one PriceHistory.
     * @example
     * // Delete one PriceHistory
     * const PriceHistory = await prisma.priceHistory.delete({
     *   where: {
     *     // ... filter to delete one PriceHistory
     *   }
     * })
     * 
     */
    delete<T extends PriceHistoryDeleteArgs>(args: SelectSubset<T, PriceHistoryDeleteArgs<ExtArgs>>): Prisma__PriceHistoryClient<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PriceHistory.
     * @param {PriceHistoryUpdateArgs} args - Arguments to update one PriceHistory.
     * @example
     * // Update one PriceHistory
     * const priceHistory = await prisma.priceHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PriceHistoryUpdateArgs>(args: SelectSubset<T, PriceHistoryUpdateArgs<ExtArgs>>): Prisma__PriceHistoryClient<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PriceHistories.
     * @param {PriceHistoryDeleteManyArgs} args - Arguments to filter PriceHistories to delete.
     * @example
     * // Delete a few PriceHistories
     * const { count } = await prisma.priceHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PriceHistoryDeleteManyArgs>(args?: SelectSubset<T, PriceHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PriceHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PriceHistories
     * const priceHistory = await prisma.priceHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PriceHistoryUpdateManyArgs>(args: SelectSubset<T, PriceHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PriceHistory.
     * @param {PriceHistoryUpsertArgs} args - Arguments to update or create a PriceHistory.
     * @example
     * // Update or create a PriceHistory
     * const priceHistory = await prisma.priceHistory.upsert({
     *   create: {
     *     // ... data to create a PriceHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PriceHistory we want to update
     *   }
     * })
     */
    upsert<T extends PriceHistoryUpsertArgs>(args: SelectSubset<T, PriceHistoryUpsertArgs<ExtArgs>>): Prisma__PriceHistoryClient<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PriceHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceHistoryCountArgs} args - Arguments to filter PriceHistories to count.
     * @example
     * // Count the number of PriceHistories
     * const count = await prisma.priceHistory.count({
     *   where: {
     *     // ... the filter for the PriceHistories we want to count
     *   }
     * })
    **/
    count<T extends PriceHistoryCountArgs>(
      args?: Subset<T, PriceHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PriceHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PriceHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PriceHistoryAggregateArgs>(args: Subset<T, PriceHistoryAggregateArgs>): Prisma.PrismaPromise<GetPriceHistoryAggregateType<T>>

    /**
     * Group by PriceHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PriceHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PriceHistoryGroupByArgs['orderBy'] }
        : { orderBy?: PriceHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PriceHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPriceHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PriceHistory model
   */
  readonly fields: PriceHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PriceHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PriceHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plan<T extends PlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlanDefaultArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PriceHistory model
   */ 
  interface PriceHistoryFieldRefs {
    readonly id: FieldRef<"PriceHistory", 'String'>
    readonly planId: FieldRef<"PriceHistory", 'String'>
    readonly price: FieldRef<"PriceHistory", 'Float'>
    readonly effectiveFrom: FieldRef<"PriceHistory", 'DateTime'>
    readonly effectiveTo: FieldRef<"PriceHistory", 'DateTime'>
    readonly reason: FieldRef<"PriceHistory", 'String'>
    readonly metadata: FieldRef<"PriceHistory", 'Json'>
    readonly createdAt: FieldRef<"PriceHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PriceHistory findUnique
   */
  export type PriceHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PriceHistory to fetch.
     */
    where: PriceHistoryWhereUniqueInput
  }

  /**
   * PriceHistory findUniqueOrThrow
   */
  export type PriceHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PriceHistory to fetch.
     */
    where: PriceHistoryWhereUniqueInput
  }

  /**
   * PriceHistory findFirst
   */
  export type PriceHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PriceHistory to fetch.
     */
    where?: PriceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceHistories to fetch.
     */
    orderBy?: PriceHistoryOrderByWithRelationInput | PriceHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PriceHistories.
     */
    cursor?: PriceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PriceHistories.
     */
    distinct?: PriceHistoryScalarFieldEnum | PriceHistoryScalarFieldEnum[]
  }

  /**
   * PriceHistory findFirstOrThrow
   */
  export type PriceHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PriceHistory to fetch.
     */
    where?: PriceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceHistories to fetch.
     */
    orderBy?: PriceHistoryOrderByWithRelationInput | PriceHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PriceHistories.
     */
    cursor?: PriceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PriceHistories.
     */
    distinct?: PriceHistoryScalarFieldEnum | PriceHistoryScalarFieldEnum[]
  }

  /**
   * PriceHistory findMany
   */
  export type PriceHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PriceHistories to fetch.
     */
    where?: PriceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceHistories to fetch.
     */
    orderBy?: PriceHistoryOrderByWithRelationInput | PriceHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PriceHistories.
     */
    cursor?: PriceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceHistories.
     */
    skip?: number
    distinct?: PriceHistoryScalarFieldEnum | PriceHistoryScalarFieldEnum[]
  }

  /**
   * PriceHistory create
   */
  export type PriceHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a PriceHistory.
     */
    data: XOR<PriceHistoryCreateInput, PriceHistoryUncheckedCreateInput>
  }

  /**
   * PriceHistory createMany
   */
  export type PriceHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PriceHistories.
     */
    data: PriceHistoryCreateManyInput | PriceHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PriceHistory createManyAndReturn
   */
  export type PriceHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PriceHistories.
     */
    data: PriceHistoryCreateManyInput | PriceHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PriceHistory update
   */
  export type PriceHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a PriceHistory.
     */
    data: XOR<PriceHistoryUpdateInput, PriceHistoryUncheckedUpdateInput>
    /**
     * Choose, which PriceHistory to update.
     */
    where: PriceHistoryWhereUniqueInput
  }

  /**
   * PriceHistory updateMany
   */
  export type PriceHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PriceHistories.
     */
    data: XOR<PriceHistoryUpdateManyMutationInput, PriceHistoryUncheckedUpdateManyInput>
    /**
     * Filter which PriceHistories to update
     */
    where?: PriceHistoryWhereInput
  }

  /**
   * PriceHistory upsert
   */
  export type PriceHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the PriceHistory to update in case it exists.
     */
    where: PriceHistoryWhereUniqueInput
    /**
     * In case the PriceHistory found by the `where` argument doesn't exist, create a new PriceHistory with this data.
     */
    create: XOR<PriceHistoryCreateInput, PriceHistoryUncheckedCreateInput>
    /**
     * In case the PriceHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PriceHistoryUpdateInput, PriceHistoryUncheckedUpdateInput>
  }

  /**
   * PriceHistory delete
   */
  export type PriceHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * Filter which PriceHistory to delete.
     */
    where: PriceHistoryWhereUniqueInput
  }

  /**
   * PriceHistory deleteMany
   */
  export type PriceHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PriceHistories to delete
     */
    where?: PriceHistoryWhereInput
  }

  /**
   * PriceHistory without action
   */
  export type PriceHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceHistoryInclude<ExtArgs> | null
  }


  /**
   * Model PriceTest
   */

  export type AggregatePriceTest = {
    _count: PriceTestCountAggregateOutputType | null
    _avg: PriceTestAvgAggregateOutputType | null
    _sum: PriceTestSumAggregateOutputType | null
    _min: PriceTestMinAggregateOutputType | null
    _max: PriceTestMaxAggregateOutputType | null
  }

  export type PriceTestAvgAggregateOutputType = {
    minConfidence: number | null
  }

  export type PriceTestSumAggregateOutputType = {
    minConfidence: number | null
  }

  export type PriceTestMinAggregateOutputType = {
    id: string | null
    planId: string | null
    name: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    status: string | null
    targetMetric: string | null
    minConfidence: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PriceTestMaxAggregateOutputType = {
    id: string | null
    planId: string | null
    name: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    status: string | null
    targetMetric: string | null
    minConfidence: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PriceTestCountAggregateOutputType = {
    id: number
    planId: number
    name: number
    description: number
    startDate: number
    endDate: number
    status: number
    targetMetric: number
    minConfidence: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PriceTestAvgAggregateInputType = {
    minConfidence?: true
  }

  export type PriceTestSumAggregateInputType = {
    minConfidence?: true
  }

  export type PriceTestMinAggregateInputType = {
    id?: true
    planId?: true
    name?: true
    description?: true
    startDate?: true
    endDate?: true
    status?: true
    targetMetric?: true
    minConfidence?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PriceTestMaxAggregateInputType = {
    id?: true
    planId?: true
    name?: true
    description?: true
    startDate?: true
    endDate?: true
    status?: true
    targetMetric?: true
    minConfidence?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PriceTestCountAggregateInputType = {
    id?: true
    planId?: true
    name?: true
    description?: true
    startDate?: true
    endDate?: true
    status?: true
    targetMetric?: true
    minConfidence?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PriceTestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PriceTest to aggregate.
     */
    where?: PriceTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceTests to fetch.
     */
    orderBy?: PriceTestOrderByWithRelationInput | PriceTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PriceTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PriceTests
    **/
    _count?: true | PriceTestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PriceTestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PriceTestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PriceTestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PriceTestMaxAggregateInputType
  }

  export type GetPriceTestAggregateType<T extends PriceTestAggregateArgs> = {
        [P in keyof T & keyof AggregatePriceTest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePriceTest[P]>
      : GetScalarType<T[P], AggregatePriceTest[P]>
  }




  export type PriceTestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PriceTestWhereInput
    orderBy?: PriceTestOrderByWithAggregationInput | PriceTestOrderByWithAggregationInput[]
    by: PriceTestScalarFieldEnum[] | PriceTestScalarFieldEnum
    having?: PriceTestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PriceTestCountAggregateInputType | true
    _avg?: PriceTestAvgAggregateInputType
    _sum?: PriceTestSumAggregateInputType
    _min?: PriceTestMinAggregateInputType
    _max?: PriceTestMaxAggregateInputType
  }

  export type PriceTestGroupByOutputType = {
    id: string
    planId: string
    name: string
    description: string | null
    startDate: Date
    endDate: Date | null
    status: string
    targetMetric: string
    minConfidence: number
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: PriceTestCountAggregateOutputType | null
    _avg: PriceTestAvgAggregateOutputType | null
    _sum: PriceTestSumAggregateOutputType | null
    _min: PriceTestMinAggregateOutputType | null
    _max: PriceTestMaxAggregateOutputType | null
  }

  type GetPriceTestGroupByPayload<T extends PriceTestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PriceTestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PriceTestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PriceTestGroupByOutputType[P]>
            : GetScalarType<T[P], PriceTestGroupByOutputType[P]>
        }
      >
    >


  export type PriceTestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    name?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    targetMetric?: boolean
    minConfidence?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | PlanDefaultArgs<ExtArgs>
    variants?: boolean | PriceTest$variantsArgs<ExtArgs>
    _count?: boolean | PriceTestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["priceTest"]>

  export type PriceTestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    name?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    targetMetric?: boolean
    minConfidence?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["priceTest"]>

  export type PriceTestSelectScalar = {
    id?: boolean
    planId?: boolean
    name?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    targetMetric?: boolean
    minConfidence?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PriceTestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | PlanDefaultArgs<ExtArgs>
    variants?: boolean | PriceTest$variantsArgs<ExtArgs>
    _count?: boolean | PriceTestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PriceTestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }

  export type $PriceTestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PriceTest"
    objects: {
      plan: Prisma.$PlanPayload<ExtArgs>
      variants: Prisma.$PriceTestVariantPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      planId: string
      name: string
      description: string | null
      startDate: Date
      endDate: Date | null
      status: string
      targetMetric: string
      minConfidence: number
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["priceTest"]>
    composites: {}
  }

  type PriceTestGetPayload<S extends boolean | null | undefined | PriceTestDefaultArgs> = $Result.GetResult<Prisma.$PriceTestPayload, S>

  type PriceTestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PriceTestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PriceTestCountAggregateInputType | true
    }

  export interface PriceTestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PriceTest'], meta: { name: 'PriceTest' } }
    /**
     * Find zero or one PriceTest that matches the filter.
     * @param {PriceTestFindUniqueArgs} args - Arguments to find a PriceTest
     * @example
     * // Get one PriceTest
     * const priceTest = await prisma.priceTest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PriceTestFindUniqueArgs>(args: SelectSubset<T, PriceTestFindUniqueArgs<ExtArgs>>): Prisma__PriceTestClient<$Result.GetResult<Prisma.$PriceTestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PriceTest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PriceTestFindUniqueOrThrowArgs} args - Arguments to find a PriceTest
     * @example
     * // Get one PriceTest
     * const priceTest = await prisma.priceTest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PriceTestFindUniqueOrThrowArgs>(args: SelectSubset<T, PriceTestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PriceTestClient<$Result.GetResult<Prisma.$PriceTestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PriceTest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceTestFindFirstArgs} args - Arguments to find a PriceTest
     * @example
     * // Get one PriceTest
     * const priceTest = await prisma.priceTest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PriceTestFindFirstArgs>(args?: SelectSubset<T, PriceTestFindFirstArgs<ExtArgs>>): Prisma__PriceTestClient<$Result.GetResult<Prisma.$PriceTestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PriceTest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceTestFindFirstOrThrowArgs} args - Arguments to find a PriceTest
     * @example
     * // Get one PriceTest
     * const priceTest = await prisma.priceTest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PriceTestFindFirstOrThrowArgs>(args?: SelectSubset<T, PriceTestFindFirstOrThrowArgs<ExtArgs>>): Prisma__PriceTestClient<$Result.GetResult<Prisma.$PriceTestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PriceTests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceTestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PriceTests
     * const priceTests = await prisma.priceTest.findMany()
     * 
     * // Get first 10 PriceTests
     * const priceTests = await prisma.priceTest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const priceTestWithIdOnly = await prisma.priceTest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PriceTestFindManyArgs>(args?: SelectSubset<T, PriceTestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceTestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PriceTest.
     * @param {PriceTestCreateArgs} args - Arguments to create a PriceTest.
     * @example
     * // Create one PriceTest
     * const PriceTest = await prisma.priceTest.create({
     *   data: {
     *     // ... data to create a PriceTest
     *   }
     * })
     * 
     */
    create<T extends PriceTestCreateArgs>(args: SelectSubset<T, PriceTestCreateArgs<ExtArgs>>): Prisma__PriceTestClient<$Result.GetResult<Prisma.$PriceTestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PriceTests.
     * @param {PriceTestCreateManyArgs} args - Arguments to create many PriceTests.
     * @example
     * // Create many PriceTests
     * const priceTest = await prisma.priceTest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PriceTestCreateManyArgs>(args?: SelectSubset<T, PriceTestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PriceTests and returns the data saved in the database.
     * @param {PriceTestCreateManyAndReturnArgs} args - Arguments to create many PriceTests.
     * @example
     * // Create many PriceTests
     * const priceTest = await prisma.priceTest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PriceTests and only return the `id`
     * const priceTestWithIdOnly = await prisma.priceTest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PriceTestCreateManyAndReturnArgs>(args?: SelectSubset<T, PriceTestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceTestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PriceTest.
     * @param {PriceTestDeleteArgs} args - Arguments to delete one PriceTest.
     * @example
     * // Delete one PriceTest
     * const PriceTest = await prisma.priceTest.delete({
     *   where: {
     *     // ... filter to delete one PriceTest
     *   }
     * })
     * 
     */
    delete<T extends PriceTestDeleteArgs>(args: SelectSubset<T, PriceTestDeleteArgs<ExtArgs>>): Prisma__PriceTestClient<$Result.GetResult<Prisma.$PriceTestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PriceTest.
     * @param {PriceTestUpdateArgs} args - Arguments to update one PriceTest.
     * @example
     * // Update one PriceTest
     * const priceTest = await prisma.priceTest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PriceTestUpdateArgs>(args: SelectSubset<T, PriceTestUpdateArgs<ExtArgs>>): Prisma__PriceTestClient<$Result.GetResult<Prisma.$PriceTestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PriceTests.
     * @param {PriceTestDeleteManyArgs} args - Arguments to filter PriceTests to delete.
     * @example
     * // Delete a few PriceTests
     * const { count } = await prisma.priceTest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PriceTestDeleteManyArgs>(args?: SelectSubset<T, PriceTestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PriceTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceTestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PriceTests
     * const priceTest = await prisma.priceTest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PriceTestUpdateManyArgs>(args: SelectSubset<T, PriceTestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PriceTest.
     * @param {PriceTestUpsertArgs} args - Arguments to update or create a PriceTest.
     * @example
     * // Update or create a PriceTest
     * const priceTest = await prisma.priceTest.upsert({
     *   create: {
     *     // ... data to create a PriceTest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PriceTest we want to update
     *   }
     * })
     */
    upsert<T extends PriceTestUpsertArgs>(args: SelectSubset<T, PriceTestUpsertArgs<ExtArgs>>): Prisma__PriceTestClient<$Result.GetResult<Prisma.$PriceTestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PriceTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceTestCountArgs} args - Arguments to filter PriceTests to count.
     * @example
     * // Count the number of PriceTests
     * const count = await prisma.priceTest.count({
     *   where: {
     *     // ... the filter for the PriceTests we want to count
     *   }
     * })
    **/
    count<T extends PriceTestCountArgs>(
      args?: Subset<T, PriceTestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PriceTestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PriceTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceTestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PriceTestAggregateArgs>(args: Subset<T, PriceTestAggregateArgs>): Prisma.PrismaPromise<GetPriceTestAggregateType<T>>

    /**
     * Group by PriceTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceTestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PriceTestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PriceTestGroupByArgs['orderBy'] }
        : { orderBy?: PriceTestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PriceTestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPriceTestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PriceTest model
   */
  readonly fields: PriceTestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PriceTest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PriceTestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plan<T extends PlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlanDefaultArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    variants<T extends PriceTest$variantsArgs<ExtArgs> = {}>(args?: Subset<T, PriceTest$variantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceTestVariantPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PriceTest model
   */ 
  interface PriceTestFieldRefs {
    readonly id: FieldRef<"PriceTest", 'String'>
    readonly planId: FieldRef<"PriceTest", 'String'>
    readonly name: FieldRef<"PriceTest", 'String'>
    readonly description: FieldRef<"PriceTest", 'String'>
    readonly startDate: FieldRef<"PriceTest", 'DateTime'>
    readonly endDate: FieldRef<"PriceTest", 'DateTime'>
    readonly status: FieldRef<"PriceTest", 'String'>
    readonly targetMetric: FieldRef<"PriceTest", 'String'>
    readonly minConfidence: FieldRef<"PriceTest", 'Float'>
    readonly metadata: FieldRef<"PriceTest", 'Json'>
    readonly createdAt: FieldRef<"PriceTest", 'DateTime'>
    readonly updatedAt: FieldRef<"PriceTest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PriceTest findUnique
   */
  export type PriceTestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceTest
     */
    select?: PriceTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceTestInclude<ExtArgs> | null
    /**
     * Filter, which PriceTest to fetch.
     */
    where: PriceTestWhereUniqueInput
  }

  /**
   * PriceTest findUniqueOrThrow
   */
  export type PriceTestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceTest
     */
    select?: PriceTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceTestInclude<ExtArgs> | null
    /**
     * Filter, which PriceTest to fetch.
     */
    where: PriceTestWhereUniqueInput
  }

  /**
   * PriceTest findFirst
   */
  export type PriceTestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceTest
     */
    select?: PriceTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceTestInclude<ExtArgs> | null
    /**
     * Filter, which PriceTest to fetch.
     */
    where?: PriceTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceTests to fetch.
     */
    orderBy?: PriceTestOrderByWithRelationInput | PriceTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PriceTests.
     */
    cursor?: PriceTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PriceTests.
     */
    distinct?: PriceTestScalarFieldEnum | PriceTestScalarFieldEnum[]
  }

  /**
   * PriceTest findFirstOrThrow
   */
  export type PriceTestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceTest
     */
    select?: PriceTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceTestInclude<ExtArgs> | null
    /**
     * Filter, which PriceTest to fetch.
     */
    where?: PriceTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceTests to fetch.
     */
    orderBy?: PriceTestOrderByWithRelationInput | PriceTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PriceTests.
     */
    cursor?: PriceTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PriceTests.
     */
    distinct?: PriceTestScalarFieldEnum | PriceTestScalarFieldEnum[]
  }

  /**
   * PriceTest findMany
   */
  export type PriceTestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceTest
     */
    select?: PriceTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceTestInclude<ExtArgs> | null
    /**
     * Filter, which PriceTests to fetch.
     */
    where?: PriceTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceTests to fetch.
     */
    orderBy?: PriceTestOrderByWithRelationInput | PriceTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PriceTests.
     */
    cursor?: PriceTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceTests.
     */
    skip?: number
    distinct?: PriceTestScalarFieldEnum | PriceTestScalarFieldEnum[]
  }

  /**
   * PriceTest create
   */
  export type PriceTestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceTest
     */
    select?: PriceTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceTestInclude<ExtArgs> | null
    /**
     * The data needed to create a PriceTest.
     */
    data: XOR<PriceTestCreateInput, PriceTestUncheckedCreateInput>
  }

  /**
   * PriceTest createMany
   */
  export type PriceTestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PriceTests.
     */
    data: PriceTestCreateManyInput | PriceTestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PriceTest createManyAndReturn
   */
  export type PriceTestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceTest
     */
    select?: PriceTestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PriceTests.
     */
    data: PriceTestCreateManyInput | PriceTestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceTestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PriceTest update
   */
  export type PriceTestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceTest
     */
    select?: PriceTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceTestInclude<ExtArgs> | null
    /**
     * The data needed to update a PriceTest.
     */
    data: XOR<PriceTestUpdateInput, PriceTestUncheckedUpdateInput>
    /**
     * Choose, which PriceTest to update.
     */
    where: PriceTestWhereUniqueInput
  }

  /**
   * PriceTest updateMany
   */
  export type PriceTestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PriceTests.
     */
    data: XOR<PriceTestUpdateManyMutationInput, PriceTestUncheckedUpdateManyInput>
    /**
     * Filter which PriceTests to update
     */
    where?: PriceTestWhereInput
  }

  /**
   * PriceTest upsert
   */
  export type PriceTestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceTest
     */
    select?: PriceTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceTestInclude<ExtArgs> | null
    /**
     * The filter to search for the PriceTest to update in case it exists.
     */
    where: PriceTestWhereUniqueInput
    /**
     * In case the PriceTest found by the `where` argument doesn't exist, create a new PriceTest with this data.
     */
    create: XOR<PriceTestCreateInput, PriceTestUncheckedCreateInput>
    /**
     * In case the PriceTest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PriceTestUpdateInput, PriceTestUncheckedUpdateInput>
  }

  /**
   * PriceTest delete
   */
  export type PriceTestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceTest
     */
    select?: PriceTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceTestInclude<ExtArgs> | null
    /**
     * Filter which PriceTest to delete.
     */
    where: PriceTestWhereUniqueInput
  }

  /**
   * PriceTest deleteMany
   */
  export type PriceTestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PriceTests to delete
     */
    where?: PriceTestWhereInput
  }

  /**
   * PriceTest.variants
   */
  export type PriceTest$variantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceTestVariant
     */
    select?: PriceTestVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceTestVariantInclude<ExtArgs> | null
    where?: PriceTestVariantWhereInput
    orderBy?: PriceTestVariantOrderByWithRelationInput | PriceTestVariantOrderByWithRelationInput[]
    cursor?: PriceTestVariantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PriceTestVariantScalarFieldEnum | PriceTestVariantScalarFieldEnum[]
  }

  /**
   * PriceTest without action
   */
  export type PriceTestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceTest
     */
    select?: PriceTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceTestInclude<ExtArgs> | null
  }


  /**
   * Model PriceTestVariant
   */

  export type AggregatePriceTestVariant = {
    _count: PriceTestVariantCountAggregateOutputType | null
    _avg: PriceTestVariantAvgAggregateOutputType | null
    _sum: PriceTestVariantSumAggregateOutputType | null
    _min: PriceTestVariantMinAggregateOutputType | null
    _max: PriceTestVariantMaxAggregateOutputType | null
  }

  export type PriceTestVariantAvgAggregateOutputType = {
    price: number | null
    conversionRate: number | null
    revenue: number | null
    subscribers: number | null
  }

  export type PriceTestVariantSumAggregateOutputType = {
    price: number | null
    conversionRate: number | null
    revenue: number | null
    subscribers: number | null
  }

  export type PriceTestVariantMinAggregateOutputType = {
    id: string | null
    testId: string | null
    price: number | null
    name: string | null
    description: string | null
    conversionRate: number | null
    revenue: number | null
    subscribers: number | null
    isControl: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PriceTestVariantMaxAggregateOutputType = {
    id: string | null
    testId: string | null
    price: number | null
    name: string | null
    description: string | null
    conversionRate: number | null
    revenue: number | null
    subscribers: number | null
    isControl: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PriceTestVariantCountAggregateOutputType = {
    id: number
    testId: number
    price: number
    name: number
    description: number
    conversionRate: number
    revenue: number
    subscribers: number
    isControl: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PriceTestVariantAvgAggregateInputType = {
    price?: true
    conversionRate?: true
    revenue?: true
    subscribers?: true
  }

  export type PriceTestVariantSumAggregateInputType = {
    price?: true
    conversionRate?: true
    revenue?: true
    subscribers?: true
  }

  export type PriceTestVariantMinAggregateInputType = {
    id?: true
    testId?: true
    price?: true
    name?: true
    description?: true
    conversionRate?: true
    revenue?: true
    subscribers?: true
    isControl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PriceTestVariantMaxAggregateInputType = {
    id?: true
    testId?: true
    price?: true
    name?: true
    description?: true
    conversionRate?: true
    revenue?: true
    subscribers?: true
    isControl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PriceTestVariantCountAggregateInputType = {
    id?: true
    testId?: true
    price?: true
    name?: true
    description?: true
    conversionRate?: true
    revenue?: true
    subscribers?: true
    isControl?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PriceTestVariantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PriceTestVariant to aggregate.
     */
    where?: PriceTestVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceTestVariants to fetch.
     */
    orderBy?: PriceTestVariantOrderByWithRelationInput | PriceTestVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PriceTestVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceTestVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceTestVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PriceTestVariants
    **/
    _count?: true | PriceTestVariantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PriceTestVariantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PriceTestVariantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PriceTestVariantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PriceTestVariantMaxAggregateInputType
  }

  export type GetPriceTestVariantAggregateType<T extends PriceTestVariantAggregateArgs> = {
        [P in keyof T & keyof AggregatePriceTestVariant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePriceTestVariant[P]>
      : GetScalarType<T[P], AggregatePriceTestVariant[P]>
  }




  export type PriceTestVariantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PriceTestVariantWhereInput
    orderBy?: PriceTestVariantOrderByWithAggregationInput | PriceTestVariantOrderByWithAggregationInput[]
    by: PriceTestVariantScalarFieldEnum[] | PriceTestVariantScalarFieldEnum
    having?: PriceTestVariantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PriceTestVariantCountAggregateInputType | true
    _avg?: PriceTestVariantAvgAggregateInputType
    _sum?: PriceTestVariantSumAggregateInputType
    _min?: PriceTestVariantMinAggregateInputType
    _max?: PriceTestVariantMaxAggregateInputType
  }

  export type PriceTestVariantGroupByOutputType = {
    id: string
    testId: string
    price: number
    name: string
    description: string | null
    conversionRate: number | null
    revenue: number | null
    subscribers: number
    isControl: boolean
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: PriceTestVariantCountAggregateOutputType | null
    _avg: PriceTestVariantAvgAggregateOutputType | null
    _sum: PriceTestVariantSumAggregateOutputType | null
    _min: PriceTestVariantMinAggregateOutputType | null
    _max: PriceTestVariantMaxAggregateOutputType | null
  }

  type GetPriceTestVariantGroupByPayload<T extends PriceTestVariantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PriceTestVariantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PriceTestVariantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PriceTestVariantGroupByOutputType[P]>
            : GetScalarType<T[P], PriceTestVariantGroupByOutputType[P]>
        }
      >
    >


  export type PriceTestVariantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    testId?: boolean
    price?: boolean
    name?: boolean
    description?: boolean
    conversionRate?: boolean
    revenue?: boolean
    subscribers?: boolean
    isControl?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    test?: boolean | PriceTestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["priceTestVariant"]>

  export type PriceTestVariantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    testId?: boolean
    price?: boolean
    name?: boolean
    description?: boolean
    conversionRate?: boolean
    revenue?: boolean
    subscribers?: boolean
    isControl?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    test?: boolean | PriceTestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["priceTestVariant"]>

  export type PriceTestVariantSelectScalar = {
    id?: boolean
    testId?: boolean
    price?: boolean
    name?: boolean
    description?: boolean
    conversionRate?: boolean
    revenue?: boolean
    subscribers?: boolean
    isControl?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PriceTestVariantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    test?: boolean | PriceTestDefaultArgs<ExtArgs>
  }
  export type PriceTestVariantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    test?: boolean | PriceTestDefaultArgs<ExtArgs>
  }

  export type $PriceTestVariantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PriceTestVariant"
    objects: {
      test: Prisma.$PriceTestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      testId: string
      price: number
      name: string
      description: string | null
      conversionRate: number | null
      revenue: number | null
      subscribers: number
      isControl: boolean
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["priceTestVariant"]>
    composites: {}
  }

  type PriceTestVariantGetPayload<S extends boolean | null | undefined | PriceTestVariantDefaultArgs> = $Result.GetResult<Prisma.$PriceTestVariantPayload, S>

  type PriceTestVariantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PriceTestVariantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PriceTestVariantCountAggregateInputType | true
    }

  export interface PriceTestVariantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PriceTestVariant'], meta: { name: 'PriceTestVariant' } }
    /**
     * Find zero or one PriceTestVariant that matches the filter.
     * @param {PriceTestVariantFindUniqueArgs} args - Arguments to find a PriceTestVariant
     * @example
     * // Get one PriceTestVariant
     * const priceTestVariant = await prisma.priceTestVariant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PriceTestVariantFindUniqueArgs>(args: SelectSubset<T, PriceTestVariantFindUniqueArgs<ExtArgs>>): Prisma__PriceTestVariantClient<$Result.GetResult<Prisma.$PriceTestVariantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PriceTestVariant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PriceTestVariantFindUniqueOrThrowArgs} args - Arguments to find a PriceTestVariant
     * @example
     * // Get one PriceTestVariant
     * const priceTestVariant = await prisma.priceTestVariant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PriceTestVariantFindUniqueOrThrowArgs>(args: SelectSubset<T, PriceTestVariantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PriceTestVariantClient<$Result.GetResult<Prisma.$PriceTestVariantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PriceTestVariant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceTestVariantFindFirstArgs} args - Arguments to find a PriceTestVariant
     * @example
     * // Get one PriceTestVariant
     * const priceTestVariant = await prisma.priceTestVariant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PriceTestVariantFindFirstArgs>(args?: SelectSubset<T, PriceTestVariantFindFirstArgs<ExtArgs>>): Prisma__PriceTestVariantClient<$Result.GetResult<Prisma.$PriceTestVariantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PriceTestVariant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceTestVariantFindFirstOrThrowArgs} args - Arguments to find a PriceTestVariant
     * @example
     * // Get one PriceTestVariant
     * const priceTestVariant = await prisma.priceTestVariant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PriceTestVariantFindFirstOrThrowArgs>(args?: SelectSubset<T, PriceTestVariantFindFirstOrThrowArgs<ExtArgs>>): Prisma__PriceTestVariantClient<$Result.GetResult<Prisma.$PriceTestVariantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PriceTestVariants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceTestVariantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PriceTestVariants
     * const priceTestVariants = await prisma.priceTestVariant.findMany()
     * 
     * // Get first 10 PriceTestVariants
     * const priceTestVariants = await prisma.priceTestVariant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const priceTestVariantWithIdOnly = await prisma.priceTestVariant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PriceTestVariantFindManyArgs>(args?: SelectSubset<T, PriceTestVariantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceTestVariantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PriceTestVariant.
     * @param {PriceTestVariantCreateArgs} args - Arguments to create a PriceTestVariant.
     * @example
     * // Create one PriceTestVariant
     * const PriceTestVariant = await prisma.priceTestVariant.create({
     *   data: {
     *     // ... data to create a PriceTestVariant
     *   }
     * })
     * 
     */
    create<T extends PriceTestVariantCreateArgs>(args: SelectSubset<T, PriceTestVariantCreateArgs<ExtArgs>>): Prisma__PriceTestVariantClient<$Result.GetResult<Prisma.$PriceTestVariantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PriceTestVariants.
     * @param {PriceTestVariantCreateManyArgs} args - Arguments to create many PriceTestVariants.
     * @example
     * // Create many PriceTestVariants
     * const priceTestVariant = await prisma.priceTestVariant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PriceTestVariantCreateManyArgs>(args?: SelectSubset<T, PriceTestVariantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PriceTestVariants and returns the data saved in the database.
     * @param {PriceTestVariantCreateManyAndReturnArgs} args - Arguments to create many PriceTestVariants.
     * @example
     * // Create many PriceTestVariants
     * const priceTestVariant = await prisma.priceTestVariant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PriceTestVariants and only return the `id`
     * const priceTestVariantWithIdOnly = await prisma.priceTestVariant.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PriceTestVariantCreateManyAndReturnArgs>(args?: SelectSubset<T, PriceTestVariantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceTestVariantPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PriceTestVariant.
     * @param {PriceTestVariantDeleteArgs} args - Arguments to delete one PriceTestVariant.
     * @example
     * // Delete one PriceTestVariant
     * const PriceTestVariant = await prisma.priceTestVariant.delete({
     *   where: {
     *     // ... filter to delete one PriceTestVariant
     *   }
     * })
     * 
     */
    delete<T extends PriceTestVariantDeleteArgs>(args: SelectSubset<T, PriceTestVariantDeleteArgs<ExtArgs>>): Prisma__PriceTestVariantClient<$Result.GetResult<Prisma.$PriceTestVariantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PriceTestVariant.
     * @param {PriceTestVariantUpdateArgs} args - Arguments to update one PriceTestVariant.
     * @example
     * // Update one PriceTestVariant
     * const priceTestVariant = await prisma.priceTestVariant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PriceTestVariantUpdateArgs>(args: SelectSubset<T, PriceTestVariantUpdateArgs<ExtArgs>>): Prisma__PriceTestVariantClient<$Result.GetResult<Prisma.$PriceTestVariantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PriceTestVariants.
     * @param {PriceTestVariantDeleteManyArgs} args - Arguments to filter PriceTestVariants to delete.
     * @example
     * // Delete a few PriceTestVariants
     * const { count } = await prisma.priceTestVariant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PriceTestVariantDeleteManyArgs>(args?: SelectSubset<T, PriceTestVariantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PriceTestVariants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceTestVariantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PriceTestVariants
     * const priceTestVariant = await prisma.priceTestVariant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PriceTestVariantUpdateManyArgs>(args: SelectSubset<T, PriceTestVariantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PriceTestVariant.
     * @param {PriceTestVariantUpsertArgs} args - Arguments to update or create a PriceTestVariant.
     * @example
     * // Update or create a PriceTestVariant
     * const priceTestVariant = await prisma.priceTestVariant.upsert({
     *   create: {
     *     // ... data to create a PriceTestVariant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PriceTestVariant we want to update
     *   }
     * })
     */
    upsert<T extends PriceTestVariantUpsertArgs>(args: SelectSubset<T, PriceTestVariantUpsertArgs<ExtArgs>>): Prisma__PriceTestVariantClient<$Result.GetResult<Prisma.$PriceTestVariantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PriceTestVariants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceTestVariantCountArgs} args - Arguments to filter PriceTestVariants to count.
     * @example
     * // Count the number of PriceTestVariants
     * const count = await prisma.priceTestVariant.count({
     *   where: {
     *     // ... the filter for the PriceTestVariants we want to count
     *   }
     * })
    **/
    count<T extends PriceTestVariantCountArgs>(
      args?: Subset<T, PriceTestVariantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PriceTestVariantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PriceTestVariant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceTestVariantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PriceTestVariantAggregateArgs>(args: Subset<T, PriceTestVariantAggregateArgs>): Prisma.PrismaPromise<GetPriceTestVariantAggregateType<T>>

    /**
     * Group by PriceTestVariant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceTestVariantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PriceTestVariantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PriceTestVariantGroupByArgs['orderBy'] }
        : { orderBy?: PriceTestVariantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PriceTestVariantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPriceTestVariantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PriceTestVariant model
   */
  readonly fields: PriceTestVariantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PriceTestVariant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PriceTestVariantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    test<T extends PriceTestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PriceTestDefaultArgs<ExtArgs>>): Prisma__PriceTestClient<$Result.GetResult<Prisma.$PriceTestPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PriceTestVariant model
   */ 
  interface PriceTestVariantFieldRefs {
    readonly id: FieldRef<"PriceTestVariant", 'String'>
    readonly testId: FieldRef<"PriceTestVariant", 'String'>
    readonly price: FieldRef<"PriceTestVariant", 'Float'>
    readonly name: FieldRef<"PriceTestVariant", 'String'>
    readonly description: FieldRef<"PriceTestVariant", 'String'>
    readonly conversionRate: FieldRef<"PriceTestVariant", 'Float'>
    readonly revenue: FieldRef<"PriceTestVariant", 'Float'>
    readonly subscribers: FieldRef<"PriceTestVariant", 'Int'>
    readonly isControl: FieldRef<"PriceTestVariant", 'Boolean'>
    readonly metadata: FieldRef<"PriceTestVariant", 'Json'>
    readonly createdAt: FieldRef<"PriceTestVariant", 'DateTime'>
    readonly updatedAt: FieldRef<"PriceTestVariant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PriceTestVariant findUnique
   */
  export type PriceTestVariantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceTestVariant
     */
    select?: PriceTestVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceTestVariantInclude<ExtArgs> | null
    /**
     * Filter, which PriceTestVariant to fetch.
     */
    where: PriceTestVariantWhereUniqueInput
  }

  /**
   * PriceTestVariant findUniqueOrThrow
   */
  export type PriceTestVariantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceTestVariant
     */
    select?: PriceTestVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceTestVariantInclude<ExtArgs> | null
    /**
     * Filter, which PriceTestVariant to fetch.
     */
    where: PriceTestVariantWhereUniqueInput
  }

  /**
   * PriceTestVariant findFirst
   */
  export type PriceTestVariantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceTestVariant
     */
    select?: PriceTestVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceTestVariantInclude<ExtArgs> | null
    /**
     * Filter, which PriceTestVariant to fetch.
     */
    where?: PriceTestVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceTestVariants to fetch.
     */
    orderBy?: PriceTestVariantOrderByWithRelationInput | PriceTestVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PriceTestVariants.
     */
    cursor?: PriceTestVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceTestVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceTestVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PriceTestVariants.
     */
    distinct?: PriceTestVariantScalarFieldEnum | PriceTestVariantScalarFieldEnum[]
  }

  /**
   * PriceTestVariant findFirstOrThrow
   */
  export type PriceTestVariantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceTestVariant
     */
    select?: PriceTestVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceTestVariantInclude<ExtArgs> | null
    /**
     * Filter, which PriceTestVariant to fetch.
     */
    where?: PriceTestVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceTestVariants to fetch.
     */
    orderBy?: PriceTestVariantOrderByWithRelationInput | PriceTestVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PriceTestVariants.
     */
    cursor?: PriceTestVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceTestVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceTestVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PriceTestVariants.
     */
    distinct?: PriceTestVariantScalarFieldEnum | PriceTestVariantScalarFieldEnum[]
  }

  /**
   * PriceTestVariant findMany
   */
  export type PriceTestVariantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceTestVariant
     */
    select?: PriceTestVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceTestVariantInclude<ExtArgs> | null
    /**
     * Filter, which PriceTestVariants to fetch.
     */
    where?: PriceTestVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceTestVariants to fetch.
     */
    orderBy?: PriceTestVariantOrderByWithRelationInput | PriceTestVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PriceTestVariants.
     */
    cursor?: PriceTestVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceTestVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceTestVariants.
     */
    skip?: number
    distinct?: PriceTestVariantScalarFieldEnum | PriceTestVariantScalarFieldEnum[]
  }

  /**
   * PriceTestVariant create
   */
  export type PriceTestVariantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceTestVariant
     */
    select?: PriceTestVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceTestVariantInclude<ExtArgs> | null
    /**
     * The data needed to create a PriceTestVariant.
     */
    data: XOR<PriceTestVariantCreateInput, PriceTestVariantUncheckedCreateInput>
  }

  /**
   * PriceTestVariant createMany
   */
  export type PriceTestVariantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PriceTestVariants.
     */
    data: PriceTestVariantCreateManyInput | PriceTestVariantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PriceTestVariant createManyAndReturn
   */
  export type PriceTestVariantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceTestVariant
     */
    select?: PriceTestVariantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PriceTestVariants.
     */
    data: PriceTestVariantCreateManyInput | PriceTestVariantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceTestVariantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PriceTestVariant update
   */
  export type PriceTestVariantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceTestVariant
     */
    select?: PriceTestVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceTestVariantInclude<ExtArgs> | null
    /**
     * The data needed to update a PriceTestVariant.
     */
    data: XOR<PriceTestVariantUpdateInput, PriceTestVariantUncheckedUpdateInput>
    /**
     * Choose, which PriceTestVariant to update.
     */
    where: PriceTestVariantWhereUniqueInput
  }

  /**
   * PriceTestVariant updateMany
   */
  export type PriceTestVariantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PriceTestVariants.
     */
    data: XOR<PriceTestVariantUpdateManyMutationInput, PriceTestVariantUncheckedUpdateManyInput>
    /**
     * Filter which PriceTestVariants to update
     */
    where?: PriceTestVariantWhereInput
  }

  /**
   * PriceTestVariant upsert
   */
  export type PriceTestVariantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceTestVariant
     */
    select?: PriceTestVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceTestVariantInclude<ExtArgs> | null
    /**
     * The filter to search for the PriceTestVariant to update in case it exists.
     */
    where: PriceTestVariantWhereUniqueInput
    /**
     * In case the PriceTestVariant found by the `where` argument doesn't exist, create a new PriceTestVariant with this data.
     */
    create: XOR<PriceTestVariantCreateInput, PriceTestVariantUncheckedCreateInput>
    /**
     * In case the PriceTestVariant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PriceTestVariantUpdateInput, PriceTestVariantUncheckedUpdateInput>
  }

  /**
   * PriceTestVariant delete
   */
  export type PriceTestVariantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceTestVariant
     */
    select?: PriceTestVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceTestVariantInclude<ExtArgs> | null
    /**
     * Filter which PriceTestVariant to delete.
     */
    where: PriceTestVariantWhereUniqueInput
  }

  /**
   * PriceTestVariant deleteMany
   */
  export type PriceTestVariantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PriceTestVariants to delete
     */
    where?: PriceTestVariantWhereInput
  }

  /**
   * PriceTestVariant without action
   */
  export type PriceTestVariantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceTestVariant
     */
    select?: PriceTestVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceTestVariantInclude<ExtArgs> | null
  }


  /**
   * Model MarketBenchmark
   */

  export type AggregateMarketBenchmark = {
    _count: MarketBenchmarkCountAggregateOutputType | null
    _avg: MarketBenchmarkAvgAggregateOutputType | null
    _sum: MarketBenchmarkSumAggregateOutputType | null
    _min: MarketBenchmarkMinAggregateOutputType | null
    _max: MarketBenchmarkMaxAggregateOutputType | null
  }

  export type MarketBenchmarkAvgAggregateOutputType = {
    avgPrice: number | null
    medianPrice: number | null
    minPrice: number | null
    maxPrice: number | null
    sampleSize: number | null
  }

  export type MarketBenchmarkSumAggregateOutputType = {
    avgPrice: number | null
    medianPrice: number | null
    minPrice: number | null
    maxPrice: number | null
    sampleSize: number | null
  }

  export type MarketBenchmarkMinAggregateOutputType = {
    id: string | null
    segment: string | null
    productType: string | null
    avgPrice: number | null
    medianPrice: number | null
    minPrice: number | null
    maxPrice: number | null
    sampleSize: number | null
    source: string | null
    collectedAt: Date | null
  }

  export type MarketBenchmarkMaxAggregateOutputType = {
    id: string | null
    segment: string | null
    productType: string | null
    avgPrice: number | null
    medianPrice: number | null
    minPrice: number | null
    maxPrice: number | null
    sampleSize: number | null
    source: string | null
    collectedAt: Date | null
  }

  export type MarketBenchmarkCountAggregateOutputType = {
    id: number
    segment: number
    productType: number
    avgPrice: number
    medianPrice: number
    minPrice: number
    maxPrice: number
    sampleSize: number
    source: number
    collectedAt: number
    metadata: number
    _all: number
  }


  export type MarketBenchmarkAvgAggregateInputType = {
    avgPrice?: true
    medianPrice?: true
    minPrice?: true
    maxPrice?: true
    sampleSize?: true
  }

  export type MarketBenchmarkSumAggregateInputType = {
    avgPrice?: true
    medianPrice?: true
    minPrice?: true
    maxPrice?: true
    sampleSize?: true
  }

  export type MarketBenchmarkMinAggregateInputType = {
    id?: true
    segment?: true
    productType?: true
    avgPrice?: true
    medianPrice?: true
    minPrice?: true
    maxPrice?: true
    sampleSize?: true
    source?: true
    collectedAt?: true
  }

  export type MarketBenchmarkMaxAggregateInputType = {
    id?: true
    segment?: true
    productType?: true
    avgPrice?: true
    medianPrice?: true
    minPrice?: true
    maxPrice?: true
    sampleSize?: true
    source?: true
    collectedAt?: true
  }

  export type MarketBenchmarkCountAggregateInputType = {
    id?: true
    segment?: true
    productType?: true
    avgPrice?: true
    medianPrice?: true
    minPrice?: true
    maxPrice?: true
    sampleSize?: true
    source?: true
    collectedAt?: true
    metadata?: true
    _all?: true
  }

  export type MarketBenchmarkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketBenchmark to aggregate.
     */
    where?: MarketBenchmarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketBenchmarks to fetch.
     */
    orderBy?: MarketBenchmarkOrderByWithRelationInput | MarketBenchmarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MarketBenchmarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketBenchmarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketBenchmarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MarketBenchmarks
    **/
    _count?: true | MarketBenchmarkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MarketBenchmarkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MarketBenchmarkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarketBenchmarkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarketBenchmarkMaxAggregateInputType
  }

  export type GetMarketBenchmarkAggregateType<T extends MarketBenchmarkAggregateArgs> = {
        [P in keyof T & keyof AggregateMarketBenchmark]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarketBenchmark[P]>
      : GetScalarType<T[P], AggregateMarketBenchmark[P]>
  }




  export type MarketBenchmarkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketBenchmarkWhereInput
    orderBy?: MarketBenchmarkOrderByWithAggregationInput | MarketBenchmarkOrderByWithAggregationInput[]
    by: MarketBenchmarkScalarFieldEnum[] | MarketBenchmarkScalarFieldEnum
    having?: MarketBenchmarkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarketBenchmarkCountAggregateInputType | true
    _avg?: MarketBenchmarkAvgAggregateInputType
    _sum?: MarketBenchmarkSumAggregateInputType
    _min?: MarketBenchmarkMinAggregateInputType
    _max?: MarketBenchmarkMaxAggregateInputType
  }

  export type MarketBenchmarkGroupByOutputType = {
    id: string
    segment: string
    productType: string
    avgPrice: number
    medianPrice: number
    minPrice: number
    maxPrice: number
    sampleSize: number
    source: string
    collectedAt: Date
    metadata: JsonValue | null
    _count: MarketBenchmarkCountAggregateOutputType | null
    _avg: MarketBenchmarkAvgAggregateOutputType | null
    _sum: MarketBenchmarkSumAggregateOutputType | null
    _min: MarketBenchmarkMinAggregateOutputType | null
    _max: MarketBenchmarkMaxAggregateOutputType | null
  }

  type GetMarketBenchmarkGroupByPayload<T extends MarketBenchmarkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MarketBenchmarkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarketBenchmarkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarketBenchmarkGroupByOutputType[P]>
            : GetScalarType<T[P], MarketBenchmarkGroupByOutputType[P]>
        }
      >
    >


  export type MarketBenchmarkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    segment?: boolean
    productType?: boolean
    avgPrice?: boolean
    medianPrice?: boolean
    minPrice?: boolean
    maxPrice?: boolean
    sampleSize?: boolean
    source?: boolean
    collectedAt?: boolean
    metadata?: boolean
  }, ExtArgs["result"]["marketBenchmark"]>

  export type MarketBenchmarkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    segment?: boolean
    productType?: boolean
    avgPrice?: boolean
    medianPrice?: boolean
    minPrice?: boolean
    maxPrice?: boolean
    sampleSize?: boolean
    source?: boolean
    collectedAt?: boolean
    metadata?: boolean
  }, ExtArgs["result"]["marketBenchmark"]>

  export type MarketBenchmarkSelectScalar = {
    id?: boolean
    segment?: boolean
    productType?: boolean
    avgPrice?: boolean
    medianPrice?: boolean
    minPrice?: boolean
    maxPrice?: boolean
    sampleSize?: boolean
    source?: boolean
    collectedAt?: boolean
    metadata?: boolean
  }


  export type $MarketBenchmarkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MarketBenchmark"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      segment: string
      productType: string
      avgPrice: number
      medianPrice: number
      minPrice: number
      maxPrice: number
      sampleSize: number
      source: string
      collectedAt: Date
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["marketBenchmark"]>
    composites: {}
  }

  type MarketBenchmarkGetPayload<S extends boolean | null | undefined | MarketBenchmarkDefaultArgs> = $Result.GetResult<Prisma.$MarketBenchmarkPayload, S>

  type MarketBenchmarkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MarketBenchmarkFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MarketBenchmarkCountAggregateInputType | true
    }

  export interface MarketBenchmarkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MarketBenchmark'], meta: { name: 'MarketBenchmark' } }
    /**
     * Find zero or one MarketBenchmark that matches the filter.
     * @param {MarketBenchmarkFindUniqueArgs} args - Arguments to find a MarketBenchmark
     * @example
     * // Get one MarketBenchmark
     * const marketBenchmark = await prisma.marketBenchmark.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MarketBenchmarkFindUniqueArgs>(args: SelectSubset<T, MarketBenchmarkFindUniqueArgs<ExtArgs>>): Prisma__MarketBenchmarkClient<$Result.GetResult<Prisma.$MarketBenchmarkPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MarketBenchmark that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MarketBenchmarkFindUniqueOrThrowArgs} args - Arguments to find a MarketBenchmark
     * @example
     * // Get one MarketBenchmark
     * const marketBenchmark = await prisma.marketBenchmark.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MarketBenchmarkFindUniqueOrThrowArgs>(args: SelectSubset<T, MarketBenchmarkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MarketBenchmarkClient<$Result.GetResult<Prisma.$MarketBenchmarkPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MarketBenchmark that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketBenchmarkFindFirstArgs} args - Arguments to find a MarketBenchmark
     * @example
     * // Get one MarketBenchmark
     * const marketBenchmark = await prisma.marketBenchmark.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MarketBenchmarkFindFirstArgs>(args?: SelectSubset<T, MarketBenchmarkFindFirstArgs<ExtArgs>>): Prisma__MarketBenchmarkClient<$Result.GetResult<Prisma.$MarketBenchmarkPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MarketBenchmark that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketBenchmarkFindFirstOrThrowArgs} args - Arguments to find a MarketBenchmark
     * @example
     * // Get one MarketBenchmark
     * const marketBenchmark = await prisma.marketBenchmark.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MarketBenchmarkFindFirstOrThrowArgs>(args?: SelectSubset<T, MarketBenchmarkFindFirstOrThrowArgs<ExtArgs>>): Prisma__MarketBenchmarkClient<$Result.GetResult<Prisma.$MarketBenchmarkPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MarketBenchmarks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketBenchmarkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MarketBenchmarks
     * const marketBenchmarks = await prisma.marketBenchmark.findMany()
     * 
     * // Get first 10 MarketBenchmarks
     * const marketBenchmarks = await prisma.marketBenchmark.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marketBenchmarkWithIdOnly = await prisma.marketBenchmark.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MarketBenchmarkFindManyArgs>(args?: SelectSubset<T, MarketBenchmarkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketBenchmarkPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MarketBenchmark.
     * @param {MarketBenchmarkCreateArgs} args - Arguments to create a MarketBenchmark.
     * @example
     * // Create one MarketBenchmark
     * const MarketBenchmark = await prisma.marketBenchmark.create({
     *   data: {
     *     // ... data to create a MarketBenchmark
     *   }
     * })
     * 
     */
    create<T extends MarketBenchmarkCreateArgs>(args: SelectSubset<T, MarketBenchmarkCreateArgs<ExtArgs>>): Prisma__MarketBenchmarkClient<$Result.GetResult<Prisma.$MarketBenchmarkPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MarketBenchmarks.
     * @param {MarketBenchmarkCreateManyArgs} args - Arguments to create many MarketBenchmarks.
     * @example
     * // Create many MarketBenchmarks
     * const marketBenchmark = await prisma.marketBenchmark.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MarketBenchmarkCreateManyArgs>(args?: SelectSubset<T, MarketBenchmarkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MarketBenchmarks and returns the data saved in the database.
     * @param {MarketBenchmarkCreateManyAndReturnArgs} args - Arguments to create many MarketBenchmarks.
     * @example
     * // Create many MarketBenchmarks
     * const marketBenchmark = await prisma.marketBenchmark.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MarketBenchmarks and only return the `id`
     * const marketBenchmarkWithIdOnly = await prisma.marketBenchmark.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MarketBenchmarkCreateManyAndReturnArgs>(args?: SelectSubset<T, MarketBenchmarkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketBenchmarkPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MarketBenchmark.
     * @param {MarketBenchmarkDeleteArgs} args - Arguments to delete one MarketBenchmark.
     * @example
     * // Delete one MarketBenchmark
     * const MarketBenchmark = await prisma.marketBenchmark.delete({
     *   where: {
     *     // ... filter to delete one MarketBenchmark
     *   }
     * })
     * 
     */
    delete<T extends MarketBenchmarkDeleteArgs>(args: SelectSubset<T, MarketBenchmarkDeleteArgs<ExtArgs>>): Prisma__MarketBenchmarkClient<$Result.GetResult<Prisma.$MarketBenchmarkPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MarketBenchmark.
     * @param {MarketBenchmarkUpdateArgs} args - Arguments to update one MarketBenchmark.
     * @example
     * // Update one MarketBenchmark
     * const marketBenchmark = await prisma.marketBenchmark.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MarketBenchmarkUpdateArgs>(args: SelectSubset<T, MarketBenchmarkUpdateArgs<ExtArgs>>): Prisma__MarketBenchmarkClient<$Result.GetResult<Prisma.$MarketBenchmarkPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MarketBenchmarks.
     * @param {MarketBenchmarkDeleteManyArgs} args - Arguments to filter MarketBenchmarks to delete.
     * @example
     * // Delete a few MarketBenchmarks
     * const { count } = await prisma.marketBenchmark.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MarketBenchmarkDeleteManyArgs>(args?: SelectSubset<T, MarketBenchmarkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketBenchmarks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketBenchmarkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MarketBenchmarks
     * const marketBenchmark = await prisma.marketBenchmark.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MarketBenchmarkUpdateManyArgs>(args: SelectSubset<T, MarketBenchmarkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MarketBenchmark.
     * @param {MarketBenchmarkUpsertArgs} args - Arguments to update or create a MarketBenchmark.
     * @example
     * // Update or create a MarketBenchmark
     * const marketBenchmark = await prisma.marketBenchmark.upsert({
     *   create: {
     *     // ... data to create a MarketBenchmark
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MarketBenchmark we want to update
     *   }
     * })
     */
    upsert<T extends MarketBenchmarkUpsertArgs>(args: SelectSubset<T, MarketBenchmarkUpsertArgs<ExtArgs>>): Prisma__MarketBenchmarkClient<$Result.GetResult<Prisma.$MarketBenchmarkPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MarketBenchmarks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketBenchmarkCountArgs} args - Arguments to filter MarketBenchmarks to count.
     * @example
     * // Count the number of MarketBenchmarks
     * const count = await prisma.marketBenchmark.count({
     *   where: {
     *     // ... the filter for the MarketBenchmarks we want to count
     *   }
     * })
    **/
    count<T extends MarketBenchmarkCountArgs>(
      args?: Subset<T, MarketBenchmarkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarketBenchmarkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MarketBenchmark.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketBenchmarkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarketBenchmarkAggregateArgs>(args: Subset<T, MarketBenchmarkAggregateArgs>): Prisma.PrismaPromise<GetMarketBenchmarkAggregateType<T>>

    /**
     * Group by MarketBenchmark.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketBenchmarkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarketBenchmarkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarketBenchmarkGroupByArgs['orderBy'] }
        : { orderBy?: MarketBenchmarkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarketBenchmarkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarketBenchmarkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MarketBenchmark model
   */
  readonly fields: MarketBenchmarkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MarketBenchmark.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MarketBenchmarkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MarketBenchmark model
   */ 
  interface MarketBenchmarkFieldRefs {
    readonly id: FieldRef<"MarketBenchmark", 'String'>
    readonly segment: FieldRef<"MarketBenchmark", 'String'>
    readonly productType: FieldRef<"MarketBenchmark", 'String'>
    readonly avgPrice: FieldRef<"MarketBenchmark", 'Float'>
    readonly medianPrice: FieldRef<"MarketBenchmark", 'Float'>
    readonly minPrice: FieldRef<"MarketBenchmark", 'Float'>
    readonly maxPrice: FieldRef<"MarketBenchmark", 'Float'>
    readonly sampleSize: FieldRef<"MarketBenchmark", 'Int'>
    readonly source: FieldRef<"MarketBenchmark", 'String'>
    readonly collectedAt: FieldRef<"MarketBenchmark", 'DateTime'>
    readonly metadata: FieldRef<"MarketBenchmark", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * MarketBenchmark findUnique
   */
  export type MarketBenchmarkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketBenchmark
     */
    select?: MarketBenchmarkSelect<ExtArgs> | null
    /**
     * Filter, which MarketBenchmark to fetch.
     */
    where: MarketBenchmarkWhereUniqueInput
  }

  /**
   * MarketBenchmark findUniqueOrThrow
   */
  export type MarketBenchmarkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketBenchmark
     */
    select?: MarketBenchmarkSelect<ExtArgs> | null
    /**
     * Filter, which MarketBenchmark to fetch.
     */
    where: MarketBenchmarkWhereUniqueInput
  }

  /**
   * MarketBenchmark findFirst
   */
  export type MarketBenchmarkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketBenchmark
     */
    select?: MarketBenchmarkSelect<ExtArgs> | null
    /**
     * Filter, which MarketBenchmark to fetch.
     */
    where?: MarketBenchmarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketBenchmarks to fetch.
     */
    orderBy?: MarketBenchmarkOrderByWithRelationInput | MarketBenchmarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketBenchmarks.
     */
    cursor?: MarketBenchmarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketBenchmarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketBenchmarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketBenchmarks.
     */
    distinct?: MarketBenchmarkScalarFieldEnum | MarketBenchmarkScalarFieldEnum[]
  }

  /**
   * MarketBenchmark findFirstOrThrow
   */
  export type MarketBenchmarkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketBenchmark
     */
    select?: MarketBenchmarkSelect<ExtArgs> | null
    /**
     * Filter, which MarketBenchmark to fetch.
     */
    where?: MarketBenchmarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketBenchmarks to fetch.
     */
    orderBy?: MarketBenchmarkOrderByWithRelationInput | MarketBenchmarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketBenchmarks.
     */
    cursor?: MarketBenchmarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketBenchmarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketBenchmarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketBenchmarks.
     */
    distinct?: MarketBenchmarkScalarFieldEnum | MarketBenchmarkScalarFieldEnum[]
  }

  /**
   * MarketBenchmark findMany
   */
  export type MarketBenchmarkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketBenchmark
     */
    select?: MarketBenchmarkSelect<ExtArgs> | null
    /**
     * Filter, which MarketBenchmarks to fetch.
     */
    where?: MarketBenchmarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketBenchmarks to fetch.
     */
    orderBy?: MarketBenchmarkOrderByWithRelationInput | MarketBenchmarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MarketBenchmarks.
     */
    cursor?: MarketBenchmarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketBenchmarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketBenchmarks.
     */
    skip?: number
    distinct?: MarketBenchmarkScalarFieldEnum | MarketBenchmarkScalarFieldEnum[]
  }

  /**
   * MarketBenchmark create
   */
  export type MarketBenchmarkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketBenchmark
     */
    select?: MarketBenchmarkSelect<ExtArgs> | null
    /**
     * The data needed to create a MarketBenchmark.
     */
    data: XOR<MarketBenchmarkCreateInput, MarketBenchmarkUncheckedCreateInput>
  }

  /**
   * MarketBenchmark createMany
   */
  export type MarketBenchmarkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MarketBenchmarks.
     */
    data: MarketBenchmarkCreateManyInput | MarketBenchmarkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MarketBenchmark createManyAndReturn
   */
  export type MarketBenchmarkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketBenchmark
     */
    select?: MarketBenchmarkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MarketBenchmarks.
     */
    data: MarketBenchmarkCreateManyInput | MarketBenchmarkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MarketBenchmark update
   */
  export type MarketBenchmarkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketBenchmark
     */
    select?: MarketBenchmarkSelect<ExtArgs> | null
    /**
     * The data needed to update a MarketBenchmark.
     */
    data: XOR<MarketBenchmarkUpdateInput, MarketBenchmarkUncheckedUpdateInput>
    /**
     * Choose, which MarketBenchmark to update.
     */
    where: MarketBenchmarkWhereUniqueInput
  }

  /**
   * MarketBenchmark updateMany
   */
  export type MarketBenchmarkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MarketBenchmarks.
     */
    data: XOR<MarketBenchmarkUpdateManyMutationInput, MarketBenchmarkUncheckedUpdateManyInput>
    /**
     * Filter which MarketBenchmarks to update
     */
    where?: MarketBenchmarkWhereInput
  }

  /**
   * MarketBenchmark upsert
   */
  export type MarketBenchmarkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketBenchmark
     */
    select?: MarketBenchmarkSelect<ExtArgs> | null
    /**
     * The filter to search for the MarketBenchmark to update in case it exists.
     */
    where: MarketBenchmarkWhereUniqueInput
    /**
     * In case the MarketBenchmark found by the `where` argument doesn't exist, create a new MarketBenchmark with this data.
     */
    create: XOR<MarketBenchmarkCreateInput, MarketBenchmarkUncheckedCreateInput>
    /**
     * In case the MarketBenchmark was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarketBenchmarkUpdateInput, MarketBenchmarkUncheckedUpdateInput>
  }

  /**
   * MarketBenchmark delete
   */
  export type MarketBenchmarkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketBenchmark
     */
    select?: MarketBenchmarkSelect<ExtArgs> | null
    /**
     * Filter which MarketBenchmark to delete.
     */
    where: MarketBenchmarkWhereUniqueInput
  }

  /**
   * MarketBenchmark deleteMany
   */
  export type MarketBenchmarkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketBenchmarks to delete
     */
    where?: MarketBenchmarkWhereInput
  }

  /**
   * MarketBenchmark without action
   */
  export type MarketBenchmarkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketBenchmark
     */
    select?: MarketBenchmarkSelect<ExtArgs> | null
  }


  /**
   * Model RevenueRecognitionRule
   */

  export type AggregateRevenueRecognitionRule = {
    _count: RevenueRecognitionRuleCountAggregateOutputType | null
    _avg: RevenueRecognitionRuleAvgAggregateOutputType | null
    _sum: RevenueRecognitionRuleSumAggregateOutputType | null
    _min: RevenueRecognitionRuleMinAggregateOutputType | null
    _max: RevenueRecognitionRuleMaxAggregateOutputType | null
  }

  export type RevenueRecognitionRuleAvgAggregateOutputType = {
    deferralPeriod: number | null
  }

  export type RevenueRecognitionRuleSumAggregateOutputType = {
    deferralPeriod: number | null
  }

  export type RevenueRecognitionRuleMinAggregateOutputType = {
    id: string | null
    planId: string | null
    type: string | null
    deferralPeriod: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RevenueRecognitionRuleMaxAggregateOutputType = {
    id: string | null
    planId: string | null
    type: string | null
    deferralPeriod: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RevenueRecognitionRuleCountAggregateOutputType = {
    id: number
    planId: number
    type: number
    deferralPeriod: number
    conditions: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RevenueRecognitionRuleAvgAggregateInputType = {
    deferralPeriod?: true
  }

  export type RevenueRecognitionRuleSumAggregateInputType = {
    deferralPeriod?: true
  }

  export type RevenueRecognitionRuleMinAggregateInputType = {
    id?: true
    planId?: true
    type?: true
    deferralPeriod?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RevenueRecognitionRuleMaxAggregateInputType = {
    id?: true
    planId?: true
    type?: true
    deferralPeriod?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RevenueRecognitionRuleCountAggregateInputType = {
    id?: true
    planId?: true
    type?: true
    deferralPeriod?: true
    conditions?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RevenueRecognitionRuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RevenueRecognitionRule to aggregate.
     */
    where?: RevenueRecognitionRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RevenueRecognitionRules to fetch.
     */
    orderBy?: RevenueRecognitionRuleOrderByWithRelationInput | RevenueRecognitionRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RevenueRecognitionRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RevenueRecognitionRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RevenueRecognitionRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RevenueRecognitionRules
    **/
    _count?: true | RevenueRecognitionRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RevenueRecognitionRuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RevenueRecognitionRuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RevenueRecognitionRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RevenueRecognitionRuleMaxAggregateInputType
  }

  export type GetRevenueRecognitionRuleAggregateType<T extends RevenueRecognitionRuleAggregateArgs> = {
        [P in keyof T & keyof AggregateRevenueRecognitionRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRevenueRecognitionRule[P]>
      : GetScalarType<T[P], AggregateRevenueRecognitionRule[P]>
  }




  export type RevenueRecognitionRuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RevenueRecognitionRuleWhereInput
    orderBy?: RevenueRecognitionRuleOrderByWithAggregationInput | RevenueRecognitionRuleOrderByWithAggregationInput[]
    by: RevenueRecognitionRuleScalarFieldEnum[] | RevenueRecognitionRuleScalarFieldEnum
    having?: RevenueRecognitionRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RevenueRecognitionRuleCountAggregateInputType | true
    _avg?: RevenueRecognitionRuleAvgAggregateInputType
    _sum?: RevenueRecognitionRuleSumAggregateInputType
    _min?: RevenueRecognitionRuleMinAggregateInputType
    _max?: RevenueRecognitionRuleMaxAggregateInputType
  }

  export type RevenueRecognitionRuleGroupByOutputType = {
    id: string
    planId: string
    type: string
    deferralPeriod: number | null
    conditions: JsonValue | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: RevenueRecognitionRuleCountAggregateOutputType | null
    _avg: RevenueRecognitionRuleAvgAggregateOutputType | null
    _sum: RevenueRecognitionRuleSumAggregateOutputType | null
    _min: RevenueRecognitionRuleMinAggregateOutputType | null
    _max: RevenueRecognitionRuleMaxAggregateOutputType | null
  }

  type GetRevenueRecognitionRuleGroupByPayload<T extends RevenueRecognitionRuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RevenueRecognitionRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RevenueRecognitionRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RevenueRecognitionRuleGroupByOutputType[P]>
            : GetScalarType<T[P], RevenueRecognitionRuleGroupByOutputType[P]>
        }
      >
    >


  export type RevenueRecognitionRuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    type?: boolean
    deferralPeriod?: boolean
    conditions?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["revenueRecognitionRule"]>

  export type RevenueRecognitionRuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    type?: boolean
    deferralPeriod?: boolean
    conditions?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["revenueRecognitionRule"]>

  export type RevenueRecognitionRuleSelectScalar = {
    id?: boolean
    planId?: boolean
    type?: boolean
    deferralPeriod?: boolean
    conditions?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RevenueRecognitionRuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }
  export type RevenueRecognitionRuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }

  export type $RevenueRecognitionRulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RevenueRecognitionRule"
    objects: {
      plan: Prisma.$PlanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      planId: string
      type: string
      deferralPeriod: number | null
      conditions: Prisma.JsonValue | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["revenueRecognitionRule"]>
    composites: {}
  }

  type RevenueRecognitionRuleGetPayload<S extends boolean | null | undefined | RevenueRecognitionRuleDefaultArgs> = $Result.GetResult<Prisma.$RevenueRecognitionRulePayload, S>

  type RevenueRecognitionRuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RevenueRecognitionRuleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RevenueRecognitionRuleCountAggregateInputType | true
    }

  export interface RevenueRecognitionRuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RevenueRecognitionRule'], meta: { name: 'RevenueRecognitionRule' } }
    /**
     * Find zero or one RevenueRecognitionRule that matches the filter.
     * @param {RevenueRecognitionRuleFindUniqueArgs} args - Arguments to find a RevenueRecognitionRule
     * @example
     * // Get one RevenueRecognitionRule
     * const revenueRecognitionRule = await prisma.revenueRecognitionRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RevenueRecognitionRuleFindUniqueArgs>(args: SelectSubset<T, RevenueRecognitionRuleFindUniqueArgs<ExtArgs>>): Prisma__RevenueRecognitionRuleClient<$Result.GetResult<Prisma.$RevenueRecognitionRulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RevenueRecognitionRule that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RevenueRecognitionRuleFindUniqueOrThrowArgs} args - Arguments to find a RevenueRecognitionRule
     * @example
     * // Get one RevenueRecognitionRule
     * const revenueRecognitionRule = await prisma.revenueRecognitionRule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RevenueRecognitionRuleFindUniqueOrThrowArgs>(args: SelectSubset<T, RevenueRecognitionRuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RevenueRecognitionRuleClient<$Result.GetResult<Prisma.$RevenueRecognitionRulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RevenueRecognitionRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueRecognitionRuleFindFirstArgs} args - Arguments to find a RevenueRecognitionRule
     * @example
     * // Get one RevenueRecognitionRule
     * const revenueRecognitionRule = await prisma.revenueRecognitionRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RevenueRecognitionRuleFindFirstArgs>(args?: SelectSubset<T, RevenueRecognitionRuleFindFirstArgs<ExtArgs>>): Prisma__RevenueRecognitionRuleClient<$Result.GetResult<Prisma.$RevenueRecognitionRulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RevenueRecognitionRule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueRecognitionRuleFindFirstOrThrowArgs} args - Arguments to find a RevenueRecognitionRule
     * @example
     * // Get one RevenueRecognitionRule
     * const revenueRecognitionRule = await prisma.revenueRecognitionRule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RevenueRecognitionRuleFindFirstOrThrowArgs>(args?: SelectSubset<T, RevenueRecognitionRuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RevenueRecognitionRuleClient<$Result.GetResult<Prisma.$RevenueRecognitionRulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RevenueRecognitionRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueRecognitionRuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RevenueRecognitionRules
     * const revenueRecognitionRules = await prisma.revenueRecognitionRule.findMany()
     * 
     * // Get first 10 RevenueRecognitionRules
     * const revenueRecognitionRules = await prisma.revenueRecognitionRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const revenueRecognitionRuleWithIdOnly = await prisma.revenueRecognitionRule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RevenueRecognitionRuleFindManyArgs>(args?: SelectSubset<T, RevenueRecognitionRuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RevenueRecognitionRulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RevenueRecognitionRule.
     * @param {RevenueRecognitionRuleCreateArgs} args - Arguments to create a RevenueRecognitionRule.
     * @example
     * // Create one RevenueRecognitionRule
     * const RevenueRecognitionRule = await prisma.revenueRecognitionRule.create({
     *   data: {
     *     // ... data to create a RevenueRecognitionRule
     *   }
     * })
     * 
     */
    create<T extends RevenueRecognitionRuleCreateArgs>(args: SelectSubset<T, RevenueRecognitionRuleCreateArgs<ExtArgs>>): Prisma__RevenueRecognitionRuleClient<$Result.GetResult<Prisma.$RevenueRecognitionRulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RevenueRecognitionRules.
     * @param {RevenueRecognitionRuleCreateManyArgs} args - Arguments to create many RevenueRecognitionRules.
     * @example
     * // Create many RevenueRecognitionRules
     * const revenueRecognitionRule = await prisma.revenueRecognitionRule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RevenueRecognitionRuleCreateManyArgs>(args?: SelectSubset<T, RevenueRecognitionRuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RevenueRecognitionRules and returns the data saved in the database.
     * @param {RevenueRecognitionRuleCreateManyAndReturnArgs} args - Arguments to create many RevenueRecognitionRules.
     * @example
     * // Create many RevenueRecognitionRules
     * const revenueRecognitionRule = await prisma.revenueRecognitionRule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RevenueRecognitionRules and only return the `id`
     * const revenueRecognitionRuleWithIdOnly = await prisma.revenueRecognitionRule.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RevenueRecognitionRuleCreateManyAndReturnArgs>(args?: SelectSubset<T, RevenueRecognitionRuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RevenueRecognitionRulePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RevenueRecognitionRule.
     * @param {RevenueRecognitionRuleDeleteArgs} args - Arguments to delete one RevenueRecognitionRule.
     * @example
     * // Delete one RevenueRecognitionRule
     * const RevenueRecognitionRule = await prisma.revenueRecognitionRule.delete({
     *   where: {
     *     // ... filter to delete one RevenueRecognitionRule
     *   }
     * })
     * 
     */
    delete<T extends RevenueRecognitionRuleDeleteArgs>(args: SelectSubset<T, RevenueRecognitionRuleDeleteArgs<ExtArgs>>): Prisma__RevenueRecognitionRuleClient<$Result.GetResult<Prisma.$RevenueRecognitionRulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RevenueRecognitionRule.
     * @param {RevenueRecognitionRuleUpdateArgs} args - Arguments to update one RevenueRecognitionRule.
     * @example
     * // Update one RevenueRecognitionRule
     * const revenueRecognitionRule = await prisma.revenueRecognitionRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RevenueRecognitionRuleUpdateArgs>(args: SelectSubset<T, RevenueRecognitionRuleUpdateArgs<ExtArgs>>): Prisma__RevenueRecognitionRuleClient<$Result.GetResult<Prisma.$RevenueRecognitionRulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RevenueRecognitionRules.
     * @param {RevenueRecognitionRuleDeleteManyArgs} args - Arguments to filter RevenueRecognitionRules to delete.
     * @example
     * // Delete a few RevenueRecognitionRules
     * const { count } = await prisma.revenueRecognitionRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RevenueRecognitionRuleDeleteManyArgs>(args?: SelectSubset<T, RevenueRecognitionRuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RevenueRecognitionRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueRecognitionRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RevenueRecognitionRules
     * const revenueRecognitionRule = await prisma.revenueRecognitionRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RevenueRecognitionRuleUpdateManyArgs>(args: SelectSubset<T, RevenueRecognitionRuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RevenueRecognitionRule.
     * @param {RevenueRecognitionRuleUpsertArgs} args - Arguments to update or create a RevenueRecognitionRule.
     * @example
     * // Update or create a RevenueRecognitionRule
     * const revenueRecognitionRule = await prisma.revenueRecognitionRule.upsert({
     *   create: {
     *     // ... data to create a RevenueRecognitionRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RevenueRecognitionRule we want to update
     *   }
     * })
     */
    upsert<T extends RevenueRecognitionRuleUpsertArgs>(args: SelectSubset<T, RevenueRecognitionRuleUpsertArgs<ExtArgs>>): Prisma__RevenueRecognitionRuleClient<$Result.GetResult<Prisma.$RevenueRecognitionRulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RevenueRecognitionRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueRecognitionRuleCountArgs} args - Arguments to filter RevenueRecognitionRules to count.
     * @example
     * // Count the number of RevenueRecognitionRules
     * const count = await prisma.revenueRecognitionRule.count({
     *   where: {
     *     // ... the filter for the RevenueRecognitionRules we want to count
     *   }
     * })
    **/
    count<T extends RevenueRecognitionRuleCountArgs>(
      args?: Subset<T, RevenueRecognitionRuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RevenueRecognitionRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RevenueRecognitionRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueRecognitionRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RevenueRecognitionRuleAggregateArgs>(args: Subset<T, RevenueRecognitionRuleAggregateArgs>): Prisma.PrismaPromise<GetRevenueRecognitionRuleAggregateType<T>>

    /**
     * Group by RevenueRecognitionRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueRecognitionRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RevenueRecognitionRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RevenueRecognitionRuleGroupByArgs['orderBy'] }
        : { orderBy?: RevenueRecognitionRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RevenueRecognitionRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRevenueRecognitionRuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RevenueRecognitionRule model
   */
  readonly fields: RevenueRecognitionRuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RevenueRecognitionRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RevenueRecognitionRuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plan<T extends PlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlanDefaultArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RevenueRecognitionRule model
   */ 
  interface RevenueRecognitionRuleFieldRefs {
    readonly id: FieldRef<"RevenueRecognitionRule", 'String'>
    readonly planId: FieldRef<"RevenueRecognitionRule", 'String'>
    readonly type: FieldRef<"RevenueRecognitionRule", 'String'>
    readonly deferralPeriod: FieldRef<"RevenueRecognitionRule", 'Int'>
    readonly conditions: FieldRef<"RevenueRecognitionRule", 'Json'>
    readonly metadata: FieldRef<"RevenueRecognitionRule", 'Json'>
    readonly createdAt: FieldRef<"RevenueRecognitionRule", 'DateTime'>
    readonly updatedAt: FieldRef<"RevenueRecognitionRule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RevenueRecognitionRule findUnique
   */
  export type RevenueRecognitionRuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueRecognitionRule
     */
    select?: RevenueRecognitionRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueRecognitionRuleInclude<ExtArgs> | null
    /**
     * Filter, which RevenueRecognitionRule to fetch.
     */
    where: RevenueRecognitionRuleWhereUniqueInput
  }

  /**
   * RevenueRecognitionRule findUniqueOrThrow
   */
  export type RevenueRecognitionRuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueRecognitionRule
     */
    select?: RevenueRecognitionRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueRecognitionRuleInclude<ExtArgs> | null
    /**
     * Filter, which RevenueRecognitionRule to fetch.
     */
    where: RevenueRecognitionRuleWhereUniqueInput
  }

  /**
   * RevenueRecognitionRule findFirst
   */
  export type RevenueRecognitionRuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueRecognitionRule
     */
    select?: RevenueRecognitionRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueRecognitionRuleInclude<ExtArgs> | null
    /**
     * Filter, which RevenueRecognitionRule to fetch.
     */
    where?: RevenueRecognitionRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RevenueRecognitionRules to fetch.
     */
    orderBy?: RevenueRecognitionRuleOrderByWithRelationInput | RevenueRecognitionRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RevenueRecognitionRules.
     */
    cursor?: RevenueRecognitionRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RevenueRecognitionRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RevenueRecognitionRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RevenueRecognitionRules.
     */
    distinct?: RevenueRecognitionRuleScalarFieldEnum | RevenueRecognitionRuleScalarFieldEnum[]
  }

  /**
   * RevenueRecognitionRule findFirstOrThrow
   */
  export type RevenueRecognitionRuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueRecognitionRule
     */
    select?: RevenueRecognitionRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueRecognitionRuleInclude<ExtArgs> | null
    /**
     * Filter, which RevenueRecognitionRule to fetch.
     */
    where?: RevenueRecognitionRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RevenueRecognitionRules to fetch.
     */
    orderBy?: RevenueRecognitionRuleOrderByWithRelationInput | RevenueRecognitionRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RevenueRecognitionRules.
     */
    cursor?: RevenueRecognitionRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RevenueRecognitionRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RevenueRecognitionRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RevenueRecognitionRules.
     */
    distinct?: RevenueRecognitionRuleScalarFieldEnum | RevenueRecognitionRuleScalarFieldEnum[]
  }

  /**
   * RevenueRecognitionRule findMany
   */
  export type RevenueRecognitionRuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueRecognitionRule
     */
    select?: RevenueRecognitionRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueRecognitionRuleInclude<ExtArgs> | null
    /**
     * Filter, which RevenueRecognitionRules to fetch.
     */
    where?: RevenueRecognitionRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RevenueRecognitionRules to fetch.
     */
    orderBy?: RevenueRecognitionRuleOrderByWithRelationInput | RevenueRecognitionRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RevenueRecognitionRules.
     */
    cursor?: RevenueRecognitionRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RevenueRecognitionRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RevenueRecognitionRules.
     */
    skip?: number
    distinct?: RevenueRecognitionRuleScalarFieldEnum | RevenueRecognitionRuleScalarFieldEnum[]
  }

  /**
   * RevenueRecognitionRule create
   */
  export type RevenueRecognitionRuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueRecognitionRule
     */
    select?: RevenueRecognitionRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueRecognitionRuleInclude<ExtArgs> | null
    /**
     * The data needed to create a RevenueRecognitionRule.
     */
    data: XOR<RevenueRecognitionRuleCreateInput, RevenueRecognitionRuleUncheckedCreateInput>
  }

  /**
   * RevenueRecognitionRule createMany
   */
  export type RevenueRecognitionRuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RevenueRecognitionRules.
     */
    data: RevenueRecognitionRuleCreateManyInput | RevenueRecognitionRuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RevenueRecognitionRule createManyAndReturn
   */
  export type RevenueRecognitionRuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueRecognitionRule
     */
    select?: RevenueRecognitionRuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RevenueRecognitionRules.
     */
    data: RevenueRecognitionRuleCreateManyInput | RevenueRecognitionRuleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueRecognitionRuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RevenueRecognitionRule update
   */
  export type RevenueRecognitionRuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueRecognitionRule
     */
    select?: RevenueRecognitionRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueRecognitionRuleInclude<ExtArgs> | null
    /**
     * The data needed to update a RevenueRecognitionRule.
     */
    data: XOR<RevenueRecognitionRuleUpdateInput, RevenueRecognitionRuleUncheckedUpdateInput>
    /**
     * Choose, which RevenueRecognitionRule to update.
     */
    where: RevenueRecognitionRuleWhereUniqueInput
  }

  /**
   * RevenueRecognitionRule updateMany
   */
  export type RevenueRecognitionRuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RevenueRecognitionRules.
     */
    data: XOR<RevenueRecognitionRuleUpdateManyMutationInput, RevenueRecognitionRuleUncheckedUpdateManyInput>
    /**
     * Filter which RevenueRecognitionRules to update
     */
    where?: RevenueRecognitionRuleWhereInput
  }

  /**
   * RevenueRecognitionRule upsert
   */
  export type RevenueRecognitionRuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueRecognitionRule
     */
    select?: RevenueRecognitionRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueRecognitionRuleInclude<ExtArgs> | null
    /**
     * The filter to search for the RevenueRecognitionRule to update in case it exists.
     */
    where: RevenueRecognitionRuleWhereUniqueInput
    /**
     * In case the RevenueRecognitionRule found by the `where` argument doesn't exist, create a new RevenueRecognitionRule with this data.
     */
    create: XOR<RevenueRecognitionRuleCreateInput, RevenueRecognitionRuleUncheckedCreateInput>
    /**
     * In case the RevenueRecognitionRule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RevenueRecognitionRuleUpdateInput, RevenueRecognitionRuleUncheckedUpdateInput>
  }

  /**
   * RevenueRecognitionRule delete
   */
  export type RevenueRecognitionRuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueRecognitionRule
     */
    select?: RevenueRecognitionRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueRecognitionRuleInclude<ExtArgs> | null
    /**
     * Filter which RevenueRecognitionRule to delete.
     */
    where: RevenueRecognitionRuleWhereUniqueInput
  }

  /**
   * RevenueRecognitionRule deleteMany
   */
  export type RevenueRecognitionRuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RevenueRecognitionRules to delete
     */
    where?: RevenueRecognitionRuleWhereInput
  }

  /**
   * RevenueRecognitionRule without action
   */
  export type RevenueRecognitionRuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueRecognitionRule
     */
    select?: RevenueRecognitionRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueRecognitionRuleInclude<ExtArgs> | null
  }


  /**
   * Model RevenueLedger
   */

  export type AggregateRevenueLedger = {
    _count: RevenueLedgerCountAggregateOutputType | null
    _avg: RevenueLedgerAvgAggregateOutputType | null
    _sum: RevenueLedgerSumAggregateOutputType | null
    _min: RevenueLedgerMinAggregateOutputType | null
    _max: RevenueLedgerMaxAggregateOutputType | null
  }

  export type RevenueLedgerAvgAggregateOutputType = {
    amount: number | null
    deferredAmount: number | null
  }

  export type RevenueLedgerSumAggregateOutputType = {
    amount: number | null
    deferredAmount: number | null
  }

  export type RevenueLedgerMinAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    amount: number | null
    currency: string | null
    recognizedDate: Date | null
    deferredAmount: number | null
    deferredUntil: Date | null
    type: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RevenueLedgerMaxAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    amount: number | null
    currency: string | null
    recognizedDate: Date | null
    deferredAmount: number | null
    deferredUntil: Date | null
    type: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RevenueLedgerCountAggregateOutputType = {
    id: number
    subscriptionId: number
    amount: number
    currency: number
    recognizedDate: number
    deferredAmount: number
    deferredUntil: number
    type: number
    status: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RevenueLedgerAvgAggregateInputType = {
    amount?: true
    deferredAmount?: true
  }

  export type RevenueLedgerSumAggregateInputType = {
    amount?: true
    deferredAmount?: true
  }

  export type RevenueLedgerMinAggregateInputType = {
    id?: true
    subscriptionId?: true
    amount?: true
    currency?: true
    recognizedDate?: true
    deferredAmount?: true
    deferredUntil?: true
    type?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RevenueLedgerMaxAggregateInputType = {
    id?: true
    subscriptionId?: true
    amount?: true
    currency?: true
    recognizedDate?: true
    deferredAmount?: true
    deferredUntil?: true
    type?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RevenueLedgerCountAggregateInputType = {
    id?: true
    subscriptionId?: true
    amount?: true
    currency?: true
    recognizedDate?: true
    deferredAmount?: true
    deferredUntil?: true
    type?: true
    status?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RevenueLedgerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RevenueLedger to aggregate.
     */
    where?: RevenueLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RevenueLedgers to fetch.
     */
    orderBy?: RevenueLedgerOrderByWithRelationInput | RevenueLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RevenueLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RevenueLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RevenueLedgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RevenueLedgers
    **/
    _count?: true | RevenueLedgerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RevenueLedgerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RevenueLedgerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RevenueLedgerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RevenueLedgerMaxAggregateInputType
  }

  export type GetRevenueLedgerAggregateType<T extends RevenueLedgerAggregateArgs> = {
        [P in keyof T & keyof AggregateRevenueLedger]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRevenueLedger[P]>
      : GetScalarType<T[P], AggregateRevenueLedger[P]>
  }




  export type RevenueLedgerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RevenueLedgerWhereInput
    orderBy?: RevenueLedgerOrderByWithAggregationInput | RevenueLedgerOrderByWithAggregationInput[]
    by: RevenueLedgerScalarFieldEnum[] | RevenueLedgerScalarFieldEnum
    having?: RevenueLedgerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RevenueLedgerCountAggregateInputType | true
    _avg?: RevenueLedgerAvgAggregateInputType
    _sum?: RevenueLedgerSumAggregateInputType
    _min?: RevenueLedgerMinAggregateInputType
    _max?: RevenueLedgerMaxAggregateInputType
  }

  export type RevenueLedgerGroupByOutputType = {
    id: string
    subscriptionId: string
    amount: number
    currency: string
    recognizedDate: Date
    deferredAmount: number | null
    deferredUntil: Date | null
    type: string
    status: string
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: RevenueLedgerCountAggregateOutputType | null
    _avg: RevenueLedgerAvgAggregateOutputType | null
    _sum: RevenueLedgerSumAggregateOutputType | null
    _min: RevenueLedgerMinAggregateOutputType | null
    _max: RevenueLedgerMaxAggregateOutputType | null
  }

  type GetRevenueLedgerGroupByPayload<T extends RevenueLedgerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RevenueLedgerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RevenueLedgerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RevenueLedgerGroupByOutputType[P]>
            : GetScalarType<T[P], RevenueLedgerGroupByOutputType[P]>
        }
      >
    >


  export type RevenueLedgerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    amount?: boolean
    currency?: boolean
    recognizedDate?: boolean
    deferredAmount?: boolean
    deferredUntil?: boolean
    type?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["revenueLedger"]>

  export type RevenueLedgerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    amount?: boolean
    currency?: boolean
    recognizedDate?: boolean
    deferredAmount?: boolean
    deferredUntil?: boolean
    type?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["revenueLedger"]>

  export type RevenueLedgerSelectScalar = {
    id?: boolean
    subscriptionId?: boolean
    amount?: boolean
    currency?: boolean
    recognizedDate?: boolean
    deferredAmount?: boolean
    deferredUntil?: boolean
    type?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $RevenueLedgerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RevenueLedger"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subscriptionId: string
      amount: number
      currency: string
      recognizedDate: Date
      deferredAmount: number | null
      deferredUntil: Date | null
      type: string
      status: string
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["revenueLedger"]>
    composites: {}
  }

  type RevenueLedgerGetPayload<S extends boolean | null | undefined | RevenueLedgerDefaultArgs> = $Result.GetResult<Prisma.$RevenueLedgerPayload, S>

  type RevenueLedgerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RevenueLedgerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RevenueLedgerCountAggregateInputType | true
    }

  export interface RevenueLedgerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RevenueLedger'], meta: { name: 'RevenueLedger' } }
    /**
     * Find zero or one RevenueLedger that matches the filter.
     * @param {RevenueLedgerFindUniqueArgs} args - Arguments to find a RevenueLedger
     * @example
     * // Get one RevenueLedger
     * const revenueLedger = await prisma.revenueLedger.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RevenueLedgerFindUniqueArgs>(args: SelectSubset<T, RevenueLedgerFindUniqueArgs<ExtArgs>>): Prisma__RevenueLedgerClient<$Result.GetResult<Prisma.$RevenueLedgerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RevenueLedger that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RevenueLedgerFindUniqueOrThrowArgs} args - Arguments to find a RevenueLedger
     * @example
     * // Get one RevenueLedger
     * const revenueLedger = await prisma.revenueLedger.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RevenueLedgerFindUniqueOrThrowArgs>(args: SelectSubset<T, RevenueLedgerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RevenueLedgerClient<$Result.GetResult<Prisma.$RevenueLedgerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RevenueLedger that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueLedgerFindFirstArgs} args - Arguments to find a RevenueLedger
     * @example
     * // Get one RevenueLedger
     * const revenueLedger = await prisma.revenueLedger.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RevenueLedgerFindFirstArgs>(args?: SelectSubset<T, RevenueLedgerFindFirstArgs<ExtArgs>>): Prisma__RevenueLedgerClient<$Result.GetResult<Prisma.$RevenueLedgerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RevenueLedger that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueLedgerFindFirstOrThrowArgs} args - Arguments to find a RevenueLedger
     * @example
     * // Get one RevenueLedger
     * const revenueLedger = await prisma.revenueLedger.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RevenueLedgerFindFirstOrThrowArgs>(args?: SelectSubset<T, RevenueLedgerFindFirstOrThrowArgs<ExtArgs>>): Prisma__RevenueLedgerClient<$Result.GetResult<Prisma.$RevenueLedgerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RevenueLedgers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueLedgerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RevenueLedgers
     * const revenueLedgers = await prisma.revenueLedger.findMany()
     * 
     * // Get first 10 RevenueLedgers
     * const revenueLedgers = await prisma.revenueLedger.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const revenueLedgerWithIdOnly = await prisma.revenueLedger.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RevenueLedgerFindManyArgs>(args?: SelectSubset<T, RevenueLedgerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RevenueLedgerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RevenueLedger.
     * @param {RevenueLedgerCreateArgs} args - Arguments to create a RevenueLedger.
     * @example
     * // Create one RevenueLedger
     * const RevenueLedger = await prisma.revenueLedger.create({
     *   data: {
     *     // ... data to create a RevenueLedger
     *   }
     * })
     * 
     */
    create<T extends RevenueLedgerCreateArgs>(args: SelectSubset<T, RevenueLedgerCreateArgs<ExtArgs>>): Prisma__RevenueLedgerClient<$Result.GetResult<Prisma.$RevenueLedgerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RevenueLedgers.
     * @param {RevenueLedgerCreateManyArgs} args - Arguments to create many RevenueLedgers.
     * @example
     * // Create many RevenueLedgers
     * const revenueLedger = await prisma.revenueLedger.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RevenueLedgerCreateManyArgs>(args?: SelectSubset<T, RevenueLedgerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RevenueLedgers and returns the data saved in the database.
     * @param {RevenueLedgerCreateManyAndReturnArgs} args - Arguments to create many RevenueLedgers.
     * @example
     * // Create many RevenueLedgers
     * const revenueLedger = await prisma.revenueLedger.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RevenueLedgers and only return the `id`
     * const revenueLedgerWithIdOnly = await prisma.revenueLedger.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RevenueLedgerCreateManyAndReturnArgs>(args?: SelectSubset<T, RevenueLedgerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RevenueLedgerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RevenueLedger.
     * @param {RevenueLedgerDeleteArgs} args - Arguments to delete one RevenueLedger.
     * @example
     * // Delete one RevenueLedger
     * const RevenueLedger = await prisma.revenueLedger.delete({
     *   where: {
     *     // ... filter to delete one RevenueLedger
     *   }
     * })
     * 
     */
    delete<T extends RevenueLedgerDeleteArgs>(args: SelectSubset<T, RevenueLedgerDeleteArgs<ExtArgs>>): Prisma__RevenueLedgerClient<$Result.GetResult<Prisma.$RevenueLedgerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RevenueLedger.
     * @param {RevenueLedgerUpdateArgs} args - Arguments to update one RevenueLedger.
     * @example
     * // Update one RevenueLedger
     * const revenueLedger = await prisma.revenueLedger.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RevenueLedgerUpdateArgs>(args: SelectSubset<T, RevenueLedgerUpdateArgs<ExtArgs>>): Prisma__RevenueLedgerClient<$Result.GetResult<Prisma.$RevenueLedgerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RevenueLedgers.
     * @param {RevenueLedgerDeleteManyArgs} args - Arguments to filter RevenueLedgers to delete.
     * @example
     * // Delete a few RevenueLedgers
     * const { count } = await prisma.revenueLedger.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RevenueLedgerDeleteManyArgs>(args?: SelectSubset<T, RevenueLedgerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RevenueLedgers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueLedgerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RevenueLedgers
     * const revenueLedger = await prisma.revenueLedger.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RevenueLedgerUpdateManyArgs>(args: SelectSubset<T, RevenueLedgerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RevenueLedger.
     * @param {RevenueLedgerUpsertArgs} args - Arguments to update or create a RevenueLedger.
     * @example
     * // Update or create a RevenueLedger
     * const revenueLedger = await prisma.revenueLedger.upsert({
     *   create: {
     *     // ... data to create a RevenueLedger
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RevenueLedger we want to update
     *   }
     * })
     */
    upsert<T extends RevenueLedgerUpsertArgs>(args: SelectSubset<T, RevenueLedgerUpsertArgs<ExtArgs>>): Prisma__RevenueLedgerClient<$Result.GetResult<Prisma.$RevenueLedgerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RevenueLedgers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueLedgerCountArgs} args - Arguments to filter RevenueLedgers to count.
     * @example
     * // Count the number of RevenueLedgers
     * const count = await prisma.revenueLedger.count({
     *   where: {
     *     // ... the filter for the RevenueLedgers we want to count
     *   }
     * })
    **/
    count<T extends RevenueLedgerCountArgs>(
      args?: Subset<T, RevenueLedgerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RevenueLedgerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RevenueLedger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueLedgerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RevenueLedgerAggregateArgs>(args: Subset<T, RevenueLedgerAggregateArgs>): Prisma.PrismaPromise<GetRevenueLedgerAggregateType<T>>

    /**
     * Group by RevenueLedger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueLedgerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RevenueLedgerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RevenueLedgerGroupByArgs['orderBy'] }
        : { orderBy?: RevenueLedgerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RevenueLedgerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRevenueLedgerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RevenueLedger model
   */
  readonly fields: RevenueLedgerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RevenueLedger.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RevenueLedgerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RevenueLedger model
   */ 
  interface RevenueLedgerFieldRefs {
    readonly id: FieldRef<"RevenueLedger", 'String'>
    readonly subscriptionId: FieldRef<"RevenueLedger", 'String'>
    readonly amount: FieldRef<"RevenueLedger", 'Float'>
    readonly currency: FieldRef<"RevenueLedger", 'String'>
    readonly recognizedDate: FieldRef<"RevenueLedger", 'DateTime'>
    readonly deferredAmount: FieldRef<"RevenueLedger", 'Float'>
    readonly deferredUntil: FieldRef<"RevenueLedger", 'DateTime'>
    readonly type: FieldRef<"RevenueLedger", 'String'>
    readonly status: FieldRef<"RevenueLedger", 'String'>
    readonly metadata: FieldRef<"RevenueLedger", 'Json'>
    readonly createdAt: FieldRef<"RevenueLedger", 'DateTime'>
    readonly updatedAt: FieldRef<"RevenueLedger", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RevenueLedger findUnique
   */
  export type RevenueLedgerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueLedger
     */
    select?: RevenueLedgerSelect<ExtArgs> | null
    /**
     * Filter, which RevenueLedger to fetch.
     */
    where: RevenueLedgerWhereUniqueInput
  }

  /**
   * RevenueLedger findUniqueOrThrow
   */
  export type RevenueLedgerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueLedger
     */
    select?: RevenueLedgerSelect<ExtArgs> | null
    /**
     * Filter, which RevenueLedger to fetch.
     */
    where: RevenueLedgerWhereUniqueInput
  }

  /**
   * RevenueLedger findFirst
   */
  export type RevenueLedgerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueLedger
     */
    select?: RevenueLedgerSelect<ExtArgs> | null
    /**
     * Filter, which RevenueLedger to fetch.
     */
    where?: RevenueLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RevenueLedgers to fetch.
     */
    orderBy?: RevenueLedgerOrderByWithRelationInput | RevenueLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RevenueLedgers.
     */
    cursor?: RevenueLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RevenueLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RevenueLedgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RevenueLedgers.
     */
    distinct?: RevenueLedgerScalarFieldEnum | RevenueLedgerScalarFieldEnum[]
  }

  /**
   * RevenueLedger findFirstOrThrow
   */
  export type RevenueLedgerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueLedger
     */
    select?: RevenueLedgerSelect<ExtArgs> | null
    /**
     * Filter, which RevenueLedger to fetch.
     */
    where?: RevenueLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RevenueLedgers to fetch.
     */
    orderBy?: RevenueLedgerOrderByWithRelationInput | RevenueLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RevenueLedgers.
     */
    cursor?: RevenueLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RevenueLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RevenueLedgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RevenueLedgers.
     */
    distinct?: RevenueLedgerScalarFieldEnum | RevenueLedgerScalarFieldEnum[]
  }

  /**
   * RevenueLedger findMany
   */
  export type RevenueLedgerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueLedger
     */
    select?: RevenueLedgerSelect<ExtArgs> | null
    /**
     * Filter, which RevenueLedgers to fetch.
     */
    where?: RevenueLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RevenueLedgers to fetch.
     */
    orderBy?: RevenueLedgerOrderByWithRelationInput | RevenueLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RevenueLedgers.
     */
    cursor?: RevenueLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RevenueLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RevenueLedgers.
     */
    skip?: number
    distinct?: RevenueLedgerScalarFieldEnum | RevenueLedgerScalarFieldEnum[]
  }

  /**
   * RevenueLedger create
   */
  export type RevenueLedgerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueLedger
     */
    select?: RevenueLedgerSelect<ExtArgs> | null
    /**
     * The data needed to create a RevenueLedger.
     */
    data: XOR<RevenueLedgerCreateInput, RevenueLedgerUncheckedCreateInput>
  }

  /**
   * RevenueLedger createMany
   */
  export type RevenueLedgerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RevenueLedgers.
     */
    data: RevenueLedgerCreateManyInput | RevenueLedgerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RevenueLedger createManyAndReturn
   */
  export type RevenueLedgerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueLedger
     */
    select?: RevenueLedgerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RevenueLedgers.
     */
    data: RevenueLedgerCreateManyInput | RevenueLedgerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RevenueLedger update
   */
  export type RevenueLedgerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueLedger
     */
    select?: RevenueLedgerSelect<ExtArgs> | null
    /**
     * The data needed to update a RevenueLedger.
     */
    data: XOR<RevenueLedgerUpdateInput, RevenueLedgerUncheckedUpdateInput>
    /**
     * Choose, which RevenueLedger to update.
     */
    where: RevenueLedgerWhereUniqueInput
  }

  /**
   * RevenueLedger updateMany
   */
  export type RevenueLedgerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RevenueLedgers.
     */
    data: XOR<RevenueLedgerUpdateManyMutationInput, RevenueLedgerUncheckedUpdateManyInput>
    /**
     * Filter which RevenueLedgers to update
     */
    where?: RevenueLedgerWhereInput
  }

  /**
   * RevenueLedger upsert
   */
  export type RevenueLedgerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueLedger
     */
    select?: RevenueLedgerSelect<ExtArgs> | null
    /**
     * The filter to search for the RevenueLedger to update in case it exists.
     */
    where: RevenueLedgerWhereUniqueInput
    /**
     * In case the RevenueLedger found by the `where` argument doesn't exist, create a new RevenueLedger with this data.
     */
    create: XOR<RevenueLedgerCreateInput, RevenueLedgerUncheckedCreateInput>
    /**
     * In case the RevenueLedger was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RevenueLedgerUpdateInput, RevenueLedgerUncheckedUpdateInput>
  }

  /**
   * RevenueLedger delete
   */
  export type RevenueLedgerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueLedger
     */
    select?: RevenueLedgerSelect<ExtArgs> | null
    /**
     * Filter which RevenueLedger to delete.
     */
    where: RevenueLedgerWhereUniqueInput
  }

  /**
   * RevenueLedger deleteMany
   */
  export type RevenueLedgerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RevenueLedgers to delete
     */
    where?: RevenueLedgerWhereInput
  }

  /**
   * RevenueLedger without action
   */
  export type RevenueLedgerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueLedger
     */
    select?: RevenueLedgerSelect<ExtArgs> | null
  }


  /**
   * Model ChurnPrediction
   */

  export type AggregateChurnPrediction = {
    _count: ChurnPredictionCountAggregateOutputType | null
    _avg: ChurnPredictionAvgAggregateOutputType | null
    _sum: ChurnPredictionSumAggregateOutputType | null
    _min: ChurnPredictionMinAggregateOutputType | null
    _max: ChurnPredictionMaxAggregateOutputType | null
  }

  export type ChurnPredictionAvgAggregateOutputType = {
    probability: number | null
  }

  export type ChurnPredictionSumAggregateOutputType = {
    probability: number | null
  }

  export type ChurnPredictionMinAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    probability: number | null
    nextBillDate: Date | null
    predictedDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChurnPredictionMaxAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    probability: number | null
    nextBillDate: Date | null
    predictedDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChurnPredictionCountAggregateOutputType = {
    id: number
    subscriptionId: number
    probability: number
    factors: number
    nextBillDate: number
    predictedDate: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChurnPredictionAvgAggregateInputType = {
    probability?: true
  }

  export type ChurnPredictionSumAggregateInputType = {
    probability?: true
  }

  export type ChurnPredictionMinAggregateInputType = {
    id?: true
    subscriptionId?: true
    probability?: true
    nextBillDate?: true
    predictedDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChurnPredictionMaxAggregateInputType = {
    id?: true
    subscriptionId?: true
    probability?: true
    nextBillDate?: true
    predictedDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChurnPredictionCountAggregateInputType = {
    id?: true
    subscriptionId?: true
    probability?: true
    factors?: true
    nextBillDate?: true
    predictedDate?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChurnPredictionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChurnPrediction to aggregate.
     */
    where?: ChurnPredictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChurnPredictions to fetch.
     */
    orderBy?: ChurnPredictionOrderByWithRelationInput | ChurnPredictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChurnPredictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChurnPredictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChurnPredictions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChurnPredictions
    **/
    _count?: true | ChurnPredictionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChurnPredictionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChurnPredictionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChurnPredictionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChurnPredictionMaxAggregateInputType
  }

  export type GetChurnPredictionAggregateType<T extends ChurnPredictionAggregateArgs> = {
        [P in keyof T & keyof AggregateChurnPrediction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChurnPrediction[P]>
      : GetScalarType<T[P], AggregateChurnPrediction[P]>
  }




  export type ChurnPredictionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChurnPredictionWhereInput
    orderBy?: ChurnPredictionOrderByWithAggregationInput | ChurnPredictionOrderByWithAggregationInput[]
    by: ChurnPredictionScalarFieldEnum[] | ChurnPredictionScalarFieldEnum
    having?: ChurnPredictionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChurnPredictionCountAggregateInputType | true
    _avg?: ChurnPredictionAvgAggregateInputType
    _sum?: ChurnPredictionSumAggregateInputType
    _min?: ChurnPredictionMinAggregateInputType
    _max?: ChurnPredictionMaxAggregateInputType
  }

  export type ChurnPredictionGroupByOutputType = {
    id: string
    subscriptionId: string
    probability: number
    factors: JsonValue
    nextBillDate: Date
    predictedDate: Date
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ChurnPredictionCountAggregateOutputType | null
    _avg: ChurnPredictionAvgAggregateOutputType | null
    _sum: ChurnPredictionSumAggregateOutputType | null
    _min: ChurnPredictionMinAggregateOutputType | null
    _max: ChurnPredictionMaxAggregateOutputType | null
  }

  type GetChurnPredictionGroupByPayload<T extends ChurnPredictionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChurnPredictionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChurnPredictionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChurnPredictionGroupByOutputType[P]>
            : GetScalarType<T[P], ChurnPredictionGroupByOutputType[P]>
        }
      >
    >


  export type ChurnPredictionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    probability?: boolean
    factors?: boolean
    nextBillDate?: boolean
    predictedDate?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["churnPrediction"]>

  export type ChurnPredictionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    probability?: boolean
    factors?: boolean
    nextBillDate?: boolean
    predictedDate?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["churnPrediction"]>

  export type ChurnPredictionSelectScalar = {
    id?: boolean
    subscriptionId?: boolean
    probability?: boolean
    factors?: boolean
    nextBillDate?: boolean
    predictedDate?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $ChurnPredictionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChurnPrediction"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subscriptionId: string
      probability: number
      factors: Prisma.JsonValue
      nextBillDate: Date
      predictedDate: Date
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["churnPrediction"]>
    composites: {}
  }

  type ChurnPredictionGetPayload<S extends boolean | null | undefined | ChurnPredictionDefaultArgs> = $Result.GetResult<Prisma.$ChurnPredictionPayload, S>

  type ChurnPredictionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChurnPredictionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChurnPredictionCountAggregateInputType | true
    }

  export interface ChurnPredictionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChurnPrediction'], meta: { name: 'ChurnPrediction' } }
    /**
     * Find zero or one ChurnPrediction that matches the filter.
     * @param {ChurnPredictionFindUniqueArgs} args - Arguments to find a ChurnPrediction
     * @example
     * // Get one ChurnPrediction
     * const churnPrediction = await prisma.churnPrediction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChurnPredictionFindUniqueArgs>(args: SelectSubset<T, ChurnPredictionFindUniqueArgs<ExtArgs>>): Prisma__ChurnPredictionClient<$Result.GetResult<Prisma.$ChurnPredictionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ChurnPrediction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChurnPredictionFindUniqueOrThrowArgs} args - Arguments to find a ChurnPrediction
     * @example
     * // Get one ChurnPrediction
     * const churnPrediction = await prisma.churnPrediction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChurnPredictionFindUniqueOrThrowArgs>(args: SelectSubset<T, ChurnPredictionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChurnPredictionClient<$Result.GetResult<Prisma.$ChurnPredictionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ChurnPrediction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChurnPredictionFindFirstArgs} args - Arguments to find a ChurnPrediction
     * @example
     * // Get one ChurnPrediction
     * const churnPrediction = await prisma.churnPrediction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChurnPredictionFindFirstArgs>(args?: SelectSubset<T, ChurnPredictionFindFirstArgs<ExtArgs>>): Prisma__ChurnPredictionClient<$Result.GetResult<Prisma.$ChurnPredictionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ChurnPrediction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChurnPredictionFindFirstOrThrowArgs} args - Arguments to find a ChurnPrediction
     * @example
     * // Get one ChurnPrediction
     * const churnPrediction = await prisma.churnPrediction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChurnPredictionFindFirstOrThrowArgs>(args?: SelectSubset<T, ChurnPredictionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChurnPredictionClient<$Result.GetResult<Prisma.$ChurnPredictionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ChurnPredictions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChurnPredictionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChurnPredictions
     * const churnPredictions = await prisma.churnPrediction.findMany()
     * 
     * // Get first 10 ChurnPredictions
     * const churnPredictions = await prisma.churnPrediction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const churnPredictionWithIdOnly = await prisma.churnPrediction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChurnPredictionFindManyArgs>(args?: SelectSubset<T, ChurnPredictionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChurnPredictionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ChurnPrediction.
     * @param {ChurnPredictionCreateArgs} args - Arguments to create a ChurnPrediction.
     * @example
     * // Create one ChurnPrediction
     * const ChurnPrediction = await prisma.churnPrediction.create({
     *   data: {
     *     // ... data to create a ChurnPrediction
     *   }
     * })
     * 
     */
    create<T extends ChurnPredictionCreateArgs>(args: SelectSubset<T, ChurnPredictionCreateArgs<ExtArgs>>): Prisma__ChurnPredictionClient<$Result.GetResult<Prisma.$ChurnPredictionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ChurnPredictions.
     * @param {ChurnPredictionCreateManyArgs} args - Arguments to create many ChurnPredictions.
     * @example
     * // Create many ChurnPredictions
     * const churnPrediction = await prisma.churnPrediction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChurnPredictionCreateManyArgs>(args?: SelectSubset<T, ChurnPredictionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChurnPredictions and returns the data saved in the database.
     * @param {ChurnPredictionCreateManyAndReturnArgs} args - Arguments to create many ChurnPredictions.
     * @example
     * // Create many ChurnPredictions
     * const churnPrediction = await prisma.churnPrediction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChurnPredictions and only return the `id`
     * const churnPredictionWithIdOnly = await prisma.churnPrediction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChurnPredictionCreateManyAndReturnArgs>(args?: SelectSubset<T, ChurnPredictionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChurnPredictionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ChurnPrediction.
     * @param {ChurnPredictionDeleteArgs} args - Arguments to delete one ChurnPrediction.
     * @example
     * // Delete one ChurnPrediction
     * const ChurnPrediction = await prisma.churnPrediction.delete({
     *   where: {
     *     // ... filter to delete one ChurnPrediction
     *   }
     * })
     * 
     */
    delete<T extends ChurnPredictionDeleteArgs>(args: SelectSubset<T, ChurnPredictionDeleteArgs<ExtArgs>>): Prisma__ChurnPredictionClient<$Result.GetResult<Prisma.$ChurnPredictionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ChurnPrediction.
     * @param {ChurnPredictionUpdateArgs} args - Arguments to update one ChurnPrediction.
     * @example
     * // Update one ChurnPrediction
     * const churnPrediction = await prisma.churnPrediction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChurnPredictionUpdateArgs>(args: SelectSubset<T, ChurnPredictionUpdateArgs<ExtArgs>>): Prisma__ChurnPredictionClient<$Result.GetResult<Prisma.$ChurnPredictionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ChurnPredictions.
     * @param {ChurnPredictionDeleteManyArgs} args - Arguments to filter ChurnPredictions to delete.
     * @example
     * // Delete a few ChurnPredictions
     * const { count } = await prisma.churnPrediction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChurnPredictionDeleteManyArgs>(args?: SelectSubset<T, ChurnPredictionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChurnPredictions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChurnPredictionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChurnPredictions
     * const churnPrediction = await prisma.churnPrediction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChurnPredictionUpdateManyArgs>(args: SelectSubset<T, ChurnPredictionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChurnPrediction.
     * @param {ChurnPredictionUpsertArgs} args - Arguments to update or create a ChurnPrediction.
     * @example
     * // Update or create a ChurnPrediction
     * const churnPrediction = await prisma.churnPrediction.upsert({
     *   create: {
     *     // ... data to create a ChurnPrediction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChurnPrediction we want to update
     *   }
     * })
     */
    upsert<T extends ChurnPredictionUpsertArgs>(args: SelectSubset<T, ChurnPredictionUpsertArgs<ExtArgs>>): Prisma__ChurnPredictionClient<$Result.GetResult<Prisma.$ChurnPredictionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ChurnPredictions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChurnPredictionCountArgs} args - Arguments to filter ChurnPredictions to count.
     * @example
     * // Count the number of ChurnPredictions
     * const count = await prisma.churnPrediction.count({
     *   where: {
     *     // ... the filter for the ChurnPredictions we want to count
     *   }
     * })
    **/
    count<T extends ChurnPredictionCountArgs>(
      args?: Subset<T, ChurnPredictionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChurnPredictionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChurnPrediction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChurnPredictionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChurnPredictionAggregateArgs>(args: Subset<T, ChurnPredictionAggregateArgs>): Prisma.PrismaPromise<GetChurnPredictionAggregateType<T>>

    /**
     * Group by ChurnPrediction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChurnPredictionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChurnPredictionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChurnPredictionGroupByArgs['orderBy'] }
        : { orderBy?: ChurnPredictionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChurnPredictionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChurnPredictionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChurnPrediction model
   */
  readonly fields: ChurnPredictionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChurnPrediction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChurnPredictionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChurnPrediction model
   */ 
  interface ChurnPredictionFieldRefs {
    readonly id: FieldRef<"ChurnPrediction", 'String'>
    readonly subscriptionId: FieldRef<"ChurnPrediction", 'String'>
    readonly probability: FieldRef<"ChurnPrediction", 'Float'>
    readonly factors: FieldRef<"ChurnPrediction", 'Json'>
    readonly nextBillDate: FieldRef<"ChurnPrediction", 'DateTime'>
    readonly predictedDate: FieldRef<"ChurnPrediction", 'DateTime'>
    readonly metadata: FieldRef<"ChurnPrediction", 'Json'>
    readonly createdAt: FieldRef<"ChurnPrediction", 'DateTime'>
    readonly updatedAt: FieldRef<"ChurnPrediction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChurnPrediction findUnique
   */
  export type ChurnPredictionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChurnPrediction
     */
    select?: ChurnPredictionSelect<ExtArgs> | null
    /**
     * Filter, which ChurnPrediction to fetch.
     */
    where: ChurnPredictionWhereUniqueInput
  }

  /**
   * ChurnPrediction findUniqueOrThrow
   */
  export type ChurnPredictionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChurnPrediction
     */
    select?: ChurnPredictionSelect<ExtArgs> | null
    /**
     * Filter, which ChurnPrediction to fetch.
     */
    where: ChurnPredictionWhereUniqueInput
  }

  /**
   * ChurnPrediction findFirst
   */
  export type ChurnPredictionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChurnPrediction
     */
    select?: ChurnPredictionSelect<ExtArgs> | null
    /**
     * Filter, which ChurnPrediction to fetch.
     */
    where?: ChurnPredictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChurnPredictions to fetch.
     */
    orderBy?: ChurnPredictionOrderByWithRelationInput | ChurnPredictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChurnPredictions.
     */
    cursor?: ChurnPredictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChurnPredictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChurnPredictions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChurnPredictions.
     */
    distinct?: ChurnPredictionScalarFieldEnum | ChurnPredictionScalarFieldEnum[]
  }

  /**
   * ChurnPrediction findFirstOrThrow
   */
  export type ChurnPredictionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChurnPrediction
     */
    select?: ChurnPredictionSelect<ExtArgs> | null
    /**
     * Filter, which ChurnPrediction to fetch.
     */
    where?: ChurnPredictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChurnPredictions to fetch.
     */
    orderBy?: ChurnPredictionOrderByWithRelationInput | ChurnPredictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChurnPredictions.
     */
    cursor?: ChurnPredictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChurnPredictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChurnPredictions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChurnPredictions.
     */
    distinct?: ChurnPredictionScalarFieldEnum | ChurnPredictionScalarFieldEnum[]
  }

  /**
   * ChurnPrediction findMany
   */
  export type ChurnPredictionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChurnPrediction
     */
    select?: ChurnPredictionSelect<ExtArgs> | null
    /**
     * Filter, which ChurnPredictions to fetch.
     */
    where?: ChurnPredictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChurnPredictions to fetch.
     */
    orderBy?: ChurnPredictionOrderByWithRelationInput | ChurnPredictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChurnPredictions.
     */
    cursor?: ChurnPredictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChurnPredictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChurnPredictions.
     */
    skip?: number
    distinct?: ChurnPredictionScalarFieldEnum | ChurnPredictionScalarFieldEnum[]
  }

  /**
   * ChurnPrediction create
   */
  export type ChurnPredictionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChurnPrediction
     */
    select?: ChurnPredictionSelect<ExtArgs> | null
    /**
     * The data needed to create a ChurnPrediction.
     */
    data: XOR<ChurnPredictionCreateInput, ChurnPredictionUncheckedCreateInput>
  }

  /**
   * ChurnPrediction createMany
   */
  export type ChurnPredictionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChurnPredictions.
     */
    data: ChurnPredictionCreateManyInput | ChurnPredictionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChurnPrediction createManyAndReturn
   */
  export type ChurnPredictionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChurnPrediction
     */
    select?: ChurnPredictionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ChurnPredictions.
     */
    data: ChurnPredictionCreateManyInput | ChurnPredictionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChurnPrediction update
   */
  export type ChurnPredictionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChurnPrediction
     */
    select?: ChurnPredictionSelect<ExtArgs> | null
    /**
     * The data needed to update a ChurnPrediction.
     */
    data: XOR<ChurnPredictionUpdateInput, ChurnPredictionUncheckedUpdateInput>
    /**
     * Choose, which ChurnPrediction to update.
     */
    where: ChurnPredictionWhereUniqueInput
  }

  /**
   * ChurnPrediction updateMany
   */
  export type ChurnPredictionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChurnPredictions.
     */
    data: XOR<ChurnPredictionUpdateManyMutationInput, ChurnPredictionUncheckedUpdateManyInput>
    /**
     * Filter which ChurnPredictions to update
     */
    where?: ChurnPredictionWhereInput
  }

  /**
   * ChurnPrediction upsert
   */
  export type ChurnPredictionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChurnPrediction
     */
    select?: ChurnPredictionSelect<ExtArgs> | null
    /**
     * The filter to search for the ChurnPrediction to update in case it exists.
     */
    where: ChurnPredictionWhereUniqueInput
    /**
     * In case the ChurnPrediction found by the `where` argument doesn't exist, create a new ChurnPrediction with this data.
     */
    create: XOR<ChurnPredictionCreateInput, ChurnPredictionUncheckedCreateInput>
    /**
     * In case the ChurnPrediction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChurnPredictionUpdateInput, ChurnPredictionUncheckedUpdateInput>
  }

  /**
   * ChurnPrediction delete
   */
  export type ChurnPredictionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChurnPrediction
     */
    select?: ChurnPredictionSelect<ExtArgs> | null
    /**
     * Filter which ChurnPrediction to delete.
     */
    where: ChurnPredictionWhereUniqueInput
  }

  /**
   * ChurnPrediction deleteMany
   */
  export type ChurnPredictionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChurnPredictions to delete
     */
    where?: ChurnPredictionWhereInput
  }

  /**
   * ChurnPrediction without action
   */
  export type ChurnPredictionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChurnPrediction
     */
    select?: ChurnPredictionSelect<ExtArgs> | null
  }


  /**
   * Model CohortAnalysis
   */

  export type AggregateCohortAnalysis = {
    _count: CohortAnalysisCountAggregateOutputType | null
    _avg: CohortAnalysisAvgAggregateOutputType | null
    _sum: CohortAnalysisSumAggregateOutputType | null
    _min: CohortAnalysisMinAggregateOutputType | null
    _max: CohortAnalysisMaxAggregateOutputType | null
  }

  export type CohortAnalysisAvgAggregateOutputType = {
    cohortSize: number | null
  }

  export type CohortAnalysisSumAggregateOutputType = {
    cohortSize: number | null
  }

  export type CohortAnalysisMinAggregateOutputType = {
    id: string | null
    cohortDate: Date | null
    cohortSize: number | null
    metric: string | null
    segment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CohortAnalysisMaxAggregateOutputType = {
    id: string | null
    cohortDate: Date | null
    cohortSize: number | null
    metric: string | null
    segment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CohortAnalysisCountAggregateOutputType = {
    id: number
    cohortDate: number
    cohortSize: number
    metric: number
    values: number
    segment: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CohortAnalysisAvgAggregateInputType = {
    cohortSize?: true
  }

  export type CohortAnalysisSumAggregateInputType = {
    cohortSize?: true
  }

  export type CohortAnalysisMinAggregateInputType = {
    id?: true
    cohortDate?: true
    cohortSize?: true
    metric?: true
    segment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CohortAnalysisMaxAggregateInputType = {
    id?: true
    cohortDate?: true
    cohortSize?: true
    metric?: true
    segment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CohortAnalysisCountAggregateInputType = {
    id?: true
    cohortDate?: true
    cohortSize?: true
    metric?: true
    values?: true
    segment?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CohortAnalysisAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CohortAnalysis to aggregate.
     */
    where?: CohortAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CohortAnalyses to fetch.
     */
    orderBy?: CohortAnalysisOrderByWithRelationInput | CohortAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CohortAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CohortAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CohortAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CohortAnalyses
    **/
    _count?: true | CohortAnalysisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CohortAnalysisAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CohortAnalysisSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CohortAnalysisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CohortAnalysisMaxAggregateInputType
  }

  export type GetCohortAnalysisAggregateType<T extends CohortAnalysisAggregateArgs> = {
        [P in keyof T & keyof AggregateCohortAnalysis]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCohortAnalysis[P]>
      : GetScalarType<T[P], AggregateCohortAnalysis[P]>
  }




  export type CohortAnalysisGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CohortAnalysisWhereInput
    orderBy?: CohortAnalysisOrderByWithAggregationInput | CohortAnalysisOrderByWithAggregationInput[]
    by: CohortAnalysisScalarFieldEnum[] | CohortAnalysisScalarFieldEnum
    having?: CohortAnalysisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CohortAnalysisCountAggregateInputType | true
    _avg?: CohortAnalysisAvgAggregateInputType
    _sum?: CohortAnalysisSumAggregateInputType
    _min?: CohortAnalysisMinAggregateInputType
    _max?: CohortAnalysisMaxAggregateInputType
  }

  export type CohortAnalysisGroupByOutputType = {
    id: string
    cohortDate: Date
    cohortSize: number
    metric: string
    values: JsonValue
    segment: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: CohortAnalysisCountAggregateOutputType | null
    _avg: CohortAnalysisAvgAggregateOutputType | null
    _sum: CohortAnalysisSumAggregateOutputType | null
    _min: CohortAnalysisMinAggregateOutputType | null
    _max: CohortAnalysisMaxAggregateOutputType | null
  }

  type GetCohortAnalysisGroupByPayload<T extends CohortAnalysisGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CohortAnalysisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CohortAnalysisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CohortAnalysisGroupByOutputType[P]>
            : GetScalarType<T[P], CohortAnalysisGroupByOutputType[P]>
        }
      >
    >


  export type CohortAnalysisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cohortDate?: boolean
    cohortSize?: boolean
    metric?: boolean
    values?: boolean
    segment?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cohortAnalysis"]>

  export type CohortAnalysisSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cohortDate?: boolean
    cohortSize?: boolean
    metric?: boolean
    values?: boolean
    segment?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cohortAnalysis"]>

  export type CohortAnalysisSelectScalar = {
    id?: boolean
    cohortDate?: boolean
    cohortSize?: boolean
    metric?: boolean
    values?: boolean
    segment?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $CohortAnalysisPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CohortAnalysis"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cohortDate: Date
      cohortSize: number
      metric: string
      values: Prisma.JsonValue
      segment: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cohortAnalysis"]>
    composites: {}
  }

  type CohortAnalysisGetPayload<S extends boolean | null | undefined | CohortAnalysisDefaultArgs> = $Result.GetResult<Prisma.$CohortAnalysisPayload, S>

  type CohortAnalysisCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CohortAnalysisFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CohortAnalysisCountAggregateInputType | true
    }

  export interface CohortAnalysisDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CohortAnalysis'], meta: { name: 'CohortAnalysis' } }
    /**
     * Find zero or one CohortAnalysis that matches the filter.
     * @param {CohortAnalysisFindUniqueArgs} args - Arguments to find a CohortAnalysis
     * @example
     * // Get one CohortAnalysis
     * const cohortAnalysis = await prisma.cohortAnalysis.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CohortAnalysisFindUniqueArgs>(args: SelectSubset<T, CohortAnalysisFindUniqueArgs<ExtArgs>>): Prisma__CohortAnalysisClient<$Result.GetResult<Prisma.$CohortAnalysisPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CohortAnalysis that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CohortAnalysisFindUniqueOrThrowArgs} args - Arguments to find a CohortAnalysis
     * @example
     * // Get one CohortAnalysis
     * const cohortAnalysis = await prisma.cohortAnalysis.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CohortAnalysisFindUniqueOrThrowArgs>(args: SelectSubset<T, CohortAnalysisFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CohortAnalysisClient<$Result.GetResult<Prisma.$CohortAnalysisPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CohortAnalysis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CohortAnalysisFindFirstArgs} args - Arguments to find a CohortAnalysis
     * @example
     * // Get one CohortAnalysis
     * const cohortAnalysis = await prisma.cohortAnalysis.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CohortAnalysisFindFirstArgs>(args?: SelectSubset<T, CohortAnalysisFindFirstArgs<ExtArgs>>): Prisma__CohortAnalysisClient<$Result.GetResult<Prisma.$CohortAnalysisPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CohortAnalysis that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CohortAnalysisFindFirstOrThrowArgs} args - Arguments to find a CohortAnalysis
     * @example
     * // Get one CohortAnalysis
     * const cohortAnalysis = await prisma.cohortAnalysis.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CohortAnalysisFindFirstOrThrowArgs>(args?: SelectSubset<T, CohortAnalysisFindFirstOrThrowArgs<ExtArgs>>): Prisma__CohortAnalysisClient<$Result.GetResult<Prisma.$CohortAnalysisPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CohortAnalyses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CohortAnalysisFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CohortAnalyses
     * const cohortAnalyses = await prisma.cohortAnalysis.findMany()
     * 
     * // Get first 10 CohortAnalyses
     * const cohortAnalyses = await prisma.cohortAnalysis.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cohortAnalysisWithIdOnly = await prisma.cohortAnalysis.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CohortAnalysisFindManyArgs>(args?: SelectSubset<T, CohortAnalysisFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CohortAnalysisPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CohortAnalysis.
     * @param {CohortAnalysisCreateArgs} args - Arguments to create a CohortAnalysis.
     * @example
     * // Create one CohortAnalysis
     * const CohortAnalysis = await prisma.cohortAnalysis.create({
     *   data: {
     *     // ... data to create a CohortAnalysis
     *   }
     * })
     * 
     */
    create<T extends CohortAnalysisCreateArgs>(args: SelectSubset<T, CohortAnalysisCreateArgs<ExtArgs>>): Prisma__CohortAnalysisClient<$Result.GetResult<Prisma.$CohortAnalysisPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CohortAnalyses.
     * @param {CohortAnalysisCreateManyArgs} args - Arguments to create many CohortAnalyses.
     * @example
     * // Create many CohortAnalyses
     * const cohortAnalysis = await prisma.cohortAnalysis.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CohortAnalysisCreateManyArgs>(args?: SelectSubset<T, CohortAnalysisCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CohortAnalyses and returns the data saved in the database.
     * @param {CohortAnalysisCreateManyAndReturnArgs} args - Arguments to create many CohortAnalyses.
     * @example
     * // Create many CohortAnalyses
     * const cohortAnalysis = await prisma.cohortAnalysis.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CohortAnalyses and only return the `id`
     * const cohortAnalysisWithIdOnly = await prisma.cohortAnalysis.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CohortAnalysisCreateManyAndReturnArgs>(args?: SelectSubset<T, CohortAnalysisCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CohortAnalysisPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CohortAnalysis.
     * @param {CohortAnalysisDeleteArgs} args - Arguments to delete one CohortAnalysis.
     * @example
     * // Delete one CohortAnalysis
     * const CohortAnalysis = await prisma.cohortAnalysis.delete({
     *   where: {
     *     // ... filter to delete one CohortAnalysis
     *   }
     * })
     * 
     */
    delete<T extends CohortAnalysisDeleteArgs>(args: SelectSubset<T, CohortAnalysisDeleteArgs<ExtArgs>>): Prisma__CohortAnalysisClient<$Result.GetResult<Prisma.$CohortAnalysisPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CohortAnalysis.
     * @param {CohortAnalysisUpdateArgs} args - Arguments to update one CohortAnalysis.
     * @example
     * // Update one CohortAnalysis
     * const cohortAnalysis = await prisma.cohortAnalysis.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CohortAnalysisUpdateArgs>(args: SelectSubset<T, CohortAnalysisUpdateArgs<ExtArgs>>): Prisma__CohortAnalysisClient<$Result.GetResult<Prisma.$CohortAnalysisPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CohortAnalyses.
     * @param {CohortAnalysisDeleteManyArgs} args - Arguments to filter CohortAnalyses to delete.
     * @example
     * // Delete a few CohortAnalyses
     * const { count } = await prisma.cohortAnalysis.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CohortAnalysisDeleteManyArgs>(args?: SelectSubset<T, CohortAnalysisDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CohortAnalyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CohortAnalysisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CohortAnalyses
     * const cohortAnalysis = await prisma.cohortAnalysis.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CohortAnalysisUpdateManyArgs>(args: SelectSubset<T, CohortAnalysisUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CohortAnalysis.
     * @param {CohortAnalysisUpsertArgs} args - Arguments to update or create a CohortAnalysis.
     * @example
     * // Update or create a CohortAnalysis
     * const cohortAnalysis = await prisma.cohortAnalysis.upsert({
     *   create: {
     *     // ... data to create a CohortAnalysis
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CohortAnalysis we want to update
     *   }
     * })
     */
    upsert<T extends CohortAnalysisUpsertArgs>(args: SelectSubset<T, CohortAnalysisUpsertArgs<ExtArgs>>): Prisma__CohortAnalysisClient<$Result.GetResult<Prisma.$CohortAnalysisPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CohortAnalyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CohortAnalysisCountArgs} args - Arguments to filter CohortAnalyses to count.
     * @example
     * // Count the number of CohortAnalyses
     * const count = await prisma.cohortAnalysis.count({
     *   where: {
     *     // ... the filter for the CohortAnalyses we want to count
     *   }
     * })
    **/
    count<T extends CohortAnalysisCountArgs>(
      args?: Subset<T, CohortAnalysisCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CohortAnalysisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CohortAnalysis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CohortAnalysisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CohortAnalysisAggregateArgs>(args: Subset<T, CohortAnalysisAggregateArgs>): Prisma.PrismaPromise<GetCohortAnalysisAggregateType<T>>

    /**
     * Group by CohortAnalysis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CohortAnalysisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CohortAnalysisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CohortAnalysisGroupByArgs['orderBy'] }
        : { orderBy?: CohortAnalysisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CohortAnalysisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCohortAnalysisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CohortAnalysis model
   */
  readonly fields: CohortAnalysisFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CohortAnalysis.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CohortAnalysisClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CohortAnalysis model
   */ 
  interface CohortAnalysisFieldRefs {
    readonly id: FieldRef<"CohortAnalysis", 'String'>
    readonly cohortDate: FieldRef<"CohortAnalysis", 'DateTime'>
    readonly cohortSize: FieldRef<"CohortAnalysis", 'Int'>
    readonly metric: FieldRef<"CohortAnalysis", 'String'>
    readonly values: FieldRef<"CohortAnalysis", 'Json'>
    readonly segment: FieldRef<"CohortAnalysis", 'String'>
    readonly metadata: FieldRef<"CohortAnalysis", 'Json'>
    readonly createdAt: FieldRef<"CohortAnalysis", 'DateTime'>
    readonly updatedAt: FieldRef<"CohortAnalysis", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CohortAnalysis findUnique
   */
  export type CohortAnalysisFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CohortAnalysis
     */
    select?: CohortAnalysisSelect<ExtArgs> | null
    /**
     * Filter, which CohortAnalysis to fetch.
     */
    where: CohortAnalysisWhereUniqueInput
  }

  /**
   * CohortAnalysis findUniqueOrThrow
   */
  export type CohortAnalysisFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CohortAnalysis
     */
    select?: CohortAnalysisSelect<ExtArgs> | null
    /**
     * Filter, which CohortAnalysis to fetch.
     */
    where: CohortAnalysisWhereUniqueInput
  }

  /**
   * CohortAnalysis findFirst
   */
  export type CohortAnalysisFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CohortAnalysis
     */
    select?: CohortAnalysisSelect<ExtArgs> | null
    /**
     * Filter, which CohortAnalysis to fetch.
     */
    where?: CohortAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CohortAnalyses to fetch.
     */
    orderBy?: CohortAnalysisOrderByWithRelationInput | CohortAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CohortAnalyses.
     */
    cursor?: CohortAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CohortAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CohortAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CohortAnalyses.
     */
    distinct?: CohortAnalysisScalarFieldEnum | CohortAnalysisScalarFieldEnum[]
  }

  /**
   * CohortAnalysis findFirstOrThrow
   */
  export type CohortAnalysisFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CohortAnalysis
     */
    select?: CohortAnalysisSelect<ExtArgs> | null
    /**
     * Filter, which CohortAnalysis to fetch.
     */
    where?: CohortAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CohortAnalyses to fetch.
     */
    orderBy?: CohortAnalysisOrderByWithRelationInput | CohortAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CohortAnalyses.
     */
    cursor?: CohortAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CohortAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CohortAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CohortAnalyses.
     */
    distinct?: CohortAnalysisScalarFieldEnum | CohortAnalysisScalarFieldEnum[]
  }

  /**
   * CohortAnalysis findMany
   */
  export type CohortAnalysisFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CohortAnalysis
     */
    select?: CohortAnalysisSelect<ExtArgs> | null
    /**
     * Filter, which CohortAnalyses to fetch.
     */
    where?: CohortAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CohortAnalyses to fetch.
     */
    orderBy?: CohortAnalysisOrderByWithRelationInput | CohortAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CohortAnalyses.
     */
    cursor?: CohortAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CohortAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CohortAnalyses.
     */
    skip?: number
    distinct?: CohortAnalysisScalarFieldEnum | CohortAnalysisScalarFieldEnum[]
  }

  /**
   * CohortAnalysis create
   */
  export type CohortAnalysisCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CohortAnalysis
     */
    select?: CohortAnalysisSelect<ExtArgs> | null
    /**
     * The data needed to create a CohortAnalysis.
     */
    data: XOR<CohortAnalysisCreateInput, CohortAnalysisUncheckedCreateInput>
  }

  /**
   * CohortAnalysis createMany
   */
  export type CohortAnalysisCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CohortAnalyses.
     */
    data: CohortAnalysisCreateManyInput | CohortAnalysisCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CohortAnalysis createManyAndReturn
   */
  export type CohortAnalysisCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CohortAnalysis
     */
    select?: CohortAnalysisSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CohortAnalyses.
     */
    data: CohortAnalysisCreateManyInput | CohortAnalysisCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CohortAnalysis update
   */
  export type CohortAnalysisUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CohortAnalysis
     */
    select?: CohortAnalysisSelect<ExtArgs> | null
    /**
     * The data needed to update a CohortAnalysis.
     */
    data: XOR<CohortAnalysisUpdateInput, CohortAnalysisUncheckedUpdateInput>
    /**
     * Choose, which CohortAnalysis to update.
     */
    where: CohortAnalysisWhereUniqueInput
  }

  /**
   * CohortAnalysis updateMany
   */
  export type CohortAnalysisUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CohortAnalyses.
     */
    data: XOR<CohortAnalysisUpdateManyMutationInput, CohortAnalysisUncheckedUpdateManyInput>
    /**
     * Filter which CohortAnalyses to update
     */
    where?: CohortAnalysisWhereInput
  }

  /**
   * CohortAnalysis upsert
   */
  export type CohortAnalysisUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CohortAnalysis
     */
    select?: CohortAnalysisSelect<ExtArgs> | null
    /**
     * The filter to search for the CohortAnalysis to update in case it exists.
     */
    where: CohortAnalysisWhereUniqueInput
    /**
     * In case the CohortAnalysis found by the `where` argument doesn't exist, create a new CohortAnalysis with this data.
     */
    create: XOR<CohortAnalysisCreateInput, CohortAnalysisUncheckedCreateInput>
    /**
     * In case the CohortAnalysis was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CohortAnalysisUpdateInput, CohortAnalysisUncheckedUpdateInput>
  }

  /**
   * CohortAnalysis delete
   */
  export type CohortAnalysisDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CohortAnalysis
     */
    select?: CohortAnalysisSelect<ExtArgs> | null
    /**
     * Filter which CohortAnalysis to delete.
     */
    where: CohortAnalysisWhereUniqueInput
  }

  /**
   * CohortAnalysis deleteMany
   */
  export type CohortAnalysisDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CohortAnalyses to delete
     */
    where?: CohortAnalysisWhereInput
  }

  /**
   * CohortAnalysis without action
   */
  export type CohortAnalysisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CohortAnalysis
     */
    select?: CohortAnalysisSelect<ExtArgs> | null
  }


  /**
   * Model ForecastModel
   */

  export type AggregateForecastModel = {
    _count: ForecastModelCountAggregateOutputType | null
    _min: ForecastModelMinAggregateOutputType | null
    _max: ForecastModelMaxAggregateOutputType | null
  }

  export type ForecastModelMinAggregateOutputType = {
    id: string | null
    name: string | null
    status: string | null
    createdAt: Date | null
    lastTraining: Date | null
  }

  export type ForecastModelMaxAggregateOutputType = {
    id: string | null
    name: string | null
    status: string | null
    createdAt: Date | null
    lastTraining: Date | null
  }

  export type ForecastModelCountAggregateOutputType = {
    id: number
    name: number
    config: number
    metadata: number
    status: number
    createdAt: number
    lastTraining: number
    metrics: number
    _all: number
  }


  export type ForecastModelMinAggregateInputType = {
    id?: true
    name?: true
    status?: true
    createdAt?: true
    lastTraining?: true
  }

  export type ForecastModelMaxAggregateInputType = {
    id?: true
    name?: true
    status?: true
    createdAt?: true
    lastTraining?: true
  }

  export type ForecastModelCountAggregateInputType = {
    id?: true
    name?: true
    config?: true
    metadata?: true
    status?: true
    createdAt?: true
    lastTraining?: true
    metrics?: true
    _all?: true
  }

  export type ForecastModelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForecastModel to aggregate.
     */
    where?: ForecastModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForecastModels to fetch.
     */
    orderBy?: ForecastModelOrderByWithRelationInput | ForecastModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ForecastModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForecastModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForecastModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ForecastModels
    **/
    _count?: true | ForecastModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ForecastModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ForecastModelMaxAggregateInputType
  }

  export type GetForecastModelAggregateType<T extends ForecastModelAggregateArgs> = {
        [P in keyof T & keyof AggregateForecastModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateForecastModel[P]>
      : GetScalarType<T[P], AggregateForecastModel[P]>
  }




  export type ForecastModelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForecastModelWhereInput
    orderBy?: ForecastModelOrderByWithAggregationInput | ForecastModelOrderByWithAggregationInput[]
    by: ForecastModelScalarFieldEnum[] | ForecastModelScalarFieldEnum
    having?: ForecastModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ForecastModelCountAggregateInputType | true
    _min?: ForecastModelMinAggregateInputType
    _max?: ForecastModelMaxAggregateInputType
  }

  export type ForecastModelGroupByOutputType = {
    id: string
    name: string
    config: JsonValue
    metadata: JsonValue | null
    status: string
    createdAt: Date
    lastTraining: Date | null
    metrics: JsonValue | null
    _count: ForecastModelCountAggregateOutputType | null
    _min: ForecastModelMinAggregateOutputType | null
    _max: ForecastModelMaxAggregateOutputType | null
  }

  type GetForecastModelGroupByPayload<T extends ForecastModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ForecastModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ForecastModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ForecastModelGroupByOutputType[P]>
            : GetScalarType<T[P], ForecastModelGroupByOutputType[P]>
        }
      >
    >


  export type ForecastModelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    config?: boolean
    metadata?: boolean
    status?: boolean
    createdAt?: boolean
    lastTraining?: boolean
    metrics?: boolean
    forecasts?: boolean | ForecastModel$forecastsArgs<ExtArgs>
    timeSeriesData?: boolean | ForecastModel$timeSeriesDataArgs<ExtArgs>
    _count?: boolean | ForecastModelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["forecastModel"]>

  export type ForecastModelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    config?: boolean
    metadata?: boolean
    status?: boolean
    createdAt?: boolean
    lastTraining?: boolean
    metrics?: boolean
  }, ExtArgs["result"]["forecastModel"]>

  export type ForecastModelSelectScalar = {
    id?: boolean
    name?: boolean
    config?: boolean
    metadata?: boolean
    status?: boolean
    createdAt?: boolean
    lastTraining?: boolean
    metrics?: boolean
  }

  export type ForecastModelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    forecasts?: boolean | ForecastModel$forecastsArgs<ExtArgs>
    timeSeriesData?: boolean | ForecastModel$timeSeriesDataArgs<ExtArgs>
    _count?: boolean | ForecastModelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ForecastModelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ForecastModelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ForecastModel"
    objects: {
      forecasts: Prisma.$ForecastResultPayload<ExtArgs>[]
      timeSeriesData: Prisma.$TimeSeriesDataPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      config: Prisma.JsonValue
      metadata: Prisma.JsonValue | null
      status: string
      createdAt: Date
      lastTraining: Date | null
      metrics: Prisma.JsonValue | null
    }, ExtArgs["result"]["forecastModel"]>
    composites: {}
  }

  type ForecastModelGetPayload<S extends boolean | null | undefined | ForecastModelDefaultArgs> = $Result.GetResult<Prisma.$ForecastModelPayload, S>

  type ForecastModelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ForecastModelFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ForecastModelCountAggregateInputType | true
    }

  export interface ForecastModelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ForecastModel'], meta: { name: 'ForecastModel' } }
    /**
     * Find zero or one ForecastModel that matches the filter.
     * @param {ForecastModelFindUniqueArgs} args - Arguments to find a ForecastModel
     * @example
     * // Get one ForecastModel
     * const forecastModel = await prisma.forecastModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ForecastModelFindUniqueArgs>(args: SelectSubset<T, ForecastModelFindUniqueArgs<ExtArgs>>): Prisma__ForecastModelClient<$Result.GetResult<Prisma.$ForecastModelPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ForecastModel that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ForecastModelFindUniqueOrThrowArgs} args - Arguments to find a ForecastModel
     * @example
     * // Get one ForecastModel
     * const forecastModel = await prisma.forecastModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ForecastModelFindUniqueOrThrowArgs>(args: SelectSubset<T, ForecastModelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ForecastModelClient<$Result.GetResult<Prisma.$ForecastModelPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ForecastModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForecastModelFindFirstArgs} args - Arguments to find a ForecastModel
     * @example
     * // Get one ForecastModel
     * const forecastModel = await prisma.forecastModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ForecastModelFindFirstArgs>(args?: SelectSubset<T, ForecastModelFindFirstArgs<ExtArgs>>): Prisma__ForecastModelClient<$Result.GetResult<Prisma.$ForecastModelPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ForecastModel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForecastModelFindFirstOrThrowArgs} args - Arguments to find a ForecastModel
     * @example
     * // Get one ForecastModel
     * const forecastModel = await prisma.forecastModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ForecastModelFindFirstOrThrowArgs>(args?: SelectSubset<T, ForecastModelFindFirstOrThrowArgs<ExtArgs>>): Prisma__ForecastModelClient<$Result.GetResult<Prisma.$ForecastModelPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ForecastModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForecastModelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ForecastModels
     * const forecastModels = await prisma.forecastModel.findMany()
     * 
     * // Get first 10 ForecastModels
     * const forecastModels = await prisma.forecastModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const forecastModelWithIdOnly = await prisma.forecastModel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ForecastModelFindManyArgs>(args?: SelectSubset<T, ForecastModelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForecastModelPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ForecastModel.
     * @param {ForecastModelCreateArgs} args - Arguments to create a ForecastModel.
     * @example
     * // Create one ForecastModel
     * const ForecastModel = await prisma.forecastModel.create({
     *   data: {
     *     // ... data to create a ForecastModel
     *   }
     * })
     * 
     */
    create<T extends ForecastModelCreateArgs>(args: SelectSubset<T, ForecastModelCreateArgs<ExtArgs>>): Prisma__ForecastModelClient<$Result.GetResult<Prisma.$ForecastModelPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ForecastModels.
     * @param {ForecastModelCreateManyArgs} args - Arguments to create many ForecastModels.
     * @example
     * // Create many ForecastModels
     * const forecastModel = await prisma.forecastModel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ForecastModelCreateManyArgs>(args?: SelectSubset<T, ForecastModelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ForecastModels and returns the data saved in the database.
     * @param {ForecastModelCreateManyAndReturnArgs} args - Arguments to create many ForecastModels.
     * @example
     * // Create many ForecastModels
     * const forecastModel = await prisma.forecastModel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ForecastModels and only return the `id`
     * const forecastModelWithIdOnly = await prisma.forecastModel.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ForecastModelCreateManyAndReturnArgs>(args?: SelectSubset<T, ForecastModelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForecastModelPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ForecastModel.
     * @param {ForecastModelDeleteArgs} args - Arguments to delete one ForecastModel.
     * @example
     * // Delete one ForecastModel
     * const ForecastModel = await prisma.forecastModel.delete({
     *   where: {
     *     // ... filter to delete one ForecastModel
     *   }
     * })
     * 
     */
    delete<T extends ForecastModelDeleteArgs>(args: SelectSubset<T, ForecastModelDeleteArgs<ExtArgs>>): Prisma__ForecastModelClient<$Result.GetResult<Prisma.$ForecastModelPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ForecastModel.
     * @param {ForecastModelUpdateArgs} args - Arguments to update one ForecastModel.
     * @example
     * // Update one ForecastModel
     * const forecastModel = await prisma.forecastModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ForecastModelUpdateArgs>(args: SelectSubset<T, ForecastModelUpdateArgs<ExtArgs>>): Prisma__ForecastModelClient<$Result.GetResult<Prisma.$ForecastModelPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ForecastModels.
     * @param {ForecastModelDeleteManyArgs} args - Arguments to filter ForecastModels to delete.
     * @example
     * // Delete a few ForecastModels
     * const { count } = await prisma.forecastModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ForecastModelDeleteManyArgs>(args?: SelectSubset<T, ForecastModelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ForecastModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForecastModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ForecastModels
     * const forecastModel = await prisma.forecastModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ForecastModelUpdateManyArgs>(args: SelectSubset<T, ForecastModelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ForecastModel.
     * @param {ForecastModelUpsertArgs} args - Arguments to update or create a ForecastModel.
     * @example
     * // Update or create a ForecastModel
     * const forecastModel = await prisma.forecastModel.upsert({
     *   create: {
     *     // ... data to create a ForecastModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ForecastModel we want to update
     *   }
     * })
     */
    upsert<T extends ForecastModelUpsertArgs>(args: SelectSubset<T, ForecastModelUpsertArgs<ExtArgs>>): Prisma__ForecastModelClient<$Result.GetResult<Prisma.$ForecastModelPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ForecastModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForecastModelCountArgs} args - Arguments to filter ForecastModels to count.
     * @example
     * // Count the number of ForecastModels
     * const count = await prisma.forecastModel.count({
     *   where: {
     *     // ... the filter for the ForecastModels we want to count
     *   }
     * })
    **/
    count<T extends ForecastModelCountArgs>(
      args?: Subset<T, ForecastModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ForecastModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ForecastModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForecastModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ForecastModelAggregateArgs>(args: Subset<T, ForecastModelAggregateArgs>): Prisma.PrismaPromise<GetForecastModelAggregateType<T>>

    /**
     * Group by ForecastModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForecastModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ForecastModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ForecastModelGroupByArgs['orderBy'] }
        : { orderBy?: ForecastModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ForecastModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetForecastModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ForecastModel model
   */
  readonly fields: ForecastModelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ForecastModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ForecastModelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    forecasts<T extends ForecastModel$forecastsArgs<ExtArgs> = {}>(args?: Subset<T, ForecastModel$forecastsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForecastResultPayload<ExtArgs>, T, "findMany"> | Null>
    timeSeriesData<T extends ForecastModel$timeSeriesDataArgs<ExtArgs> = {}>(args?: Subset<T, ForecastModel$timeSeriesDataArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeSeriesDataPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ForecastModel model
   */ 
  interface ForecastModelFieldRefs {
    readonly id: FieldRef<"ForecastModel", 'String'>
    readonly name: FieldRef<"ForecastModel", 'String'>
    readonly config: FieldRef<"ForecastModel", 'Json'>
    readonly metadata: FieldRef<"ForecastModel", 'Json'>
    readonly status: FieldRef<"ForecastModel", 'String'>
    readonly createdAt: FieldRef<"ForecastModel", 'DateTime'>
    readonly lastTraining: FieldRef<"ForecastModel", 'DateTime'>
    readonly metrics: FieldRef<"ForecastModel", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * ForecastModel findUnique
   */
  export type ForecastModelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForecastModel
     */
    select?: ForecastModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForecastModelInclude<ExtArgs> | null
    /**
     * Filter, which ForecastModel to fetch.
     */
    where: ForecastModelWhereUniqueInput
  }

  /**
   * ForecastModel findUniqueOrThrow
   */
  export type ForecastModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForecastModel
     */
    select?: ForecastModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForecastModelInclude<ExtArgs> | null
    /**
     * Filter, which ForecastModel to fetch.
     */
    where: ForecastModelWhereUniqueInput
  }

  /**
   * ForecastModel findFirst
   */
  export type ForecastModelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForecastModel
     */
    select?: ForecastModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForecastModelInclude<ExtArgs> | null
    /**
     * Filter, which ForecastModel to fetch.
     */
    where?: ForecastModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForecastModels to fetch.
     */
    orderBy?: ForecastModelOrderByWithRelationInput | ForecastModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForecastModels.
     */
    cursor?: ForecastModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForecastModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForecastModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForecastModels.
     */
    distinct?: ForecastModelScalarFieldEnum | ForecastModelScalarFieldEnum[]
  }

  /**
   * ForecastModel findFirstOrThrow
   */
  export type ForecastModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForecastModel
     */
    select?: ForecastModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForecastModelInclude<ExtArgs> | null
    /**
     * Filter, which ForecastModel to fetch.
     */
    where?: ForecastModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForecastModels to fetch.
     */
    orderBy?: ForecastModelOrderByWithRelationInput | ForecastModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForecastModels.
     */
    cursor?: ForecastModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForecastModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForecastModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForecastModels.
     */
    distinct?: ForecastModelScalarFieldEnum | ForecastModelScalarFieldEnum[]
  }

  /**
   * ForecastModel findMany
   */
  export type ForecastModelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForecastModel
     */
    select?: ForecastModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForecastModelInclude<ExtArgs> | null
    /**
     * Filter, which ForecastModels to fetch.
     */
    where?: ForecastModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForecastModels to fetch.
     */
    orderBy?: ForecastModelOrderByWithRelationInput | ForecastModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ForecastModels.
     */
    cursor?: ForecastModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForecastModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForecastModels.
     */
    skip?: number
    distinct?: ForecastModelScalarFieldEnum | ForecastModelScalarFieldEnum[]
  }

  /**
   * ForecastModel create
   */
  export type ForecastModelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForecastModel
     */
    select?: ForecastModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForecastModelInclude<ExtArgs> | null
    /**
     * The data needed to create a ForecastModel.
     */
    data: XOR<ForecastModelCreateInput, ForecastModelUncheckedCreateInput>
  }

  /**
   * ForecastModel createMany
   */
  export type ForecastModelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ForecastModels.
     */
    data: ForecastModelCreateManyInput | ForecastModelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ForecastModel createManyAndReturn
   */
  export type ForecastModelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForecastModel
     */
    select?: ForecastModelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ForecastModels.
     */
    data: ForecastModelCreateManyInput | ForecastModelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ForecastModel update
   */
  export type ForecastModelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForecastModel
     */
    select?: ForecastModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForecastModelInclude<ExtArgs> | null
    /**
     * The data needed to update a ForecastModel.
     */
    data: XOR<ForecastModelUpdateInput, ForecastModelUncheckedUpdateInput>
    /**
     * Choose, which ForecastModel to update.
     */
    where: ForecastModelWhereUniqueInput
  }

  /**
   * ForecastModel updateMany
   */
  export type ForecastModelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ForecastModels.
     */
    data: XOR<ForecastModelUpdateManyMutationInput, ForecastModelUncheckedUpdateManyInput>
    /**
     * Filter which ForecastModels to update
     */
    where?: ForecastModelWhereInput
  }

  /**
   * ForecastModel upsert
   */
  export type ForecastModelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForecastModel
     */
    select?: ForecastModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForecastModelInclude<ExtArgs> | null
    /**
     * The filter to search for the ForecastModel to update in case it exists.
     */
    where: ForecastModelWhereUniqueInput
    /**
     * In case the ForecastModel found by the `where` argument doesn't exist, create a new ForecastModel with this data.
     */
    create: XOR<ForecastModelCreateInput, ForecastModelUncheckedCreateInput>
    /**
     * In case the ForecastModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ForecastModelUpdateInput, ForecastModelUncheckedUpdateInput>
  }

  /**
   * ForecastModel delete
   */
  export type ForecastModelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForecastModel
     */
    select?: ForecastModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForecastModelInclude<ExtArgs> | null
    /**
     * Filter which ForecastModel to delete.
     */
    where: ForecastModelWhereUniqueInput
  }

  /**
   * ForecastModel deleteMany
   */
  export type ForecastModelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForecastModels to delete
     */
    where?: ForecastModelWhereInput
  }

  /**
   * ForecastModel.forecasts
   */
  export type ForecastModel$forecastsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForecastResult
     */
    select?: ForecastResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForecastResultInclude<ExtArgs> | null
    where?: ForecastResultWhereInput
    orderBy?: ForecastResultOrderByWithRelationInput | ForecastResultOrderByWithRelationInput[]
    cursor?: ForecastResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ForecastResultScalarFieldEnum | ForecastResultScalarFieldEnum[]
  }

  /**
   * ForecastModel.timeSeriesData
   */
  export type ForecastModel$timeSeriesDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSeriesData
     */
    select?: TimeSeriesDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSeriesDataInclude<ExtArgs> | null
    where?: TimeSeriesDataWhereInput
    orderBy?: TimeSeriesDataOrderByWithRelationInput | TimeSeriesDataOrderByWithRelationInput[]
    cursor?: TimeSeriesDataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimeSeriesDataScalarFieldEnum | TimeSeriesDataScalarFieldEnum[]
  }

  /**
   * ForecastModel without action
   */
  export type ForecastModelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForecastModel
     */
    select?: ForecastModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForecastModelInclude<ExtArgs> | null
  }


  /**
   * Model TimeSeriesData
   */

  export type AggregateTimeSeriesData = {
    _count: TimeSeriesDataCountAggregateOutputType | null
    _avg: TimeSeriesDataAvgAggregateOutputType | null
    _sum: TimeSeriesDataSumAggregateOutputType | null
    _min: TimeSeriesDataMinAggregateOutputType | null
    _max: TimeSeriesDataMaxAggregateOutputType | null
  }

  export type TimeSeriesDataAvgAggregateOutputType = {
    value: number | null
  }

  export type TimeSeriesDataSumAggregateOutputType = {
    value: number | null
  }

  export type TimeSeriesDataMinAggregateOutputType = {
    id: string | null
    timestamp: Date | null
    value: number | null
    modelId: string | null
  }

  export type TimeSeriesDataMaxAggregateOutputType = {
    id: string | null
    timestamp: Date | null
    value: number | null
    modelId: string | null
  }

  export type TimeSeriesDataCountAggregateOutputType = {
    id: number
    timestamp: number
    value: number
    metadata: number
    modelId: number
    _all: number
  }


  export type TimeSeriesDataAvgAggregateInputType = {
    value?: true
  }

  export type TimeSeriesDataSumAggregateInputType = {
    value?: true
  }

  export type TimeSeriesDataMinAggregateInputType = {
    id?: true
    timestamp?: true
    value?: true
    modelId?: true
  }

  export type TimeSeriesDataMaxAggregateInputType = {
    id?: true
    timestamp?: true
    value?: true
    modelId?: true
  }

  export type TimeSeriesDataCountAggregateInputType = {
    id?: true
    timestamp?: true
    value?: true
    metadata?: true
    modelId?: true
    _all?: true
  }

  export type TimeSeriesDataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimeSeriesData to aggregate.
     */
    where?: TimeSeriesDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeSeriesData to fetch.
     */
    orderBy?: TimeSeriesDataOrderByWithRelationInput | TimeSeriesDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TimeSeriesDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeSeriesData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeSeriesData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TimeSeriesData
    **/
    _count?: true | TimeSeriesDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TimeSeriesDataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TimeSeriesDataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TimeSeriesDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TimeSeriesDataMaxAggregateInputType
  }

  export type GetTimeSeriesDataAggregateType<T extends TimeSeriesDataAggregateArgs> = {
        [P in keyof T & keyof AggregateTimeSeriesData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTimeSeriesData[P]>
      : GetScalarType<T[P], AggregateTimeSeriesData[P]>
  }




  export type TimeSeriesDataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeSeriesDataWhereInput
    orderBy?: TimeSeriesDataOrderByWithAggregationInput | TimeSeriesDataOrderByWithAggregationInput[]
    by: TimeSeriesDataScalarFieldEnum[] | TimeSeriesDataScalarFieldEnum
    having?: TimeSeriesDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TimeSeriesDataCountAggregateInputType | true
    _avg?: TimeSeriesDataAvgAggregateInputType
    _sum?: TimeSeriesDataSumAggregateInputType
    _min?: TimeSeriesDataMinAggregateInputType
    _max?: TimeSeriesDataMaxAggregateInputType
  }

  export type TimeSeriesDataGroupByOutputType = {
    id: string
    timestamp: Date
    value: number
    metadata: JsonValue | null
    modelId: string
    _count: TimeSeriesDataCountAggregateOutputType | null
    _avg: TimeSeriesDataAvgAggregateOutputType | null
    _sum: TimeSeriesDataSumAggregateOutputType | null
    _min: TimeSeriesDataMinAggregateOutputType | null
    _max: TimeSeriesDataMaxAggregateOutputType | null
  }

  type GetTimeSeriesDataGroupByPayload<T extends TimeSeriesDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TimeSeriesDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TimeSeriesDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TimeSeriesDataGroupByOutputType[P]>
            : GetScalarType<T[P], TimeSeriesDataGroupByOutputType[P]>
        }
      >
    >


  export type TimeSeriesDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    value?: boolean
    metadata?: boolean
    modelId?: boolean
    model?: boolean | ForecastModelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timeSeriesData"]>

  export type TimeSeriesDataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    value?: boolean
    metadata?: boolean
    modelId?: boolean
    model?: boolean | ForecastModelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timeSeriesData"]>

  export type TimeSeriesDataSelectScalar = {
    id?: boolean
    timestamp?: boolean
    value?: boolean
    metadata?: boolean
    modelId?: boolean
  }

  export type TimeSeriesDataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    model?: boolean | ForecastModelDefaultArgs<ExtArgs>
  }
  export type TimeSeriesDataIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    model?: boolean | ForecastModelDefaultArgs<ExtArgs>
  }

  export type $TimeSeriesDataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TimeSeriesData"
    objects: {
      model: Prisma.$ForecastModelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      timestamp: Date
      value: number
      metadata: Prisma.JsonValue | null
      modelId: string
    }, ExtArgs["result"]["timeSeriesData"]>
    composites: {}
  }

  type TimeSeriesDataGetPayload<S extends boolean | null | undefined | TimeSeriesDataDefaultArgs> = $Result.GetResult<Prisma.$TimeSeriesDataPayload, S>

  type TimeSeriesDataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TimeSeriesDataFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TimeSeriesDataCountAggregateInputType | true
    }

  export interface TimeSeriesDataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TimeSeriesData'], meta: { name: 'TimeSeriesData' } }
    /**
     * Find zero or one TimeSeriesData that matches the filter.
     * @param {TimeSeriesDataFindUniqueArgs} args - Arguments to find a TimeSeriesData
     * @example
     * // Get one TimeSeriesData
     * const timeSeriesData = await prisma.timeSeriesData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TimeSeriesDataFindUniqueArgs>(args: SelectSubset<T, TimeSeriesDataFindUniqueArgs<ExtArgs>>): Prisma__TimeSeriesDataClient<$Result.GetResult<Prisma.$TimeSeriesDataPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TimeSeriesData that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TimeSeriesDataFindUniqueOrThrowArgs} args - Arguments to find a TimeSeriesData
     * @example
     * // Get one TimeSeriesData
     * const timeSeriesData = await prisma.timeSeriesData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TimeSeriesDataFindUniqueOrThrowArgs>(args: SelectSubset<T, TimeSeriesDataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TimeSeriesDataClient<$Result.GetResult<Prisma.$TimeSeriesDataPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TimeSeriesData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSeriesDataFindFirstArgs} args - Arguments to find a TimeSeriesData
     * @example
     * // Get one TimeSeriesData
     * const timeSeriesData = await prisma.timeSeriesData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TimeSeriesDataFindFirstArgs>(args?: SelectSubset<T, TimeSeriesDataFindFirstArgs<ExtArgs>>): Prisma__TimeSeriesDataClient<$Result.GetResult<Prisma.$TimeSeriesDataPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TimeSeriesData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSeriesDataFindFirstOrThrowArgs} args - Arguments to find a TimeSeriesData
     * @example
     * // Get one TimeSeriesData
     * const timeSeriesData = await prisma.timeSeriesData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TimeSeriesDataFindFirstOrThrowArgs>(args?: SelectSubset<T, TimeSeriesDataFindFirstOrThrowArgs<ExtArgs>>): Prisma__TimeSeriesDataClient<$Result.GetResult<Prisma.$TimeSeriesDataPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TimeSeriesData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSeriesDataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TimeSeriesData
     * const timeSeriesData = await prisma.timeSeriesData.findMany()
     * 
     * // Get first 10 TimeSeriesData
     * const timeSeriesData = await prisma.timeSeriesData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const timeSeriesDataWithIdOnly = await prisma.timeSeriesData.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TimeSeriesDataFindManyArgs>(args?: SelectSubset<T, TimeSeriesDataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeSeriesDataPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TimeSeriesData.
     * @param {TimeSeriesDataCreateArgs} args - Arguments to create a TimeSeriesData.
     * @example
     * // Create one TimeSeriesData
     * const TimeSeriesData = await prisma.timeSeriesData.create({
     *   data: {
     *     // ... data to create a TimeSeriesData
     *   }
     * })
     * 
     */
    create<T extends TimeSeriesDataCreateArgs>(args: SelectSubset<T, TimeSeriesDataCreateArgs<ExtArgs>>): Prisma__TimeSeriesDataClient<$Result.GetResult<Prisma.$TimeSeriesDataPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TimeSeriesData.
     * @param {TimeSeriesDataCreateManyArgs} args - Arguments to create many TimeSeriesData.
     * @example
     * // Create many TimeSeriesData
     * const timeSeriesData = await prisma.timeSeriesData.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TimeSeriesDataCreateManyArgs>(args?: SelectSubset<T, TimeSeriesDataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TimeSeriesData and returns the data saved in the database.
     * @param {TimeSeriesDataCreateManyAndReturnArgs} args - Arguments to create many TimeSeriesData.
     * @example
     * // Create many TimeSeriesData
     * const timeSeriesData = await prisma.timeSeriesData.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TimeSeriesData and only return the `id`
     * const timeSeriesDataWithIdOnly = await prisma.timeSeriesData.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TimeSeriesDataCreateManyAndReturnArgs>(args?: SelectSubset<T, TimeSeriesDataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeSeriesDataPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TimeSeriesData.
     * @param {TimeSeriesDataDeleteArgs} args - Arguments to delete one TimeSeriesData.
     * @example
     * // Delete one TimeSeriesData
     * const TimeSeriesData = await prisma.timeSeriesData.delete({
     *   where: {
     *     // ... filter to delete one TimeSeriesData
     *   }
     * })
     * 
     */
    delete<T extends TimeSeriesDataDeleteArgs>(args: SelectSubset<T, TimeSeriesDataDeleteArgs<ExtArgs>>): Prisma__TimeSeriesDataClient<$Result.GetResult<Prisma.$TimeSeriesDataPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TimeSeriesData.
     * @param {TimeSeriesDataUpdateArgs} args - Arguments to update one TimeSeriesData.
     * @example
     * // Update one TimeSeriesData
     * const timeSeriesData = await prisma.timeSeriesData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TimeSeriesDataUpdateArgs>(args: SelectSubset<T, TimeSeriesDataUpdateArgs<ExtArgs>>): Prisma__TimeSeriesDataClient<$Result.GetResult<Prisma.$TimeSeriesDataPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TimeSeriesData.
     * @param {TimeSeriesDataDeleteManyArgs} args - Arguments to filter TimeSeriesData to delete.
     * @example
     * // Delete a few TimeSeriesData
     * const { count } = await prisma.timeSeriesData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TimeSeriesDataDeleteManyArgs>(args?: SelectSubset<T, TimeSeriesDataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TimeSeriesData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSeriesDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TimeSeriesData
     * const timeSeriesData = await prisma.timeSeriesData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TimeSeriesDataUpdateManyArgs>(args: SelectSubset<T, TimeSeriesDataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TimeSeriesData.
     * @param {TimeSeriesDataUpsertArgs} args - Arguments to update or create a TimeSeriesData.
     * @example
     * // Update or create a TimeSeriesData
     * const timeSeriesData = await prisma.timeSeriesData.upsert({
     *   create: {
     *     // ... data to create a TimeSeriesData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TimeSeriesData we want to update
     *   }
     * })
     */
    upsert<T extends TimeSeriesDataUpsertArgs>(args: SelectSubset<T, TimeSeriesDataUpsertArgs<ExtArgs>>): Prisma__TimeSeriesDataClient<$Result.GetResult<Prisma.$TimeSeriesDataPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TimeSeriesData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSeriesDataCountArgs} args - Arguments to filter TimeSeriesData to count.
     * @example
     * // Count the number of TimeSeriesData
     * const count = await prisma.timeSeriesData.count({
     *   where: {
     *     // ... the filter for the TimeSeriesData we want to count
     *   }
     * })
    **/
    count<T extends TimeSeriesDataCountArgs>(
      args?: Subset<T, TimeSeriesDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TimeSeriesDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TimeSeriesData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSeriesDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TimeSeriesDataAggregateArgs>(args: Subset<T, TimeSeriesDataAggregateArgs>): Prisma.PrismaPromise<GetTimeSeriesDataAggregateType<T>>

    /**
     * Group by TimeSeriesData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSeriesDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TimeSeriesDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TimeSeriesDataGroupByArgs['orderBy'] }
        : { orderBy?: TimeSeriesDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TimeSeriesDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTimeSeriesDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TimeSeriesData model
   */
  readonly fields: TimeSeriesDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TimeSeriesData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TimeSeriesDataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    model<T extends ForecastModelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ForecastModelDefaultArgs<ExtArgs>>): Prisma__ForecastModelClient<$Result.GetResult<Prisma.$ForecastModelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TimeSeriesData model
   */ 
  interface TimeSeriesDataFieldRefs {
    readonly id: FieldRef<"TimeSeriesData", 'String'>
    readonly timestamp: FieldRef<"TimeSeriesData", 'DateTime'>
    readonly value: FieldRef<"TimeSeriesData", 'Float'>
    readonly metadata: FieldRef<"TimeSeriesData", 'Json'>
    readonly modelId: FieldRef<"TimeSeriesData", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TimeSeriesData findUnique
   */
  export type TimeSeriesDataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSeriesData
     */
    select?: TimeSeriesDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSeriesDataInclude<ExtArgs> | null
    /**
     * Filter, which TimeSeriesData to fetch.
     */
    where: TimeSeriesDataWhereUniqueInput
  }

  /**
   * TimeSeriesData findUniqueOrThrow
   */
  export type TimeSeriesDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSeriesData
     */
    select?: TimeSeriesDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSeriesDataInclude<ExtArgs> | null
    /**
     * Filter, which TimeSeriesData to fetch.
     */
    where: TimeSeriesDataWhereUniqueInput
  }

  /**
   * TimeSeriesData findFirst
   */
  export type TimeSeriesDataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSeriesData
     */
    select?: TimeSeriesDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSeriesDataInclude<ExtArgs> | null
    /**
     * Filter, which TimeSeriesData to fetch.
     */
    where?: TimeSeriesDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeSeriesData to fetch.
     */
    orderBy?: TimeSeriesDataOrderByWithRelationInput | TimeSeriesDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimeSeriesData.
     */
    cursor?: TimeSeriesDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeSeriesData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeSeriesData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimeSeriesData.
     */
    distinct?: TimeSeriesDataScalarFieldEnum | TimeSeriesDataScalarFieldEnum[]
  }

  /**
   * TimeSeriesData findFirstOrThrow
   */
  export type TimeSeriesDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSeriesData
     */
    select?: TimeSeriesDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSeriesDataInclude<ExtArgs> | null
    /**
     * Filter, which TimeSeriesData to fetch.
     */
    where?: TimeSeriesDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeSeriesData to fetch.
     */
    orderBy?: TimeSeriesDataOrderByWithRelationInput | TimeSeriesDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimeSeriesData.
     */
    cursor?: TimeSeriesDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeSeriesData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeSeriesData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimeSeriesData.
     */
    distinct?: TimeSeriesDataScalarFieldEnum | TimeSeriesDataScalarFieldEnum[]
  }

  /**
   * TimeSeriesData findMany
   */
  export type TimeSeriesDataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSeriesData
     */
    select?: TimeSeriesDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSeriesDataInclude<ExtArgs> | null
    /**
     * Filter, which TimeSeriesData to fetch.
     */
    where?: TimeSeriesDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeSeriesData to fetch.
     */
    orderBy?: TimeSeriesDataOrderByWithRelationInput | TimeSeriesDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TimeSeriesData.
     */
    cursor?: TimeSeriesDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeSeriesData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeSeriesData.
     */
    skip?: number
    distinct?: TimeSeriesDataScalarFieldEnum | TimeSeriesDataScalarFieldEnum[]
  }

  /**
   * TimeSeriesData create
   */
  export type TimeSeriesDataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSeriesData
     */
    select?: TimeSeriesDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSeriesDataInclude<ExtArgs> | null
    /**
     * The data needed to create a TimeSeriesData.
     */
    data: XOR<TimeSeriesDataCreateInput, TimeSeriesDataUncheckedCreateInput>
  }

  /**
   * TimeSeriesData createMany
   */
  export type TimeSeriesDataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TimeSeriesData.
     */
    data: TimeSeriesDataCreateManyInput | TimeSeriesDataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TimeSeriesData createManyAndReturn
   */
  export type TimeSeriesDataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSeriesData
     */
    select?: TimeSeriesDataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TimeSeriesData.
     */
    data: TimeSeriesDataCreateManyInput | TimeSeriesDataCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSeriesDataIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TimeSeriesData update
   */
  export type TimeSeriesDataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSeriesData
     */
    select?: TimeSeriesDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSeriesDataInclude<ExtArgs> | null
    /**
     * The data needed to update a TimeSeriesData.
     */
    data: XOR<TimeSeriesDataUpdateInput, TimeSeriesDataUncheckedUpdateInput>
    /**
     * Choose, which TimeSeriesData to update.
     */
    where: TimeSeriesDataWhereUniqueInput
  }

  /**
   * TimeSeriesData updateMany
   */
  export type TimeSeriesDataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TimeSeriesData.
     */
    data: XOR<TimeSeriesDataUpdateManyMutationInput, TimeSeriesDataUncheckedUpdateManyInput>
    /**
     * Filter which TimeSeriesData to update
     */
    where?: TimeSeriesDataWhereInput
  }

  /**
   * TimeSeriesData upsert
   */
  export type TimeSeriesDataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSeriesData
     */
    select?: TimeSeriesDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSeriesDataInclude<ExtArgs> | null
    /**
     * The filter to search for the TimeSeriesData to update in case it exists.
     */
    where: TimeSeriesDataWhereUniqueInput
    /**
     * In case the TimeSeriesData found by the `where` argument doesn't exist, create a new TimeSeriesData with this data.
     */
    create: XOR<TimeSeriesDataCreateInput, TimeSeriesDataUncheckedCreateInput>
    /**
     * In case the TimeSeriesData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TimeSeriesDataUpdateInput, TimeSeriesDataUncheckedUpdateInput>
  }

  /**
   * TimeSeriesData delete
   */
  export type TimeSeriesDataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSeriesData
     */
    select?: TimeSeriesDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSeriesDataInclude<ExtArgs> | null
    /**
     * Filter which TimeSeriesData to delete.
     */
    where: TimeSeriesDataWhereUniqueInput
  }

  /**
   * TimeSeriesData deleteMany
   */
  export type TimeSeriesDataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimeSeriesData to delete
     */
    where?: TimeSeriesDataWhereInput
  }

  /**
   * TimeSeriesData without action
   */
  export type TimeSeriesDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSeriesData
     */
    select?: TimeSeriesDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSeriesDataInclude<ExtArgs> | null
  }


  /**
   * Model ForecastResult
   */

  export type AggregateForecastResult = {
    _count: ForecastResultCountAggregateOutputType | null
    _avg: ForecastResultAvgAggregateOutputType | null
    _sum: ForecastResultSumAggregateOutputType | null
    _min: ForecastResultMinAggregateOutputType | null
    _max: ForecastResultMaxAggregateOutputType | null
  }

  export type ForecastResultAvgAggregateOutputType = {
    value: number | null
    lowerBound: number | null
    upperBound: number | null
    confidence: number | null
  }

  export type ForecastResultSumAggregateOutputType = {
    value: number | null
    lowerBound: number | null
    upperBound: number | null
    confidence: number | null
  }

  export type ForecastResultMinAggregateOutputType = {
    id: string | null
    timestamp: Date | null
    value: number | null
    lowerBound: number | null
    upperBound: number | null
    confidence: number | null
    modelId: string | null
  }

  export type ForecastResultMaxAggregateOutputType = {
    id: string | null
    timestamp: Date | null
    value: number | null
    lowerBound: number | null
    upperBound: number | null
    confidence: number | null
    modelId: string | null
  }

  export type ForecastResultCountAggregateOutputType = {
    id: number
    timestamp: number
    value: number
    lowerBound: number
    upperBound: number
    confidence: number
    metadata: number
    modelId: number
    _all: number
  }


  export type ForecastResultAvgAggregateInputType = {
    value?: true
    lowerBound?: true
    upperBound?: true
    confidence?: true
  }

  export type ForecastResultSumAggregateInputType = {
    value?: true
    lowerBound?: true
    upperBound?: true
    confidence?: true
  }

  export type ForecastResultMinAggregateInputType = {
    id?: true
    timestamp?: true
    value?: true
    lowerBound?: true
    upperBound?: true
    confidence?: true
    modelId?: true
  }

  export type ForecastResultMaxAggregateInputType = {
    id?: true
    timestamp?: true
    value?: true
    lowerBound?: true
    upperBound?: true
    confidence?: true
    modelId?: true
  }

  export type ForecastResultCountAggregateInputType = {
    id?: true
    timestamp?: true
    value?: true
    lowerBound?: true
    upperBound?: true
    confidence?: true
    metadata?: true
    modelId?: true
    _all?: true
  }

  export type ForecastResultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForecastResult to aggregate.
     */
    where?: ForecastResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForecastResults to fetch.
     */
    orderBy?: ForecastResultOrderByWithRelationInput | ForecastResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ForecastResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForecastResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForecastResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ForecastResults
    **/
    _count?: true | ForecastResultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ForecastResultAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ForecastResultSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ForecastResultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ForecastResultMaxAggregateInputType
  }

  export type GetForecastResultAggregateType<T extends ForecastResultAggregateArgs> = {
        [P in keyof T & keyof AggregateForecastResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateForecastResult[P]>
      : GetScalarType<T[P], AggregateForecastResult[P]>
  }




  export type ForecastResultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForecastResultWhereInput
    orderBy?: ForecastResultOrderByWithAggregationInput | ForecastResultOrderByWithAggregationInput[]
    by: ForecastResultScalarFieldEnum[] | ForecastResultScalarFieldEnum
    having?: ForecastResultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ForecastResultCountAggregateInputType | true
    _avg?: ForecastResultAvgAggregateInputType
    _sum?: ForecastResultSumAggregateInputType
    _min?: ForecastResultMinAggregateInputType
    _max?: ForecastResultMaxAggregateInputType
  }

  export type ForecastResultGroupByOutputType = {
    id: string
    timestamp: Date
    value: number
    lowerBound: number | null
    upperBound: number | null
    confidence: number | null
    metadata: JsonValue | null
    modelId: string
    _count: ForecastResultCountAggregateOutputType | null
    _avg: ForecastResultAvgAggregateOutputType | null
    _sum: ForecastResultSumAggregateOutputType | null
    _min: ForecastResultMinAggregateOutputType | null
    _max: ForecastResultMaxAggregateOutputType | null
  }

  type GetForecastResultGroupByPayload<T extends ForecastResultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ForecastResultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ForecastResultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ForecastResultGroupByOutputType[P]>
            : GetScalarType<T[P], ForecastResultGroupByOutputType[P]>
        }
      >
    >


  export type ForecastResultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    value?: boolean
    lowerBound?: boolean
    upperBound?: boolean
    confidence?: boolean
    metadata?: boolean
    modelId?: boolean
    model?: boolean | ForecastModelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["forecastResult"]>

  export type ForecastResultSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    value?: boolean
    lowerBound?: boolean
    upperBound?: boolean
    confidence?: boolean
    metadata?: boolean
    modelId?: boolean
    model?: boolean | ForecastModelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["forecastResult"]>

  export type ForecastResultSelectScalar = {
    id?: boolean
    timestamp?: boolean
    value?: boolean
    lowerBound?: boolean
    upperBound?: boolean
    confidence?: boolean
    metadata?: boolean
    modelId?: boolean
  }

  export type ForecastResultInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    model?: boolean | ForecastModelDefaultArgs<ExtArgs>
  }
  export type ForecastResultIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    model?: boolean | ForecastModelDefaultArgs<ExtArgs>
  }

  export type $ForecastResultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ForecastResult"
    objects: {
      model: Prisma.$ForecastModelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      timestamp: Date
      value: number
      lowerBound: number | null
      upperBound: number | null
      confidence: number | null
      metadata: Prisma.JsonValue | null
      modelId: string
    }, ExtArgs["result"]["forecastResult"]>
    composites: {}
  }

  type ForecastResultGetPayload<S extends boolean | null | undefined | ForecastResultDefaultArgs> = $Result.GetResult<Prisma.$ForecastResultPayload, S>

  type ForecastResultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ForecastResultFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ForecastResultCountAggregateInputType | true
    }

  export interface ForecastResultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ForecastResult'], meta: { name: 'ForecastResult' } }
    /**
     * Find zero or one ForecastResult that matches the filter.
     * @param {ForecastResultFindUniqueArgs} args - Arguments to find a ForecastResult
     * @example
     * // Get one ForecastResult
     * const forecastResult = await prisma.forecastResult.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ForecastResultFindUniqueArgs>(args: SelectSubset<T, ForecastResultFindUniqueArgs<ExtArgs>>): Prisma__ForecastResultClient<$Result.GetResult<Prisma.$ForecastResultPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ForecastResult that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ForecastResultFindUniqueOrThrowArgs} args - Arguments to find a ForecastResult
     * @example
     * // Get one ForecastResult
     * const forecastResult = await prisma.forecastResult.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ForecastResultFindUniqueOrThrowArgs>(args: SelectSubset<T, ForecastResultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ForecastResultClient<$Result.GetResult<Prisma.$ForecastResultPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ForecastResult that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForecastResultFindFirstArgs} args - Arguments to find a ForecastResult
     * @example
     * // Get one ForecastResult
     * const forecastResult = await prisma.forecastResult.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ForecastResultFindFirstArgs>(args?: SelectSubset<T, ForecastResultFindFirstArgs<ExtArgs>>): Prisma__ForecastResultClient<$Result.GetResult<Prisma.$ForecastResultPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ForecastResult that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForecastResultFindFirstOrThrowArgs} args - Arguments to find a ForecastResult
     * @example
     * // Get one ForecastResult
     * const forecastResult = await prisma.forecastResult.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ForecastResultFindFirstOrThrowArgs>(args?: SelectSubset<T, ForecastResultFindFirstOrThrowArgs<ExtArgs>>): Prisma__ForecastResultClient<$Result.GetResult<Prisma.$ForecastResultPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ForecastResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForecastResultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ForecastResults
     * const forecastResults = await prisma.forecastResult.findMany()
     * 
     * // Get first 10 ForecastResults
     * const forecastResults = await prisma.forecastResult.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const forecastResultWithIdOnly = await prisma.forecastResult.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ForecastResultFindManyArgs>(args?: SelectSubset<T, ForecastResultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForecastResultPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ForecastResult.
     * @param {ForecastResultCreateArgs} args - Arguments to create a ForecastResult.
     * @example
     * // Create one ForecastResult
     * const ForecastResult = await prisma.forecastResult.create({
     *   data: {
     *     // ... data to create a ForecastResult
     *   }
     * })
     * 
     */
    create<T extends ForecastResultCreateArgs>(args: SelectSubset<T, ForecastResultCreateArgs<ExtArgs>>): Prisma__ForecastResultClient<$Result.GetResult<Prisma.$ForecastResultPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ForecastResults.
     * @param {ForecastResultCreateManyArgs} args - Arguments to create many ForecastResults.
     * @example
     * // Create many ForecastResults
     * const forecastResult = await prisma.forecastResult.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ForecastResultCreateManyArgs>(args?: SelectSubset<T, ForecastResultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ForecastResults and returns the data saved in the database.
     * @param {ForecastResultCreateManyAndReturnArgs} args - Arguments to create many ForecastResults.
     * @example
     * // Create many ForecastResults
     * const forecastResult = await prisma.forecastResult.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ForecastResults and only return the `id`
     * const forecastResultWithIdOnly = await prisma.forecastResult.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ForecastResultCreateManyAndReturnArgs>(args?: SelectSubset<T, ForecastResultCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForecastResultPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ForecastResult.
     * @param {ForecastResultDeleteArgs} args - Arguments to delete one ForecastResult.
     * @example
     * // Delete one ForecastResult
     * const ForecastResult = await prisma.forecastResult.delete({
     *   where: {
     *     // ... filter to delete one ForecastResult
     *   }
     * })
     * 
     */
    delete<T extends ForecastResultDeleteArgs>(args: SelectSubset<T, ForecastResultDeleteArgs<ExtArgs>>): Prisma__ForecastResultClient<$Result.GetResult<Prisma.$ForecastResultPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ForecastResult.
     * @param {ForecastResultUpdateArgs} args - Arguments to update one ForecastResult.
     * @example
     * // Update one ForecastResult
     * const forecastResult = await prisma.forecastResult.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ForecastResultUpdateArgs>(args: SelectSubset<T, ForecastResultUpdateArgs<ExtArgs>>): Prisma__ForecastResultClient<$Result.GetResult<Prisma.$ForecastResultPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ForecastResults.
     * @param {ForecastResultDeleteManyArgs} args - Arguments to filter ForecastResults to delete.
     * @example
     * // Delete a few ForecastResults
     * const { count } = await prisma.forecastResult.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ForecastResultDeleteManyArgs>(args?: SelectSubset<T, ForecastResultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ForecastResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForecastResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ForecastResults
     * const forecastResult = await prisma.forecastResult.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ForecastResultUpdateManyArgs>(args: SelectSubset<T, ForecastResultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ForecastResult.
     * @param {ForecastResultUpsertArgs} args - Arguments to update or create a ForecastResult.
     * @example
     * // Update or create a ForecastResult
     * const forecastResult = await prisma.forecastResult.upsert({
     *   create: {
     *     // ... data to create a ForecastResult
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ForecastResult we want to update
     *   }
     * })
     */
    upsert<T extends ForecastResultUpsertArgs>(args: SelectSubset<T, ForecastResultUpsertArgs<ExtArgs>>): Prisma__ForecastResultClient<$Result.GetResult<Prisma.$ForecastResultPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ForecastResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForecastResultCountArgs} args - Arguments to filter ForecastResults to count.
     * @example
     * // Count the number of ForecastResults
     * const count = await prisma.forecastResult.count({
     *   where: {
     *     // ... the filter for the ForecastResults we want to count
     *   }
     * })
    **/
    count<T extends ForecastResultCountArgs>(
      args?: Subset<T, ForecastResultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ForecastResultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ForecastResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForecastResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ForecastResultAggregateArgs>(args: Subset<T, ForecastResultAggregateArgs>): Prisma.PrismaPromise<GetForecastResultAggregateType<T>>

    /**
     * Group by ForecastResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForecastResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ForecastResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ForecastResultGroupByArgs['orderBy'] }
        : { orderBy?: ForecastResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ForecastResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetForecastResultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ForecastResult model
   */
  readonly fields: ForecastResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ForecastResult.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ForecastResultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    model<T extends ForecastModelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ForecastModelDefaultArgs<ExtArgs>>): Prisma__ForecastModelClient<$Result.GetResult<Prisma.$ForecastModelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ForecastResult model
   */ 
  interface ForecastResultFieldRefs {
    readonly id: FieldRef<"ForecastResult", 'String'>
    readonly timestamp: FieldRef<"ForecastResult", 'DateTime'>
    readonly value: FieldRef<"ForecastResult", 'Float'>
    readonly lowerBound: FieldRef<"ForecastResult", 'Float'>
    readonly upperBound: FieldRef<"ForecastResult", 'Float'>
    readonly confidence: FieldRef<"ForecastResult", 'Float'>
    readonly metadata: FieldRef<"ForecastResult", 'Json'>
    readonly modelId: FieldRef<"ForecastResult", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ForecastResult findUnique
   */
  export type ForecastResultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForecastResult
     */
    select?: ForecastResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForecastResultInclude<ExtArgs> | null
    /**
     * Filter, which ForecastResult to fetch.
     */
    where: ForecastResultWhereUniqueInput
  }

  /**
   * ForecastResult findUniqueOrThrow
   */
  export type ForecastResultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForecastResult
     */
    select?: ForecastResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForecastResultInclude<ExtArgs> | null
    /**
     * Filter, which ForecastResult to fetch.
     */
    where: ForecastResultWhereUniqueInput
  }

  /**
   * ForecastResult findFirst
   */
  export type ForecastResultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForecastResult
     */
    select?: ForecastResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForecastResultInclude<ExtArgs> | null
    /**
     * Filter, which ForecastResult to fetch.
     */
    where?: ForecastResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForecastResults to fetch.
     */
    orderBy?: ForecastResultOrderByWithRelationInput | ForecastResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForecastResults.
     */
    cursor?: ForecastResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForecastResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForecastResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForecastResults.
     */
    distinct?: ForecastResultScalarFieldEnum | ForecastResultScalarFieldEnum[]
  }

  /**
   * ForecastResult findFirstOrThrow
   */
  export type ForecastResultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForecastResult
     */
    select?: ForecastResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForecastResultInclude<ExtArgs> | null
    /**
     * Filter, which ForecastResult to fetch.
     */
    where?: ForecastResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForecastResults to fetch.
     */
    orderBy?: ForecastResultOrderByWithRelationInput | ForecastResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForecastResults.
     */
    cursor?: ForecastResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForecastResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForecastResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForecastResults.
     */
    distinct?: ForecastResultScalarFieldEnum | ForecastResultScalarFieldEnum[]
  }

  /**
   * ForecastResult findMany
   */
  export type ForecastResultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForecastResult
     */
    select?: ForecastResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForecastResultInclude<ExtArgs> | null
    /**
     * Filter, which ForecastResults to fetch.
     */
    where?: ForecastResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForecastResults to fetch.
     */
    orderBy?: ForecastResultOrderByWithRelationInput | ForecastResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ForecastResults.
     */
    cursor?: ForecastResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForecastResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForecastResults.
     */
    skip?: number
    distinct?: ForecastResultScalarFieldEnum | ForecastResultScalarFieldEnum[]
  }

  /**
   * ForecastResult create
   */
  export type ForecastResultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForecastResult
     */
    select?: ForecastResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForecastResultInclude<ExtArgs> | null
    /**
     * The data needed to create a ForecastResult.
     */
    data: XOR<ForecastResultCreateInput, ForecastResultUncheckedCreateInput>
  }

  /**
   * ForecastResult createMany
   */
  export type ForecastResultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ForecastResults.
     */
    data: ForecastResultCreateManyInput | ForecastResultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ForecastResult createManyAndReturn
   */
  export type ForecastResultCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForecastResult
     */
    select?: ForecastResultSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ForecastResults.
     */
    data: ForecastResultCreateManyInput | ForecastResultCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForecastResultIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ForecastResult update
   */
  export type ForecastResultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForecastResult
     */
    select?: ForecastResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForecastResultInclude<ExtArgs> | null
    /**
     * The data needed to update a ForecastResult.
     */
    data: XOR<ForecastResultUpdateInput, ForecastResultUncheckedUpdateInput>
    /**
     * Choose, which ForecastResult to update.
     */
    where: ForecastResultWhereUniqueInput
  }

  /**
   * ForecastResult updateMany
   */
  export type ForecastResultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ForecastResults.
     */
    data: XOR<ForecastResultUpdateManyMutationInput, ForecastResultUncheckedUpdateManyInput>
    /**
     * Filter which ForecastResults to update
     */
    where?: ForecastResultWhereInput
  }

  /**
   * ForecastResult upsert
   */
  export type ForecastResultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForecastResult
     */
    select?: ForecastResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForecastResultInclude<ExtArgs> | null
    /**
     * The filter to search for the ForecastResult to update in case it exists.
     */
    where: ForecastResultWhereUniqueInput
    /**
     * In case the ForecastResult found by the `where` argument doesn't exist, create a new ForecastResult with this data.
     */
    create: XOR<ForecastResultCreateInput, ForecastResultUncheckedCreateInput>
    /**
     * In case the ForecastResult was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ForecastResultUpdateInput, ForecastResultUncheckedUpdateInput>
  }

  /**
   * ForecastResult delete
   */
  export type ForecastResultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForecastResult
     */
    select?: ForecastResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForecastResultInclude<ExtArgs> | null
    /**
     * Filter which ForecastResult to delete.
     */
    where: ForecastResultWhereUniqueInput
  }

  /**
   * ForecastResult deleteMany
   */
  export type ForecastResultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForecastResults to delete
     */
    where?: ForecastResultWhereInput
  }

  /**
   * ForecastResult without action
   */
  export type ForecastResultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForecastResult
     */
    select?: ForecastResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForecastResultInclude<ExtArgs> | null
  }


  /**
   * Model MarketTrend
   */

  export type AggregateMarketTrend = {
    _count: MarketTrendCountAggregateOutputType | null
    _avg: MarketTrendAvgAggregateOutputType | null
    _sum: MarketTrendSumAggregateOutputType | null
    _min: MarketTrendMinAggregateOutputType | null
    _max: MarketTrendMaxAggregateOutputType | null
  }

  export type MarketTrendAvgAggregateOutputType = {
    trend: number | null
    seasonality: number | null
  }

  export type MarketTrendSumAggregateOutputType = {
    trend: number | null
    seasonality: number | null
  }

  export type MarketTrendMinAggregateOutputType = {
    id: string | null
    timestamp: Date | null
    trend: number | null
    seasonality: number | null
  }

  export type MarketTrendMaxAggregateOutputType = {
    id: string | null
    timestamp: Date | null
    trend: number | null
    seasonality: number | null
  }

  export type MarketTrendCountAggregateOutputType = {
    id: number
    timestamp: number
    trend: number
    seasonality: number
    metadata: number
    _all: number
  }


  export type MarketTrendAvgAggregateInputType = {
    trend?: true
    seasonality?: true
  }

  export type MarketTrendSumAggregateInputType = {
    trend?: true
    seasonality?: true
  }

  export type MarketTrendMinAggregateInputType = {
    id?: true
    timestamp?: true
    trend?: true
    seasonality?: true
  }

  export type MarketTrendMaxAggregateInputType = {
    id?: true
    timestamp?: true
    trend?: true
    seasonality?: true
  }

  export type MarketTrendCountAggregateInputType = {
    id?: true
    timestamp?: true
    trend?: true
    seasonality?: true
    metadata?: true
    _all?: true
  }

  export type MarketTrendAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketTrend to aggregate.
     */
    where?: MarketTrendWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketTrends to fetch.
     */
    orderBy?: MarketTrendOrderByWithRelationInput | MarketTrendOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MarketTrendWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketTrends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketTrends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MarketTrends
    **/
    _count?: true | MarketTrendCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MarketTrendAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MarketTrendSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarketTrendMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarketTrendMaxAggregateInputType
  }

  export type GetMarketTrendAggregateType<T extends MarketTrendAggregateArgs> = {
        [P in keyof T & keyof AggregateMarketTrend]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarketTrend[P]>
      : GetScalarType<T[P], AggregateMarketTrend[P]>
  }




  export type MarketTrendGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketTrendWhereInput
    orderBy?: MarketTrendOrderByWithAggregationInput | MarketTrendOrderByWithAggregationInput[]
    by: MarketTrendScalarFieldEnum[] | MarketTrendScalarFieldEnum
    having?: MarketTrendScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarketTrendCountAggregateInputType | true
    _avg?: MarketTrendAvgAggregateInputType
    _sum?: MarketTrendSumAggregateInputType
    _min?: MarketTrendMinAggregateInputType
    _max?: MarketTrendMaxAggregateInputType
  }

  export type MarketTrendGroupByOutputType = {
    id: string
    timestamp: Date
    trend: number
    seasonality: number | null
    metadata: JsonValue | null
    _count: MarketTrendCountAggregateOutputType | null
    _avg: MarketTrendAvgAggregateOutputType | null
    _sum: MarketTrendSumAggregateOutputType | null
    _min: MarketTrendMinAggregateOutputType | null
    _max: MarketTrendMaxAggregateOutputType | null
  }

  type GetMarketTrendGroupByPayload<T extends MarketTrendGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MarketTrendGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarketTrendGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarketTrendGroupByOutputType[P]>
            : GetScalarType<T[P], MarketTrendGroupByOutputType[P]>
        }
      >
    >


  export type MarketTrendSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    trend?: boolean
    seasonality?: boolean
    metadata?: boolean
  }, ExtArgs["result"]["marketTrend"]>

  export type MarketTrendSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    trend?: boolean
    seasonality?: boolean
    metadata?: boolean
  }, ExtArgs["result"]["marketTrend"]>

  export type MarketTrendSelectScalar = {
    id?: boolean
    timestamp?: boolean
    trend?: boolean
    seasonality?: boolean
    metadata?: boolean
  }


  export type $MarketTrendPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MarketTrend"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      timestamp: Date
      trend: number
      seasonality: number | null
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["marketTrend"]>
    composites: {}
  }

  type MarketTrendGetPayload<S extends boolean | null | undefined | MarketTrendDefaultArgs> = $Result.GetResult<Prisma.$MarketTrendPayload, S>

  type MarketTrendCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MarketTrendFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MarketTrendCountAggregateInputType | true
    }

  export interface MarketTrendDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MarketTrend'], meta: { name: 'MarketTrend' } }
    /**
     * Find zero or one MarketTrend that matches the filter.
     * @param {MarketTrendFindUniqueArgs} args - Arguments to find a MarketTrend
     * @example
     * // Get one MarketTrend
     * const marketTrend = await prisma.marketTrend.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MarketTrendFindUniqueArgs>(args: SelectSubset<T, MarketTrendFindUniqueArgs<ExtArgs>>): Prisma__MarketTrendClient<$Result.GetResult<Prisma.$MarketTrendPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MarketTrend that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MarketTrendFindUniqueOrThrowArgs} args - Arguments to find a MarketTrend
     * @example
     * // Get one MarketTrend
     * const marketTrend = await prisma.marketTrend.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MarketTrendFindUniqueOrThrowArgs>(args: SelectSubset<T, MarketTrendFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MarketTrendClient<$Result.GetResult<Prisma.$MarketTrendPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MarketTrend that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketTrendFindFirstArgs} args - Arguments to find a MarketTrend
     * @example
     * // Get one MarketTrend
     * const marketTrend = await prisma.marketTrend.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MarketTrendFindFirstArgs>(args?: SelectSubset<T, MarketTrendFindFirstArgs<ExtArgs>>): Prisma__MarketTrendClient<$Result.GetResult<Prisma.$MarketTrendPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MarketTrend that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketTrendFindFirstOrThrowArgs} args - Arguments to find a MarketTrend
     * @example
     * // Get one MarketTrend
     * const marketTrend = await prisma.marketTrend.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MarketTrendFindFirstOrThrowArgs>(args?: SelectSubset<T, MarketTrendFindFirstOrThrowArgs<ExtArgs>>): Prisma__MarketTrendClient<$Result.GetResult<Prisma.$MarketTrendPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MarketTrends that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketTrendFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MarketTrends
     * const marketTrends = await prisma.marketTrend.findMany()
     * 
     * // Get first 10 MarketTrends
     * const marketTrends = await prisma.marketTrend.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marketTrendWithIdOnly = await prisma.marketTrend.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MarketTrendFindManyArgs>(args?: SelectSubset<T, MarketTrendFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketTrendPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MarketTrend.
     * @param {MarketTrendCreateArgs} args - Arguments to create a MarketTrend.
     * @example
     * // Create one MarketTrend
     * const MarketTrend = await prisma.marketTrend.create({
     *   data: {
     *     // ... data to create a MarketTrend
     *   }
     * })
     * 
     */
    create<T extends MarketTrendCreateArgs>(args: SelectSubset<T, MarketTrendCreateArgs<ExtArgs>>): Prisma__MarketTrendClient<$Result.GetResult<Prisma.$MarketTrendPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MarketTrends.
     * @param {MarketTrendCreateManyArgs} args - Arguments to create many MarketTrends.
     * @example
     * // Create many MarketTrends
     * const marketTrend = await prisma.marketTrend.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MarketTrendCreateManyArgs>(args?: SelectSubset<T, MarketTrendCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MarketTrends and returns the data saved in the database.
     * @param {MarketTrendCreateManyAndReturnArgs} args - Arguments to create many MarketTrends.
     * @example
     * // Create many MarketTrends
     * const marketTrend = await prisma.marketTrend.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MarketTrends and only return the `id`
     * const marketTrendWithIdOnly = await prisma.marketTrend.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MarketTrendCreateManyAndReturnArgs>(args?: SelectSubset<T, MarketTrendCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketTrendPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MarketTrend.
     * @param {MarketTrendDeleteArgs} args - Arguments to delete one MarketTrend.
     * @example
     * // Delete one MarketTrend
     * const MarketTrend = await prisma.marketTrend.delete({
     *   where: {
     *     // ... filter to delete one MarketTrend
     *   }
     * })
     * 
     */
    delete<T extends MarketTrendDeleteArgs>(args: SelectSubset<T, MarketTrendDeleteArgs<ExtArgs>>): Prisma__MarketTrendClient<$Result.GetResult<Prisma.$MarketTrendPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MarketTrend.
     * @param {MarketTrendUpdateArgs} args - Arguments to update one MarketTrend.
     * @example
     * // Update one MarketTrend
     * const marketTrend = await prisma.marketTrend.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MarketTrendUpdateArgs>(args: SelectSubset<T, MarketTrendUpdateArgs<ExtArgs>>): Prisma__MarketTrendClient<$Result.GetResult<Prisma.$MarketTrendPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MarketTrends.
     * @param {MarketTrendDeleteManyArgs} args - Arguments to filter MarketTrends to delete.
     * @example
     * // Delete a few MarketTrends
     * const { count } = await prisma.marketTrend.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MarketTrendDeleteManyArgs>(args?: SelectSubset<T, MarketTrendDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketTrends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketTrendUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MarketTrends
     * const marketTrend = await prisma.marketTrend.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MarketTrendUpdateManyArgs>(args: SelectSubset<T, MarketTrendUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MarketTrend.
     * @param {MarketTrendUpsertArgs} args - Arguments to update or create a MarketTrend.
     * @example
     * // Update or create a MarketTrend
     * const marketTrend = await prisma.marketTrend.upsert({
     *   create: {
     *     // ... data to create a MarketTrend
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MarketTrend we want to update
     *   }
     * })
     */
    upsert<T extends MarketTrendUpsertArgs>(args: SelectSubset<T, MarketTrendUpsertArgs<ExtArgs>>): Prisma__MarketTrendClient<$Result.GetResult<Prisma.$MarketTrendPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MarketTrends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketTrendCountArgs} args - Arguments to filter MarketTrends to count.
     * @example
     * // Count the number of MarketTrends
     * const count = await prisma.marketTrend.count({
     *   where: {
     *     // ... the filter for the MarketTrends we want to count
     *   }
     * })
    **/
    count<T extends MarketTrendCountArgs>(
      args?: Subset<T, MarketTrendCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarketTrendCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MarketTrend.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketTrendAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarketTrendAggregateArgs>(args: Subset<T, MarketTrendAggregateArgs>): Prisma.PrismaPromise<GetMarketTrendAggregateType<T>>

    /**
     * Group by MarketTrend.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketTrendGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarketTrendGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarketTrendGroupByArgs['orderBy'] }
        : { orderBy?: MarketTrendGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarketTrendGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarketTrendGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MarketTrend model
   */
  readonly fields: MarketTrendFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MarketTrend.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MarketTrendClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MarketTrend model
   */ 
  interface MarketTrendFieldRefs {
    readonly id: FieldRef<"MarketTrend", 'String'>
    readonly timestamp: FieldRef<"MarketTrend", 'DateTime'>
    readonly trend: FieldRef<"MarketTrend", 'Float'>
    readonly seasonality: FieldRef<"MarketTrend", 'Float'>
    readonly metadata: FieldRef<"MarketTrend", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * MarketTrend findUnique
   */
  export type MarketTrendFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketTrend
     */
    select?: MarketTrendSelect<ExtArgs> | null
    /**
     * Filter, which MarketTrend to fetch.
     */
    where: MarketTrendWhereUniqueInput
  }

  /**
   * MarketTrend findUniqueOrThrow
   */
  export type MarketTrendFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketTrend
     */
    select?: MarketTrendSelect<ExtArgs> | null
    /**
     * Filter, which MarketTrend to fetch.
     */
    where: MarketTrendWhereUniqueInput
  }

  /**
   * MarketTrend findFirst
   */
  export type MarketTrendFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketTrend
     */
    select?: MarketTrendSelect<ExtArgs> | null
    /**
     * Filter, which MarketTrend to fetch.
     */
    where?: MarketTrendWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketTrends to fetch.
     */
    orderBy?: MarketTrendOrderByWithRelationInput | MarketTrendOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketTrends.
     */
    cursor?: MarketTrendWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketTrends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketTrends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketTrends.
     */
    distinct?: MarketTrendScalarFieldEnum | MarketTrendScalarFieldEnum[]
  }

  /**
   * MarketTrend findFirstOrThrow
   */
  export type MarketTrendFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketTrend
     */
    select?: MarketTrendSelect<ExtArgs> | null
    /**
     * Filter, which MarketTrend to fetch.
     */
    where?: MarketTrendWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketTrends to fetch.
     */
    orderBy?: MarketTrendOrderByWithRelationInput | MarketTrendOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketTrends.
     */
    cursor?: MarketTrendWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketTrends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketTrends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketTrends.
     */
    distinct?: MarketTrendScalarFieldEnum | MarketTrendScalarFieldEnum[]
  }

  /**
   * MarketTrend findMany
   */
  export type MarketTrendFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketTrend
     */
    select?: MarketTrendSelect<ExtArgs> | null
    /**
     * Filter, which MarketTrends to fetch.
     */
    where?: MarketTrendWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketTrends to fetch.
     */
    orderBy?: MarketTrendOrderByWithRelationInput | MarketTrendOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MarketTrends.
     */
    cursor?: MarketTrendWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketTrends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketTrends.
     */
    skip?: number
    distinct?: MarketTrendScalarFieldEnum | MarketTrendScalarFieldEnum[]
  }

  /**
   * MarketTrend create
   */
  export type MarketTrendCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketTrend
     */
    select?: MarketTrendSelect<ExtArgs> | null
    /**
     * The data needed to create a MarketTrend.
     */
    data: XOR<MarketTrendCreateInput, MarketTrendUncheckedCreateInput>
  }

  /**
   * MarketTrend createMany
   */
  export type MarketTrendCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MarketTrends.
     */
    data: MarketTrendCreateManyInput | MarketTrendCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MarketTrend createManyAndReturn
   */
  export type MarketTrendCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketTrend
     */
    select?: MarketTrendSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MarketTrends.
     */
    data: MarketTrendCreateManyInput | MarketTrendCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MarketTrend update
   */
  export type MarketTrendUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketTrend
     */
    select?: MarketTrendSelect<ExtArgs> | null
    /**
     * The data needed to update a MarketTrend.
     */
    data: XOR<MarketTrendUpdateInput, MarketTrendUncheckedUpdateInput>
    /**
     * Choose, which MarketTrend to update.
     */
    where: MarketTrendWhereUniqueInput
  }

  /**
   * MarketTrend updateMany
   */
  export type MarketTrendUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MarketTrends.
     */
    data: XOR<MarketTrendUpdateManyMutationInput, MarketTrendUncheckedUpdateManyInput>
    /**
     * Filter which MarketTrends to update
     */
    where?: MarketTrendWhereInput
  }

  /**
   * MarketTrend upsert
   */
  export type MarketTrendUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketTrend
     */
    select?: MarketTrendSelect<ExtArgs> | null
    /**
     * The filter to search for the MarketTrend to update in case it exists.
     */
    where: MarketTrendWhereUniqueInput
    /**
     * In case the MarketTrend found by the `where` argument doesn't exist, create a new MarketTrend with this data.
     */
    create: XOR<MarketTrendCreateInput, MarketTrendUncheckedCreateInput>
    /**
     * In case the MarketTrend was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarketTrendUpdateInput, MarketTrendUncheckedUpdateInput>
  }

  /**
   * MarketTrend delete
   */
  export type MarketTrendDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketTrend
     */
    select?: MarketTrendSelect<ExtArgs> | null
    /**
     * Filter which MarketTrend to delete.
     */
    where: MarketTrendWhereUniqueInput
  }

  /**
   * MarketTrend deleteMany
   */
  export type MarketTrendDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketTrends to delete
     */
    where?: MarketTrendWhereInput
  }

  /**
   * MarketTrend without action
   */
  export type MarketTrendDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketTrend
     */
    select?: MarketTrendSelect<ExtArgs> | null
  }


  /**
   * Model PredictionInterval
   */

  export type AggregatePredictionInterval = {
    _count: PredictionIntervalCountAggregateOutputType | null
    _avg: PredictionIntervalAvgAggregateOutputType | null
    _sum: PredictionIntervalSumAggregateOutputType | null
    _min: PredictionIntervalMinAggregateOutputType | null
    _max: PredictionIntervalMaxAggregateOutputType | null
  }

  export type PredictionIntervalAvgAggregateOutputType = {
    lowerBound: number | null
    upperBound: number | null
    confidence: number | null
  }

  export type PredictionIntervalSumAggregateOutputType = {
    lowerBound: number | null
    upperBound: number | null
    confidence: number | null
  }

  export type PredictionIntervalMinAggregateOutputType = {
    id: string | null
    timestamp: Date | null
    lowerBound: number | null
    upperBound: number | null
    confidence: number | null
  }

  export type PredictionIntervalMaxAggregateOutputType = {
    id: string | null
    timestamp: Date | null
    lowerBound: number | null
    upperBound: number | null
    confidence: number | null
  }

  export type PredictionIntervalCountAggregateOutputType = {
    id: number
    timestamp: number
    lowerBound: number
    upperBound: number
    confidence: number
    metadata: number
    _all: number
  }


  export type PredictionIntervalAvgAggregateInputType = {
    lowerBound?: true
    upperBound?: true
    confidence?: true
  }

  export type PredictionIntervalSumAggregateInputType = {
    lowerBound?: true
    upperBound?: true
    confidence?: true
  }

  export type PredictionIntervalMinAggregateInputType = {
    id?: true
    timestamp?: true
    lowerBound?: true
    upperBound?: true
    confidence?: true
  }

  export type PredictionIntervalMaxAggregateInputType = {
    id?: true
    timestamp?: true
    lowerBound?: true
    upperBound?: true
    confidence?: true
  }

  export type PredictionIntervalCountAggregateInputType = {
    id?: true
    timestamp?: true
    lowerBound?: true
    upperBound?: true
    confidence?: true
    metadata?: true
    _all?: true
  }

  export type PredictionIntervalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PredictionInterval to aggregate.
     */
    where?: PredictionIntervalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PredictionIntervals to fetch.
     */
    orderBy?: PredictionIntervalOrderByWithRelationInput | PredictionIntervalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PredictionIntervalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PredictionIntervals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PredictionIntervals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PredictionIntervals
    **/
    _count?: true | PredictionIntervalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PredictionIntervalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PredictionIntervalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PredictionIntervalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PredictionIntervalMaxAggregateInputType
  }

  export type GetPredictionIntervalAggregateType<T extends PredictionIntervalAggregateArgs> = {
        [P in keyof T & keyof AggregatePredictionInterval]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePredictionInterval[P]>
      : GetScalarType<T[P], AggregatePredictionInterval[P]>
  }




  export type PredictionIntervalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PredictionIntervalWhereInput
    orderBy?: PredictionIntervalOrderByWithAggregationInput | PredictionIntervalOrderByWithAggregationInput[]
    by: PredictionIntervalScalarFieldEnum[] | PredictionIntervalScalarFieldEnum
    having?: PredictionIntervalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PredictionIntervalCountAggregateInputType | true
    _avg?: PredictionIntervalAvgAggregateInputType
    _sum?: PredictionIntervalSumAggregateInputType
    _min?: PredictionIntervalMinAggregateInputType
    _max?: PredictionIntervalMaxAggregateInputType
  }

  export type PredictionIntervalGroupByOutputType = {
    id: string
    timestamp: Date
    lowerBound: number
    upperBound: number
    confidence: number
    metadata: JsonValue | null
    _count: PredictionIntervalCountAggregateOutputType | null
    _avg: PredictionIntervalAvgAggregateOutputType | null
    _sum: PredictionIntervalSumAggregateOutputType | null
    _min: PredictionIntervalMinAggregateOutputType | null
    _max: PredictionIntervalMaxAggregateOutputType | null
  }

  type GetPredictionIntervalGroupByPayload<T extends PredictionIntervalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PredictionIntervalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PredictionIntervalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PredictionIntervalGroupByOutputType[P]>
            : GetScalarType<T[P], PredictionIntervalGroupByOutputType[P]>
        }
      >
    >


  export type PredictionIntervalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    lowerBound?: boolean
    upperBound?: boolean
    confidence?: boolean
    metadata?: boolean
  }, ExtArgs["result"]["predictionInterval"]>

  export type PredictionIntervalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    lowerBound?: boolean
    upperBound?: boolean
    confidence?: boolean
    metadata?: boolean
  }, ExtArgs["result"]["predictionInterval"]>

  export type PredictionIntervalSelectScalar = {
    id?: boolean
    timestamp?: boolean
    lowerBound?: boolean
    upperBound?: boolean
    confidence?: boolean
    metadata?: boolean
  }


  export type $PredictionIntervalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PredictionInterval"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      timestamp: Date
      lowerBound: number
      upperBound: number
      confidence: number
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["predictionInterval"]>
    composites: {}
  }

  type PredictionIntervalGetPayload<S extends boolean | null | undefined | PredictionIntervalDefaultArgs> = $Result.GetResult<Prisma.$PredictionIntervalPayload, S>

  type PredictionIntervalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PredictionIntervalFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PredictionIntervalCountAggregateInputType | true
    }

  export interface PredictionIntervalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PredictionInterval'], meta: { name: 'PredictionInterval' } }
    /**
     * Find zero or one PredictionInterval that matches the filter.
     * @param {PredictionIntervalFindUniqueArgs} args - Arguments to find a PredictionInterval
     * @example
     * // Get one PredictionInterval
     * const predictionInterval = await prisma.predictionInterval.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PredictionIntervalFindUniqueArgs>(args: SelectSubset<T, PredictionIntervalFindUniqueArgs<ExtArgs>>): Prisma__PredictionIntervalClient<$Result.GetResult<Prisma.$PredictionIntervalPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PredictionInterval that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PredictionIntervalFindUniqueOrThrowArgs} args - Arguments to find a PredictionInterval
     * @example
     * // Get one PredictionInterval
     * const predictionInterval = await prisma.predictionInterval.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PredictionIntervalFindUniqueOrThrowArgs>(args: SelectSubset<T, PredictionIntervalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PredictionIntervalClient<$Result.GetResult<Prisma.$PredictionIntervalPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PredictionInterval that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PredictionIntervalFindFirstArgs} args - Arguments to find a PredictionInterval
     * @example
     * // Get one PredictionInterval
     * const predictionInterval = await prisma.predictionInterval.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PredictionIntervalFindFirstArgs>(args?: SelectSubset<T, PredictionIntervalFindFirstArgs<ExtArgs>>): Prisma__PredictionIntervalClient<$Result.GetResult<Prisma.$PredictionIntervalPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PredictionInterval that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PredictionIntervalFindFirstOrThrowArgs} args - Arguments to find a PredictionInterval
     * @example
     * // Get one PredictionInterval
     * const predictionInterval = await prisma.predictionInterval.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PredictionIntervalFindFirstOrThrowArgs>(args?: SelectSubset<T, PredictionIntervalFindFirstOrThrowArgs<ExtArgs>>): Prisma__PredictionIntervalClient<$Result.GetResult<Prisma.$PredictionIntervalPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PredictionIntervals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PredictionIntervalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PredictionIntervals
     * const predictionIntervals = await prisma.predictionInterval.findMany()
     * 
     * // Get first 10 PredictionIntervals
     * const predictionIntervals = await prisma.predictionInterval.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const predictionIntervalWithIdOnly = await prisma.predictionInterval.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PredictionIntervalFindManyArgs>(args?: SelectSubset<T, PredictionIntervalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PredictionIntervalPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PredictionInterval.
     * @param {PredictionIntervalCreateArgs} args - Arguments to create a PredictionInterval.
     * @example
     * // Create one PredictionInterval
     * const PredictionInterval = await prisma.predictionInterval.create({
     *   data: {
     *     // ... data to create a PredictionInterval
     *   }
     * })
     * 
     */
    create<T extends PredictionIntervalCreateArgs>(args: SelectSubset<T, PredictionIntervalCreateArgs<ExtArgs>>): Prisma__PredictionIntervalClient<$Result.GetResult<Prisma.$PredictionIntervalPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PredictionIntervals.
     * @param {PredictionIntervalCreateManyArgs} args - Arguments to create many PredictionIntervals.
     * @example
     * // Create many PredictionIntervals
     * const predictionInterval = await prisma.predictionInterval.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PredictionIntervalCreateManyArgs>(args?: SelectSubset<T, PredictionIntervalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PredictionIntervals and returns the data saved in the database.
     * @param {PredictionIntervalCreateManyAndReturnArgs} args - Arguments to create many PredictionIntervals.
     * @example
     * // Create many PredictionIntervals
     * const predictionInterval = await prisma.predictionInterval.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PredictionIntervals and only return the `id`
     * const predictionIntervalWithIdOnly = await prisma.predictionInterval.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PredictionIntervalCreateManyAndReturnArgs>(args?: SelectSubset<T, PredictionIntervalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PredictionIntervalPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PredictionInterval.
     * @param {PredictionIntervalDeleteArgs} args - Arguments to delete one PredictionInterval.
     * @example
     * // Delete one PredictionInterval
     * const PredictionInterval = await prisma.predictionInterval.delete({
     *   where: {
     *     // ... filter to delete one PredictionInterval
     *   }
     * })
     * 
     */
    delete<T extends PredictionIntervalDeleteArgs>(args: SelectSubset<T, PredictionIntervalDeleteArgs<ExtArgs>>): Prisma__PredictionIntervalClient<$Result.GetResult<Prisma.$PredictionIntervalPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PredictionInterval.
     * @param {PredictionIntervalUpdateArgs} args - Arguments to update one PredictionInterval.
     * @example
     * // Update one PredictionInterval
     * const predictionInterval = await prisma.predictionInterval.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PredictionIntervalUpdateArgs>(args: SelectSubset<T, PredictionIntervalUpdateArgs<ExtArgs>>): Prisma__PredictionIntervalClient<$Result.GetResult<Prisma.$PredictionIntervalPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PredictionIntervals.
     * @param {PredictionIntervalDeleteManyArgs} args - Arguments to filter PredictionIntervals to delete.
     * @example
     * // Delete a few PredictionIntervals
     * const { count } = await prisma.predictionInterval.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PredictionIntervalDeleteManyArgs>(args?: SelectSubset<T, PredictionIntervalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PredictionIntervals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PredictionIntervalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PredictionIntervals
     * const predictionInterval = await prisma.predictionInterval.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PredictionIntervalUpdateManyArgs>(args: SelectSubset<T, PredictionIntervalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PredictionInterval.
     * @param {PredictionIntervalUpsertArgs} args - Arguments to update or create a PredictionInterval.
     * @example
     * // Update or create a PredictionInterval
     * const predictionInterval = await prisma.predictionInterval.upsert({
     *   create: {
     *     // ... data to create a PredictionInterval
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PredictionInterval we want to update
     *   }
     * })
     */
    upsert<T extends PredictionIntervalUpsertArgs>(args: SelectSubset<T, PredictionIntervalUpsertArgs<ExtArgs>>): Prisma__PredictionIntervalClient<$Result.GetResult<Prisma.$PredictionIntervalPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PredictionIntervals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PredictionIntervalCountArgs} args - Arguments to filter PredictionIntervals to count.
     * @example
     * // Count the number of PredictionIntervals
     * const count = await prisma.predictionInterval.count({
     *   where: {
     *     // ... the filter for the PredictionIntervals we want to count
     *   }
     * })
    **/
    count<T extends PredictionIntervalCountArgs>(
      args?: Subset<T, PredictionIntervalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PredictionIntervalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PredictionInterval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PredictionIntervalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PredictionIntervalAggregateArgs>(args: Subset<T, PredictionIntervalAggregateArgs>): Prisma.PrismaPromise<GetPredictionIntervalAggregateType<T>>

    /**
     * Group by PredictionInterval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PredictionIntervalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PredictionIntervalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PredictionIntervalGroupByArgs['orderBy'] }
        : { orderBy?: PredictionIntervalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PredictionIntervalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPredictionIntervalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PredictionInterval model
   */
  readonly fields: PredictionIntervalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PredictionInterval.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PredictionIntervalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PredictionInterval model
   */ 
  interface PredictionIntervalFieldRefs {
    readonly id: FieldRef<"PredictionInterval", 'String'>
    readonly timestamp: FieldRef<"PredictionInterval", 'DateTime'>
    readonly lowerBound: FieldRef<"PredictionInterval", 'Float'>
    readonly upperBound: FieldRef<"PredictionInterval", 'Float'>
    readonly confidence: FieldRef<"PredictionInterval", 'Float'>
    readonly metadata: FieldRef<"PredictionInterval", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * PredictionInterval findUnique
   */
  export type PredictionIntervalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PredictionInterval
     */
    select?: PredictionIntervalSelect<ExtArgs> | null
    /**
     * Filter, which PredictionInterval to fetch.
     */
    where: PredictionIntervalWhereUniqueInput
  }

  /**
   * PredictionInterval findUniqueOrThrow
   */
  export type PredictionIntervalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PredictionInterval
     */
    select?: PredictionIntervalSelect<ExtArgs> | null
    /**
     * Filter, which PredictionInterval to fetch.
     */
    where: PredictionIntervalWhereUniqueInput
  }

  /**
   * PredictionInterval findFirst
   */
  export type PredictionIntervalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PredictionInterval
     */
    select?: PredictionIntervalSelect<ExtArgs> | null
    /**
     * Filter, which PredictionInterval to fetch.
     */
    where?: PredictionIntervalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PredictionIntervals to fetch.
     */
    orderBy?: PredictionIntervalOrderByWithRelationInput | PredictionIntervalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PredictionIntervals.
     */
    cursor?: PredictionIntervalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PredictionIntervals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PredictionIntervals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PredictionIntervals.
     */
    distinct?: PredictionIntervalScalarFieldEnum | PredictionIntervalScalarFieldEnum[]
  }

  /**
   * PredictionInterval findFirstOrThrow
   */
  export type PredictionIntervalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PredictionInterval
     */
    select?: PredictionIntervalSelect<ExtArgs> | null
    /**
     * Filter, which PredictionInterval to fetch.
     */
    where?: PredictionIntervalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PredictionIntervals to fetch.
     */
    orderBy?: PredictionIntervalOrderByWithRelationInput | PredictionIntervalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PredictionIntervals.
     */
    cursor?: PredictionIntervalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PredictionIntervals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PredictionIntervals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PredictionIntervals.
     */
    distinct?: PredictionIntervalScalarFieldEnum | PredictionIntervalScalarFieldEnum[]
  }

  /**
   * PredictionInterval findMany
   */
  export type PredictionIntervalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PredictionInterval
     */
    select?: PredictionIntervalSelect<ExtArgs> | null
    /**
     * Filter, which PredictionIntervals to fetch.
     */
    where?: PredictionIntervalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PredictionIntervals to fetch.
     */
    orderBy?: PredictionIntervalOrderByWithRelationInput | PredictionIntervalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PredictionIntervals.
     */
    cursor?: PredictionIntervalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PredictionIntervals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PredictionIntervals.
     */
    skip?: number
    distinct?: PredictionIntervalScalarFieldEnum | PredictionIntervalScalarFieldEnum[]
  }

  /**
   * PredictionInterval create
   */
  export type PredictionIntervalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PredictionInterval
     */
    select?: PredictionIntervalSelect<ExtArgs> | null
    /**
     * The data needed to create a PredictionInterval.
     */
    data: XOR<PredictionIntervalCreateInput, PredictionIntervalUncheckedCreateInput>
  }

  /**
   * PredictionInterval createMany
   */
  export type PredictionIntervalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PredictionIntervals.
     */
    data: PredictionIntervalCreateManyInput | PredictionIntervalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PredictionInterval createManyAndReturn
   */
  export type PredictionIntervalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PredictionInterval
     */
    select?: PredictionIntervalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PredictionIntervals.
     */
    data: PredictionIntervalCreateManyInput | PredictionIntervalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PredictionInterval update
   */
  export type PredictionIntervalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PredictionInterval
     */
    select?: PredictionIntervalSelect<ExtArgs> | null
    /**
     * The data needed to update a PredictionInterval.
     */
    data: XOR<PredictionIntervalUpdateInput, PredictionIntervalUncheckedUpdateInput>
    /**
     * Choose, which PredictionInterval to update.
     */
    where: PredictionIntervalWhereUniqueInput
  }

  /**
   * PredictionInterval updateMany
   */
  export type PredictionIntervalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PredictionIntervals.
     */
    data: XOR<PredictionIntervalUpdateManyMutationInput, PredictionIntervalUncheckedUpdateManyInput>
    /**
     * Filter which PredictionIntervals to update
     */
    where?: PredictionIntervalWhereInput
  }

  /**
   * PredictionInterval upsert
   */
  export type PredictionIntervalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PredictionInterval
     */
    select?: PredictionIntervalSelect<ExtArgs> | null
    /**
     * The filter to search for the PredictionInterval to update in case it exists.
     */
    where: PredictionIntervalWhereUniqueInput
    /**
     * In case the PredictionInterval found by the `where` argument doesn't exist, create a new PredictionInterval with this data.
     */
    create: XOR<PredictionIntervalCreateInput, PredictionIntervalUncheckedCreateInput>
    /**
     * In case the PredictionInterval was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PredictionIntervalUpdateInput, PredictionIntervalUncheckedUpdateInput>
  }

  /**
   * PredictionInterval delete
   */
  export type PredictionIntervalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PredictionInterval
     */
    select?: PredictionIntervalSelect<ExtArgs> | null
    /**
     * Filter which PredictionInterval to delete.
     */
    where: PredictionIntervalWhereUniqueInput
  }

  /**
   * PredictionInterval deleteMany
   */
  export type PredictionIntervalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PredictionIntervals to delete
     */
    where?: PredictionIntervalWhereInput
  }

  /**
   * PredictionInterval without action
   */
  export type PredictionIntervalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PredictionInterval
     */
    select?: PredictionIntervalSelect<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    organizationId: string | null
    type: string | null
    message: string | null
    read: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    organizationId: string | null
    type: string | null
    message: string | null
    read: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    organizationId: number
    type: number
    message: number
    read: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    organizationId?: true
    type?: true
    message?: true
    read?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    organizationId?: true
    type?: true
    message?: true
    read?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    organizationId?: true
    type?: true
    message?: true
    read?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    organizationId: string
    type: string
    message: string
    read: boolean
    createdAt: Date
    updatedAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    organizationId?: boolean
    type?: boolean
    message?: boolean
    read?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    organizationId?: boolean
    type?: boolean
    message?: boolean
    read?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    organizationId?: boolean
    type?: boolean
    message?: boolean
    read?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      organization: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      organizationId: string
      type: string
      message: string
      read: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly organizationId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly updatedAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model ApiKey
   */

  export type AggregateApiKey = {
    _count: ApiKeyCountAggregateOutputType | null
    _min: ApiKeyMinAggregateOutputType | null
    _max: ApiKeyMaxAggregateOutputType | null
  }

  export type ApiKeyMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    name: string | null
    key: string | null
    lastUsed: Date | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApiKeyMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    name: string | null
    key: string | null
    lastUsed: Date | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApiKeyCountAggregateOutputType = {
    id: number
    organizationId: number
    name: number
    key: number
    lastUsed: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ApiKeyMinAggregateInputType = {
    id?: true
    organizationId?: true
    name?: true
    key?: true
    lastUsed?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApiKeyMaxAggregateInputType = {
    id?: true
    organizationId?: true
    name?: true
    key?: true
    lastUsed?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApiKeyCountAggregateInputType = {
    id?: true
    organizationId?: true
    name?: true
    key?: true
    lastUsed?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ApiKeyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKey to aggregate.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApiKeys
    **/
    _count?: true | ApiKeyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApiKeyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApiKeyMaxAggregateInputType
  }

  export type GetApiKeyAggregateType<T extends ApiKeyAggregateArgs> = {
        [P in keyof T & keyof AggregateApiKey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiKey[P]>
      : GetScalarType<T[P], AggregateApiKey[P]>
  }




  export type ApiKeyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeyWhereInput
    orderBy?: ApiKeyOrderByWithAggregationInput | ApiKeyOrderByWithAggregationInput[]
    by: ApiKeyScalarFieldEnum[] | ApiKeyScalarFieldEnum
    having?: ApiKeyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApiKeyCountAggregateInputType | true
    _min?: ApiKeyMinAggregateInputType
    _max?: ApiKeyMaxAggregateInputType
  }

  export type ApiKeyGroupByOutputType = {
    id: string
    organizationId: string
    name: string
    key: string
    lastUsed: Date | null
    expiresAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ApiKeyCountAggregateOutputType | null
    _min: ApiKeyMinAggregateOutputType | null
    _max: ApiKeyMaxAggregateOutputType | null
  }

  type GetApiKeyGroupByPayload<T extends ApiKeyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiKeyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApiKeyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApiKeyGroupByOutputType[P]>
            : GetScalarType<T[P], ApiKeyGroupByOutputType[P]>
        }
      >
    >


  export type ApiKeySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    name?: boolean
    key?: boolean
    lastUsed?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKey"]>

  export type ApiKeySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    name?: boolean
    key?: boolean
    lastUsed?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKey"]>

  export type ApiKeySelectScalar = {
    id?: boolean
    organizationId?: boolean
    name?: boolean
    key?: boolean
    lastUsed?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ApiKeyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type ApiKeyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $ApiKeyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApiKey"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string
      name: string
      key: string
      lastUsed: Date | null
      expiresAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["apiKey"]>
    composites: {}
  }

  type ApiKeyGetPayload<S extends boolean | null | undefined | ApiKeyDefaultArgs> = $Result.GetResult<Prisma.$ApiKeyPayload, S>

  type ApiKeyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ApiKeyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ApiKeyCountAggregateInputType | true
    }

  export interface ApiKeyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiKey'], meta: { name: 'ApiKey' } }
    /**
     * Find zero or one ApiKey that matches the filter.
     * @param {ApiKeyFindUniqueArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApiKeyFindUniqueArgs>(args: SelectSubset<T, ApiKeyFindUniqueArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ApiKey that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ApiKeyFindUniqueOrThrowArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApiKeyFindUniqueOrThrowArgs>(args: SelectSubset<T, ApiKeyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ApiKey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindFirstArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApiKeyFindFirstArgs>(args?: SelectSubset<T, ApiKeyFindFirstArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ApiKey that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindFirstOrThrowArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApiKeyFindFirstOrThrowArgs>(args?: SelectSubset<T, ApiKeyFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ApiKeys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiKeys
     * const apiKeys = await prisma.apiKey.findMany()
     * 
     * // Get first 10 ApiKeys
     * const apiKeys = await prisma.apiKey.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApiKeyFindManyArgs>(args?: SelectSubset<T, ApiKeyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ApiKey.
     * @param {ApiKeyCreateArgs} args - Arguments to create a ApiKey.
     * @example
     * // Create one ApiKey
     * const ApiKey = await prisma.apiKey.create({
     *   data: {
     *     // ... data to create a ApiKey
     *   }
     * })
     * 
     */
    create<T extends ApiKeyCreateArgs>(args: SelectSubset<T, ApiKeyCreateArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ApiKeys.
     * @param {ApiKeyCreateManyArgs} args - Arguments to create many ApiKeys.
     * @example
     * // Create many ApiKeys
     * const apiKey = await prisma.apiKey.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApiKeyCreateManyArgs>(args?: SelectSubset<T, ApiKeyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApiKeys and returns the data saved in the database.
     * @param {ApiKeyCreateManyAndReturnArgs} args - Arguments to create many ApiKeys.
     * @example
     * // Create many ApiKeys
     * const apiKey = await prisma.apiKey.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApiKeys and only return the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApiKeyCreateManyAndReturnArgs>(args?: SelectSubset<T, ApiKeyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ApiKey.
     * @param {ApiKeyDeleteArgs} args - Arguments to delete one ApiKey.
     * @example
     * // Delete one ApiKey
     * const ApiKey = await prisma.apiKey.delete({
     *   where: {
     *     // ... filter to delete one ApiKey
     *   }
     * })
     * 
     */
    delete<T extends ApiKeyDeleteArgs>(args: SelectSubset<T, ApiKeyDeleteArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ApiKey.
     * @param {ApiKeyUpdateArgs} args - Arguments to update one ApiKey.
     * @example
     * // Update one ApiKey
     * const apiKey = await prisma.apiKey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApiKeyUpdateArgs>(args: SelectSubset<T, ApiKeyUpdateArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ApiKeys.
     * @param {ApiKeyDeleteManyArgs} args - Arguments to filter ApiKeys to delete.
     * @example
     * // Delete a few ApiKeys
     * const { count } = await prisma.apiKey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApiKeyDeleteManyArgs>(args?: SelectSubset<T, ApiKeyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiKeys
     * const apiKey = await prisma.apiKey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApiKeyUpdateManyArgs>(args: SelectSubset<T, ApiKeyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ApiKey.
     * @param {ApiKeyUpsertArgs} args - Arguments to update or create a ApiKey.
     * @example
     * // Update or create a ApiKey
     * const apiKey = await prisma.apiKey.upsert({
     *   create: {
     *     // ... data to create a ApiKey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiKey we want to update
     *   }
     * })
     */
    upsert<T extends ApiKeyUpsertArgs>(args: SelectSubset<T, ApiKeyUpsertArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyCountArgs} args - Arguments to filter ApiKeys to count.
     * @example
     * // Count the number of ApiKeys
     * const count = await prisma.apiKey.count({
     *   where: {
     *     // ... the filter for the ApiKeys we want to count
     *   }
     * })
    **/
    count<T extends ApiKeyCountArgs>(
      args?: Subset<T, ApiKeyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiKeyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApiKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApiKeyAggregateArgs>(args: Subset<T, ApiKeyAggregateArgs>): Prisma.PrismaPromise<GetApiKeyAggregateType<T>>

    /**
     * Group by ApiKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApiKeyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiKeyGroupByArgs['orderBy'] }
        : { orderBy?: ApiKeyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApiKeyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiKeyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApiKey model
   */
  readonly fields: ApiKeyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiKey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiKeyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApiKey model
   */ 
  interface ApiKeyFieldRefs {
    readonly id: FieldRef<"ApiKey", 'String'>
    readonly organizationId: FieldRef<"ApiKey", 'String'>
    readonly name: FieldRef<"ApiKey", 'String'>
    readonly key: FieldRef<"ApiKey", 'String'>
    readonly lastUsed: FieldRef<"ApiKey", 'DateTime'>
    readonly expiresAt: FieldRef<"ApiKey", 'DateTime'>
    readonly createdAt: FieldRef<"ApiKey", 'DateTime'>
    readonly updatedAt: FieldRef<"ApiKey", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApiKey findUnique
   */
  export type ApiKeyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey findUniqueOrThrow
   */
  export type ApiKeyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey findFirst
   */
  export type ApiKeyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeys.
     */
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey findFirstOrThrow
   */
  export type ApiKeyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeys.
     */
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey findMany
   */
  export type ApiKeyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKeys to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey create
   */
  export type ApiKeyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The data needed to create a ApiKey.
     */
    data: XOR<ApiKeyCreateInput, ApiKeyUncheckedCreateInput>
  }

  /**
   * ApiKey createMany
   */
  export type ApiKeyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApiKeys.
     */
    data: ApiKeyCreateManyInput | ApiKeyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiKey createManyAndReturn
   */
  export type ApiKeyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ApiKeys.
     */
    data: ApiKeyCreateManyInput | ApiKeyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApiKey update
   */
  export type ApiKeyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The data needed to update a ApiKey.
     */
    data: XOR<ApiKeyUpdateInput, ApiKeyUncheckedUpdateInput>
    /**
     * Choose, which ApiKey to update.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey updateMany
   */
  export type ApiKeyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApiKeys.
     */
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyInput>
    /**
     * Filter which ApiKeys to update
     */
    where?: ApiKeyWhereInput
  }

  /**
   * ApiKey upsert
   */
  export type ApiKeyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The filter to search for the ApiKey to update in case it exists.
     */
    where: ApiKeyWhereUniqueInput
    /**
     * In case the ApiKey found by the `where` argument doesn't exist, create a new ApiKey with this data.
     */
    create: XOR<ApiKeyCreateInput, ApiKeyUncheckedCreateInput>
    /**
     * In case the ApiKey was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiKeyUpdateInput, ApiKeyUncheckedUpdateInput>
  }

  /**
   * ApiKey delete
   */
  export type ApiKeyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter which ApiKey to delete.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey deleteMany
   */
  export type ApiKeyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKeys to delete
     */
    where?: ApiKeyWhereInput
  }

  /**
   * ApiKey without action
   */
  export type ApiKeyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
  }


  /**
   * Model TaxCalculation
   */

  export type AggregateTaxCalculation = {
    _count: TaxCalculationCountAggregateOutputType | null
    _avg: TaxCalculationAvgAggregateOutputType | null
    _sum: TaxCalculationSumAggregateOutputType | null
    _min: TaxCalculationMinAggregateOutputType | null
    _max: TaxCalculationMaxAggregateOutputType | null
  }

  export type TaxCalculationAvgAggregateOutputType = {
    amount: number | null
    taxRate: number | null
    taxAmount: number | null
  }

  export type TaxCalculationSumAggregateOutputType = {
    amount: number | null
    taxRate: number | null
    taxAmount: number | null
  }

  export type TaxCalculationMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    amount: number | null
    taxRate: number | null
    taxAmount: number | null
    country: string | null
    state: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaxCalculationMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    amount: number | null
    taxRate: number | null
    taxAmount: number | null
    country: string | null
    state: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaxCalculationCountAggregateOutputType = {
    id: number
    customerId: number
    amount: number
    taxRate: number
    taxAmount: number
    country: number
    state: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TaxCalculationAvgAggregateInputType = {
    amount?: true
    taxRate?: true
    taxAmount?: true
  }

  export type TaxCalculationSumAggregateInputType = {
    amount?: true
    taxRate?: true
    taxAmount?: true
  }

  export type TaxCalculationMinAggregateInputType = {
    id?: true
    customerId?: true
    amount?: true
    taxRate?: true
    taxAmount?: true
    country?: true
    state?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaxCalculationMaxAggregateInputType = {
    id?: true
    customerId?: true
    amount?: true
    taxRate?: true
    taxAmount?: true
    country?: true
    state?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaxCalculationCountAggregateInputType = {
    id?: true
    customerId?: true
    amount?: true
    taxRate?: true
    taxAmount?: true
    country?: true
    state?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TaxCalculationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaxCalculation to aggregate.
     */
    where?: TaxCalculationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxCalculations to fetch.
     */
    orderBy?: TaxCalculationOrderByWithRelationInput | TaxCalculationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaxCalculationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxCalculations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxCalculations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaxCalculations
    **/
    _count?: true | TaxCalculationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaxCalculationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaxCalculationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaxCalculationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaxCalculationMaxAggregateInputType
  }

  export type GetTaxCalculationAggregateType<T extends TaxCalculationAggregateArgs> = {
        [P in keyof T & keyof AggregateTaxCalculation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaxCalculation[P]>
      : GetScalarType<T[P], AggregateTaxCalculation[P]>
  }




  export type TaxCalculationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaxCalculationWhereInput
    orderBy?: TaxCalculationOrderByWithAggregationInput | TaxCalculationOrderByWithAggregationInput[]
    by: TaxCalculationScalarFieldEnum[] | TaxCalculationScalarFieldEnum
    having?: TaxCalculationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaxCalculationCountAggregateInputType | true
    _avg?: TaxCalculationAvgAggregateInputType
    _sum?: TaxCalculationSumAggregateInputType
    _min?: TaxCalculationMinAggregateInputType
    _max?: TaxCalculationMaxAggregateInputType
  }

  export type TaxCalculationGroupByOutputType = {
    id: string
    customerId: string
    amount: number
    taxRate: number
    taxAmount: number
    country: string
    state: string | null
    createdAt: Date
    updatedAt: Date
    _count: TaxCalculationCountAggregateOutputType | null
    _avg: TaxCalculationAvgAggregateOutputType | null
    _sum: TaxCalculationSumAggregateOutputType | null
    _min: TaxCalculationMinAggregateOutputType | null
    _max: TaxCalculationMaxAggregateOutputType | null
  }

  type GetTaxCalculationGroupByPayload<T extends TaxCalculationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaxCalculationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaxCalculationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaxCalculationGroupByOutputType[P]>
            : GetScalarType<T[P], TaxCalculationGroupByOutputType[P]>
        }
      >
    >


  export type TaxCalculationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    amount?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    country?: boolean
    state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taxCalculation"]>

  export type TaxCalculationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    amount?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    country?: boolean
    state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taxCalculation"]>

  export type TaxCalculationSelectScalar = {
    id?: boolean
    customerId?: boolean
    amount?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    country?: boolean
    state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TaxCalculationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type TaxCalculationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $TaxCalculationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaxCalculation"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string
      amount: number
      taxRate: number
      taxAmount: number
      country: string
      state: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["taxCalculation"]>
    composites: {}
  }

  type TaxCalculationGetPayload<S extends boolean | null | undefined | TaxCalculationDefaultArgs> = $Result.GetResult<Prisma.$TaxCalculationPayload, S>

  type TaxCalculationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TaxCalculationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TaxCalculationCountAggregateInputType | true
    }

  export interface TaxCalculationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaxCalculation'], meta: { name: 'TaxCalculation' } }
    /**
     * Find zero or one TaxCalculation that matches the filter.
     * @param {TaxCalculationFindUniqueArgs} args - Arguments to find a TaxCalculation
     * @example
     * // Get one TaxCalculation
     * const taxCalculation = await prisma.taxCalculation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaxCalculationFindUniqueArgs>(args: SelectSubset<T, TaxCalculationFindUniqueArgs<ExtArgs>>): Prisma__TaxCalculationClient<$Result.GetResult<Prisma.$TaxCalculationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TaxCalculation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TaxCalculationFindUniqueOrThrowArgs} args - Arguments to find a TaxCalculation
     * @example
     * // Get one TaxCalculation
     * const taxCalculation = await prisma.taxCalculation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaxCalculationFindUniqueOrThrowArgs>(args: SelectSubset<T, TaxCalculationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaxCalculationClient<$Result.GetResult<Prisma.$TaxCalculationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TaxCalculation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxCalculationFindFirstArgs} args - Arguments to find a TaxCalculation
     * @example
     * // Get one TaxCalculation
     * const taxCalculation = await prisma.taxCalculation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaxCalculationFindFirstArgs>(args?: SelectSubset<T, TaxCalculationFindFirstArgs<ExtArgs>>): Prisma__TaxCalculationClient<$Result.GetResult<Prisma.$TaxCalculationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TaxCalculation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxCalculationFindFirstOrThrowArgs} args - Arguments to find a TaxCalculation
     * @example
     * // Get one TaxCalculation
     * const taxCalculation = await prisma.taxCalculation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaxCalculationFindFirstOrThrowArgs>(args?: SelectSubset<T, TaxCalculationFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaxCalculationClient<$Result.GetResult<Prisma.$TaxCalculationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TaxCalculations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxCalculationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaxCalculations
     * const taxCalculations = await prisma.taxCalculation.findMany()
     * 
     * // Get first 10 TaxCalculations
     * const taxCalculations = await prisma.taxCalculation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taxCalculationWithIdOnly = await prisma.taxCalculation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaxCalculationFindManyArgs>(args?: SelectSubset<T, TaxCalculationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxCalculationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TaxCalculation.
     * @param {TaxCalculationCreateArgs} args - Arguments to create a TaxCalculation.
     * @example
     * // Create one TaxCalculation
     * const TaxCalculation = await prisma.taxCalculation.create({
     *   data: {
     *     // ... data to create a TaxCalculation
     *   }
     * })
     * 
     */
    create<T extends TaxCalculationCreateArgs>(args: SelectSubset<T, TaxCalculationCreateArgs<ExtArgs>>): Prisma__TaxCalculationClient<$Result.GetResult<Prisma.$TaxCalculationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TaxCalculations.
     * @param {TaxCalculationCreateManyArgs} args - Arguments to create many TaxCalculations.
     * @example
     * // Create many TaxCalculations
     * const taxCalculation = await prisma.taxCalculation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaxCalculationCreateManyArgs>(args?: SelectSubset<T, TaxCalculationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaxCalculations and returns the data saved in the database.
     * @param {TaxCalculationCreateManyAndReturnArgs} args - Arguments to create many TaxCalculations.
     * @example
     * // Create many TaxCalculations
     * const taxCalculation = await prisma.taxCalculation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaxCalculations and only return the `id`
     * const taxCalculationWithIdOnly = await prisma.taxCalculation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaxCalculationCreateManyAndReturnArgs>(args?: SelectSubset<T, TaxCalculationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxCalculationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TaxCalculation.
     * @param {TaxCalculationDeleteArgs} args - Arguments to delete one TaxCalculation.
     * @example
     * // Delete one TaxCalculation
     * const TaxCalculation = await prisma.taxCalculation.delete({
     *   where: {
     *     // ... filter to delete one TaxCalculation
     *   }
     * })
     * 
     */
    delete<T extends TaxCalculationDeleteArgs>(args: SelectSubset<T, TaxCalculationDeleteArgs<ExtArgs>>): Prisma__TaxCalculationClient<$Result.GetResult<Prisma.$TaxCalculationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TaxCalculation.
     * @param {TaxCalculationUpdateArgs} args - Arguments to update one TaxCalculation.
     * @example
     * // Update one TaxCalculation
     * const taxCalculation = await prisma.taxCalculation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaxCalculationUpdateArgs>(args: SelectSubset<T, TaxCalculationUpdateArgs<ExtArgs>>): Prisma__TaxCalculationClient<$Result.GetResult<Prisma.$TaxCalculationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TaxCalculations.
     * @param {TaxCalculationDeleteManyArgs} args - Arguments to filter TaxCalculations to delete.
     * @example
     * // Delete a few TaxCalculations
     * const { count } = await prisma.taxCalculation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaxCalculationDeleteManyArgs>(args?: SelectSubset<T, TaxCalculationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaxCalculations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxCalculationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaxCalculations
     * const taxCalculation = await prisma.taxCalculation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaxCalculationUpdateManyArgs>(args: SelectSubset<T, TaxCalculationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TaxCalculation.
     * @param {TaxCalculationUpsertArgs} args - Arguments to update or create a TaxCalculation.
     * @example
     * // Update or create a TaxCalculation
     * const taxCalculation = await prisma.taxCalculation.upsert({
     *   create: {
     *     // ... data to create a TaxCalculation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaxCalculation we want to update
     *   }
     * })
     */
    upsert<T extends TaxCalculationUpsertArgs>(args: SelectSubset<T, TaxCalculationUpsertArgs<ExtArgs>>): Prisma__TaxCalculationClient<$Result.GetResult<Prisma.$TaxCalculationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TaxCalculations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxCalculationCountArgs} args - Arguments to filter TaxCalculations to count.
     * @example
     * // Count the number of TaxCalculations
     * const count = await prisma.taxCalculation.count({
     *   where: {
     *     // ... the filter for the TaxCalculations we want to count
     *   }
     * })
    **/
    count<T extends TaxCalculationCountArgs>(
      args?: Subset<T, TaxCalculationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaxCalculationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaxCalculation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxCalculationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaxCalculationAggregateArgs>(args: Subset<T, TaxCalculationAggregateArgs>): Prisma.PrismaPromise<GetTaxCalculationAggregateType<T>>

    /**
     * Group by TaxCalculation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxCalculationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaxCalculationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaxCalculationGroupByArgs['orderBy'] }
        : { orderBy?: TaxCalculationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaxCalculationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaxCalculationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaxCalculation model
   */
  readonly fields: TaxCalculationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaxCalculation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaxCalculationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaxCalculation model
   */ 
  interface TaxCalculationFieldRefs {
    readonly id: FieldRef<"TaxCalculation", 'String'>
    readonly customerId: FieldRef<"TaxCalculation", 'String'>
    readonly amount: FieldRef<"TaxCalculation", 'Float'>
    readonly taxRate: FieldRef<"TaxCalculation", 'Float'>
    readonly taxAmount: FieldRef<"TaxCalculation", 'Float'>
    readonly country: FieldRef<"TaxCalculation", 'String'>
    readonly state: FieldRef<"TaxCalculation", 'String'>
    readonly createdAt: FieldRef<"TaxCalculation", 'DateTime'>
    readonly updatedAt: FieldRef<"TaxCalculation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaxCalculation findUnique
   */
  export type TaxCalculationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxCalculation
     */
    select?: TaxCalculationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxCalculationInclude<ExtArgs> | null
    /**
     * Filter, which TaxCalculation to fetch.
     */
    where: TaxCalculationWhereUniqueInput
  }

  /**
   * TaxCalculation findUniqueOrThrow
   */
  export type TaxCalculationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxCalculation
     */
    select?: TaxCalculationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxCalculationInclude<ExtArgs> | null
    /**
     * Filter, which TaxCalculation to fetch.
     */
    where: TaxCalculationWhereUniqueInput
  }

  /**
   * TaxCalculation findFirst
   */
  export type TaxCalculationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxCalculation
     */
    select?: TaxCalculationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxCalculationInclude<ExtArgs> | null
    /**
     * Filter, which TaxCalculation to fetch.
     */
    where?: TaxCalculationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxCalculations to fetch.
     */
    orderBy?: TaxCalculationOrderByWithRelationInput | TaxCalculationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaxCalculations.
     */
    cursor?: TaxCalculationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxCalculations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxCalculations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaxCalculations.
     */
    distinct?: TaxCalculationScalarFieldEnum | TaxCalculationScalarFieldEnum[]
  }

  /**
   * TaxCalculation findFirstOrThrow
   */
  export type TaxCalculationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxCalculation
     */
    select?: TaxCalculationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxCalculationInclude<ExtArgs> | null
    /**
     * Filter, which TaxCalculation to fetch.
     */
    where?: TaxCalculationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxCalculations to fetch.
     */
    orderBy?: TaxCalculationOrderByWithRelationInput | TaxCalculationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaxCalculations.
     */
    cursor?: TaxCalculationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxCalculations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxCalculations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaxCalculations.
     */
    distinct?: TaxCalculationScalarFieldEnum | TaxCalculationScalarFieldEnum[]
  }

  /**
   * TaxCalculation findMany
   */
  export type TaxCalculationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxCalculation
     */
    select?: TaxCalculationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxCalculationInclude<ExtArgs> | null
    /**
     * Filter, which TaxCalculations to fetch.
     */
    where?: TaxCalculationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxCalculations to fetch.
     */
    orderBy?: TaxCalculationOrderByWithRelationInput | TaxCalculationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaxCalculations.
     */
    cursor?: TaxCalculationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxCalculations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxCalculations.
     */
    skip?: number
    distinct?: TaxCalculationScalarFieldEnum | TaxCalculationScalarFieldEnum[]
  }

  /**
   * TaxCalculation create
   */
  export type TaxCalculationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxCalculation
     */
    select?: TaxCalculationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxCalculationInclude<ExtArgs> | null
    /**
     * The data needed to create a TaxCalculation.
     */
    data: XOR<TaxCalculationCreateInput, TaxCalculationUncheckedCreateInput>
  }

  /**
   * TaxCalculation createMany
   */
  export type TaxCalculationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaxCalculations.
     */
    data: TaxCalculationCreateManyInput | TaxCalculationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaxCalculation createManyAndReturn
   */
  export type TaxCalculationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxCalculation
     */
    select?: TaxCalculationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TaxCalculations.
     */
    data: TaxCalculationCreateManyInput | TaxCalculationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxCalculationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaxCalculation update
   */
  export type TaxCalculationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxCalculation
     */
    select?: TaxCalculationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxCalculationInclude<ExtArgs> | null
    /**
     * The data needed to update a TaxCalculation.
     */
    data: XOR<TaxCalculationUpdateInput, TaxCalculationUncheckedUpdateInput>
    /**
     * Choose, which TaxCalculation to update.
     */
    where: TaxCalculationWhereUniqueInput
  }

  /**
   * TaxCalculation updateMany
   */
  export type TaxCalculationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaxCalculations.
     */
    data: XOR<TaxCalculationUpdateManyMutationInput, TaxCalculationUncheckedUpdateManyInput>
    /**
     * Filter which TaxCalculations to update
     */
    where?: TaxCalculationWhereInput
  }

  /**
   * TaxCalculation upsert
   */
  export type TaxCalculationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxCalculation
     */
    select?: TaxCalculationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxCalculationInclude<ExtArgs> | null
    /**
     * The filter to search for the TaxCalculation to update in case it exists.
     */
    where: TaxCalculationWhereUniqueInput
    /**
     * In case the TaxCalculation found by the `where` argument doesn't exist, create a new TaxCalculation with this data.
     */
    create: XOR<TaxCalculationCreateInput, TaxCalculationUncheckedCreateInput>
    /**
     * In case the TaxCalculation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaxCalculationUpdateInput, TaxCalculationUncheckedUpdateInput>
  }

  /**
   * TaxCalculation delete
   */
  export type TaxCalculationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxCalculation
     */
    select?: TaxCalculationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxCalculationInclude<ExtArgs> | null
    /**
     * Filter which TaxCalculation to delete.
     */
    where: TaxCalculationWhereUniqueInput
  }

  /**
   * TaxCalculation deleteMany
   */
  export type TaxCalculationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaxCalculations to delete
     */
    where?: TaxCalculationWhereInput
  }

  /**
   * TaxCalculation without action
   */
  export type TaxCalculationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxCalculation
     */
    select?: TaxCalculationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxCalculationInclude<ExtArgs> | null
  }


  /**
   * Model Alert
   */

  export type AggregateAlert = {
    _count: AlertCountAggregateOutputType | null
    _min: AlertMinAggregateOutputType | null
    _max: AlertMaxAggregateOutputType | null
  }

  export type AlertMinAggregateOutputType = {
    id: string | null
    type: string | null
    message: string | null
    severity: string | null
    resolved: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AlertMaxAggregateOutputType = {
    id: string | null
    type: string | null
    message: string | null
    severity: string | null
    resolved: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AlertCountAggregateOutputType = {
    id: number
    type: number
    message: number
    severity: number
    metadata: number
    resolved: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AlertMinAggregateInputType = {
    id?: true
    type?: true
    message?: true
    severity?: true
    resolved?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AlertMaxAggregateInputType = {
    id?: true
    type?: true
    message?: true
    severity?: true
    resolved?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AlertCountAggregateInputType = {
    id?: true
    type?: true
    message?: true
    severity?: true
    metadata?: true
    resolved?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AlertAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alert to aggregate.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Alerts
    **/
    _count?: true | AlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlertMaxAggregateInputType
  }

  export type GetAlertAggregateType<T extends AlertAggregateArgs> = {
        [P in keyof T & keyof AggregateAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlert[P]>
      : GetScalarType<T[P], AggregateAlert[P]>
  }




  export type AlertGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertWhereInput
    orderBy?: AlertOrderByWithAggregationInput | AlertOrderByWithAggregationInput[]
    by: AlertScalarFieldEnum[] | AlertScalarFieldEnum
    having?: AlertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlertCountAggregateInputType | true
    _min?: AlertMinAggregateInputType
    _max?: AlertMaxAggregateInputType
  }

  export type AlertGroupByOutputType = {
    id: string
    type: string
    message: string
    severity: string
    metadata: JsonValue | null
    resolved: boolean
    createdAt: Date
    updatedAt: Date
    _count: AlertCountAggregateOutputType | null
    _min: AlertMinAggregateOutputType | null
    _max: AlertMaxAggregateOutputType | null
  }

  type GetAlertGroupByPayload<T extends AlertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlertGroupByOutputType[P]>
            : GetScalarType<T[P], AlertGroupByOutputType[P]>
        }
      >
    >


  export type AlertSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    message?: boolean
    severity?: boolean
    metadata?: boolean
    resolved?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["alert"]>

  export type AlertSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    message?: boolean
    severity?: boolean
    metadata?: boolean
    resolved?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["alert"]>

  export type AlertSelectScalar = {
    id?: boolean
    type?: boolean
    message?: boolean
    severity?: boolean
    metadata?: boolean
    resolved?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $AlertPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Alert"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      message: string
      severity: string
      metadata: Prisma.JsonValue | null
      resolved: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["alert"]>
    composites: {}
  }

  type AlertGetPayload<S extends boolean | null | undefined | AlertDefaultArgs> = $Result.GetResult<Prisma.$AlertPayload, S>

  type AlertCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AlertFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AlertCountAggregateInputType | true
    }

  export interface AlertDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Alert'], meta: { name: 'Alert' } }
    /**
     * Find zero or one Alert that matches the filter.
     * @param {AlertFindUniqueArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlertFindUniqueArgs>(args: SelectSubset<T, AlertFindUniqueArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Alert that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AlertFindUniqueOrThrowArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlertFindUniqueOrThrowArgs>(args: SelectSubset<T, AlertFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Alert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindFirstArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlertFindFirstArgs>(args?: SelectSubset<T, AlertFindFirstArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Alert that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindFirstOrThrowArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlertFindFirstOrThrowArgs>(args?: SelectSubset<T, AlertFindFirstOrThrowArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Alerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Alerts
     * const alerts = await prisma.alert.findMany()
     * 
     * // Get first 10 Alerts
     * const alerts = await prisma.alert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alertWithIdOnly = await prisma.alert.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AlertFindManyArgs>(args?: SelectSubset<T, AlertFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Alert.
     * @param {AlertCreateArgs} args - Arguments to create a Alert.
     * @example
     * // Create one Alert
     * const Alert = await prisma.alert.create({
     *   data: {
     *     // ... data to create a Alert
     *   }
     * })
     * 
     */
    create<T extends AlertCreateArgs>(args: SelectSubset<T, AlertCreateArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Alerts.
     * @param {AlertCreateManyArgs} args - Arguments to create many Alerts.
     * @example
     * // Create many Alerts
     * const alert = await prisma.alert.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AlertCreateManyArgs>(args?: SelectSubset<T, AlertCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Alerts and returns the data saved in the database.
     * @param {AlertCreateManyAndReturnArgs} args - Arguments to create many Alerts.
     * @example
     * // Create many Alerts
     * const alert = await prisma.alert.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Alerts and only return the `id`
     * const alertWithIdOnly = await prisma.alert.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AlertCreateManyAndReturnArgs>(args?: SelectSubset<T, AlertCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Alert.
     * @param {AlertDeleteArgs} args - Arguments to delete one Alert.
     * @example
     * // Delete one Alert
     * const Alert = await prisma.alert.delete({
     *   where: {
     *     // ... filter to delete one Alert
     *   }
     * })
     * 
     */
    delete<T extends AlertDeleteArgs>(args: SelectSubset<T, AlertDeleteArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Alert.
     * @param {AlertUpdateArgs} args - Arguments to update one Alert.
     * @example
     * // Update one Alert
     * const alert = await prisma.alert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AlertUpdateArgs>(args: SelectSubset<T, AlertUpdateArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Alerts.
     * @param {AlertDeleteManyArgs} args - Arguments to filter Alerts to delete.
     * @example
     * // Delete a few Alerts
     * const { count } = await prisma.alert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AlertDeleteManyArgs>(args?: SelectSubset<T, AlertDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Alerts
     * const alert = await prisma.alert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AlertUpdateManyArgs>(args: SelectSubset<T, AlertUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Alert.
     * @param {AlertUpsertArgs} args - Arguments to update or create a Alert.
     * @example
     * // Update or create a Alert
     * const alert = await prisma.alert.upsert({
     *   create: {
     *     // ... data to create a Alert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Alert we want to update
     *   }
     * })
     */
    upsert<T extends AlertUpsertArgs>(args: SelectSubset<T, AlertUpsertArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertCountArgs} args - Arguments to filter Alerts to count.
     * @example
     * // Count the number of Alerts
     * const count = await prisma.alert.count({
     *   where: {
     *     // ... the filter for the Alerts we want to count
     *   }
     * })
    **/
    count<T extends AlertCountArgs>(
      args?: Subset<T, AlertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Alert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlertAggregateArgs>(args: Subset<T, AlertAggregateArgs>): Prisma.PrismaPromise<GetAlertAggregateType<T>>

    /**
     * Group by Alert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlertGroupByArgs['orderBy'] }
        : { orderBy?: AlertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Alert model
   */
  readonly fields: AlertFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Alert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlertClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Alert model
   */ 
  interface AlertFieldRefs {
    readonly id: FieldRef<"Alert", 'String'>
    readonly type: FieldRef<"Alert", 'String'>
    readonly message: FieldRef<"Alert", 'String'>
    readonly severity: FieldRef<"Alert", 'String'>
    readonly metadata: FieldRef<"Alert", 'Json'>
    readonly resolved: FieldRef<"Alert", 'Boolean'>
    readonly createdAt: FieldRef<"Alert", 'DateTime'>
    readonly updatedAt: FieldRef<"Alert", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Alert findUnique
   */
  export type AlertFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert findUniqueOrThrow
   */
  export type AlertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert findFirst
   */
  export type AlertFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alerts.
     */
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Alert findFirstOrThrow
   */
  export type AlertFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alerts.
     */
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Alert findMany
   */
  export type AlertFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Filter, which Alerts to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Alert create
   */
  export type AlertCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * The data needed to create a Alert.
     */
    data: XOR<AlertCreateInput, AlertUncheckedCreateInput>
  }

  /**
   * Alert createMany
   */
  export type AlertCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Alerts.
     */
    data: AlertCreateManyInput | AlertCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Alert createManyAndReturn
   */
  export type AlertCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Alerts.
     */
    data: AlertCreateManyInput | AlertCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Alert update
   */
  export type AlertUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * The data needed to update a Alert.
     */
    data: XOR<AlertUpdateInput, AlertUncheckedUpdateInput>
    /**
     * Choose, which Alert to update.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert updateMany
   */
  export type AlertUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Alerts.
     */
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyInput>
    /**
     * Filter which Alerts to update
     */
    where?: AlertWhereInput
  }

  /**
   * Alert upsert
   */
  export type AlertUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * The filter to search for the Alert to update in case it exists.
     */
    where: AlertWhereUniqueInput
    /**
     * In case the Alert found by the `where` argument doesn't exist, create a new Alert with this data.
     */
    create: XOR<AlertCreateInput, AlertUncheckedCreateInput>
    /**
     * In case the Alert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlertUpdateInput, AlertUncheckedUpdateInput>
  }

  /**
   * Alert delete
   */
  export type AlertDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Filter which Alert to delete.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert deleteMany
   */
  export type AlertDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alerts to delete
     */
    where?: AlertWhereInput
  }

  /**
   * Alert without action
   */
  export type AlertDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
  }


  /**
   * Model TaxRate
   */

  export type AggregateTaxRate = {
    _count: TaxRateCountAggregateOutputType | null
    _avg: TaxRateAvgAggregateOutputType | null
    _sum: TaxRateSumAggregateOutputType | null
    _min: TaxRateMinAggregateOutputType | null
    _max: TaxRateMaxAggregateOutputType | null
  }

  export type TaxRateAvgAggregateOutputType = {
    rate: Decimal | null
  }

  export type TaxRateSumAggregateOutputType = {
    rate: Decimal | null
  }

  export type TaxRateMinAggregateOutputType = {
    id: string | null
    countryCode: string | null
    stateCode: string | null
    name: string | null
    rate: Decimal | null
    isActive: boolean | null
    isEU: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaxRateMaxAggregateOutputType = {
    id: string | null
    countryCode: string | null
    stateCode: string | null
    name: string | null
    rate: Decimal | null
    isActive: boolean | null
    isEU: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaxRateCountAggregateOutputType = {
    id: number
    countryCode: number
    stateCode: number
    name: number
    rate: number
    isActive: number
    isEU: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TaxRateAvgAggregateInputType = {
    rate?: true
  }

  export type TaxRateSumAggregateInputType = {
    rate?: true
  }

  export type TaxRateMinAggregateInputType = {
    id?: true
    countryCode?: true
    stateCode?: true
    name?: true
    rate?: true
    isActive?: true
    isEU?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaxRateMaxAggregateInputType = {
    id?: true
    countryCode?: true
    stateCode?: true
    name?: true
    rate?: true
    isActive?: true
    isEU?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaxRateCountAggregateInputType = {
    id?: true
    countryCode?: true
    stateCode?: true
    name?: true
    rate?: true
    isActive?: true
    isEU?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TaxRateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaxRate to aggregate.
     */
    where?: TaxRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxRates to fetch.
     */
    orderBy?: TaxRateOrderByWithRelationInput | TaxRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaxRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaxRates
    **/
    _count?: true | TaxRateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaxRateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaxRateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaxRateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaxRateMaxAggregateInputType
  }

  export type GetTaxRateAggregateType<T extends TaxRateAggregateArgs> = {
        [P in keyof T & keyof AggregateTaxRate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaxRate[P]>
      : GetScalarType<T[P], AggregateTaxRate[P]>
  }




  export type TaxRateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaxRateWhereInput
    orderBy?: TaxRateOrderByWithAggregationInput | TaxRateOrderByWithAggregationInput[]
    by: TaxRateScalarFieldEnum[] | TaxRateScalarFieldEnum
    having?: TaxRateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaxRateCountAggregateInputType | true
    _avg?: TaxRateAvgAggregateInputType
    _sum?: TaxRateSumAggregateInputType
    _min?: TaxRateMinAggregateInputType
    _max?: TaxRateMaxAggregateInputType
  }

  export type TaxRateGroupByOutputType = {
    id: string
    countryCode: string
    stateCode: string | null
    name: string
    rate: Decimal
    isActive: boolean
    isEU: boolean
    createdAt: Date
    updatedAt: Date
    _count: TaxRateCountAggregateOutputType | null
    _avg: TaxRateAvgAggregateOutputType | null
    _sum: TaxRateSumAggregateOutputType | null
    _min: TaxRateMinAggregateOutputType | null
    _max: TaxRateMaxAggregateOutputType | null
  }

  type GetTaxRateGroupByPayload<T extends TaxRateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaxRateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaxRateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaxRateGroupByOutputType[P]>
            : GetScalarType<T[P], TaxRateGroupByOutputType[P]>
        }
      >
    >


  export type TaxRateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    countryCode?: boolean
    stateCode?: boolean
    name?: boolean
    rate?: boolean
    isActive?: boolean
    isEU?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["taxRate"]>

  export type TaxRateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    countryCode?: boolean
    stateCode?: boolean
    name?: boolean
    rate?: boolean
    isActive?: boolean
    isEU?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["taxRate"]>

  export type TaxRateSelectScalar = {
    id?: boolean
    countryCode?: boolean
    stateCode?: boolean
    name?: boolean
    rate?: boolean
    isActive?: boolean
    isEU?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $TaxRatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaxRate"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      countryCode: string
      stateCode: string | null
      name: string
      rate: Prisma.Decimal
      isActive: boolean
      isEU: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["taxRate"]>
    composites: {}
  }

  type TaxRateGetPayload<S extends boolean | null | undefined | TaxRateDefaultArgs> = $Result.GetResult<Prisma.$TaxRatePayload, S>

  type TaxRateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TaxRateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TaxRateCountAggregateInputType | true
    }

  export interface TaxRateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaxRate'], meta: { name: 'TaxRate' } }
    /**
     * Find zero or one TaxRate that matches the filter.
     * @param {TaxRateFindUniqueArgs} args - Arguments to find a TaxRate
     * @example
     * // Get one TaxRate
     * const taxRate = await prisma.taxRate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaxRateFindUniqueArgs>(args: SelectSubset<T, TaxRateFindUniqueArgs<ExtArgs>>): Prisma__TaxRateClient<$Result.GetResult<Prisma.$TaxRatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TaxRate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TaxRateFindUniqueOrThrowArgs} args - Arguments to find a TaxRate
     * @example
     * // Get one TaxRate
     * const taxRate = await prisma.taxRate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaxRateFindUniqueOrThrowArgs>(args: SelectSubset<T, TaxRateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaxRateClient<$Result.GetResult<Prisma.$TaxRatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TaxRate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxRateFindFirstArgs} args - Arguments to find a TaxRate
     * @example
     * // Get one TaxRate
     * const taxRate = await prisma.taxRate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaxRateFindFirstArgs>(args?: SelectSubset<T, TaxRateFindFirstArgs<ExtArgs>>): Prisma__TaxRateClient<$Result.GetResult<Prisma.$TaxRatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TaxRate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxRateFindFirstOrThrowArgs} args - Arguments to find a TaxRate
     * @example
     * // Get one TaxRate
     * const taxRate = await prisma.taxRate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaxRateFindFirstOrThrowArgs>(args?: SelectSubset<T, TaxRateFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaxRateClient<$Result.GetResult<Prisma.$TaxRatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TaxRates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxRateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaxRates
     * const taxRates = await prisma.taxRate.findMany()
     * 
     * // Get first 10 TaxRates
     * const taxRates = await prisma.taxRate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taxRateWithIdOnly = await prisma.taxRate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaxRateFindManyArgs>(args?: SelectSubset<T, TaxRateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxRatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TaxRate.
     * @param {TaxRateCreateArgs} args - Arguments to create a TaxRate.
     * @example
     * // Create one TaxRate
     * const TaxRate = await prisma.taxRate.create({
     *   data: {
     *     // ... data to create a TaxRate
     *   }
     * })
     * 
     */
    create<T extends TaxRateCreateArgs>(args: SelectSubset<T, TaxRateCreateArgs<ExtArgs>>): Prisma__TaxRateClient<$Result.GetResult<Prisma.$TaxRatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TaxRates.
     * @param {TaxRateCreateManyArgs} args - Arguments to create many TaxRates.
     * @example
     * // Create many TaxRates
     * const taxRate = await prisma.taxRate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaxRateCreateManyArgs>(args?: SelectSubset<T, TaxRateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaxRates and returns the data saved in the database.
     * @param {TaxRateCreateManyAndReturnArgs} args - Arguments to create many TaxRates.
     * @example
     * // Create many TaxRates
     * const taxRate = await prisma.taxRate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaxRates and only return the `id`
     * const taxRateWithIdOnly = await prisma.taxRate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaxRateCreateManyAndReturnArgs>(args?: SelectSubset<T, TaxRateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxRatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TaxRate.
     * @param {TaxRateDeleteArgs} args - Arguments to delete one TaxRate.
     * @example
     * // Delete one TaxRate
     * const TaxRate = await prisma.taxRate.delete({
     *   where: {
     *     // ... filter to delete one TaxRate
     *   }
     * })
     * 
     */
    delete<T extends TaxRateDeleteArgs>(args: SelectSubset<T, TaxRateDeleteArgs<ExtArgs>>): Prisma__TaxRateClient<$Result.GetResult<Prisma.$TaxRatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TaxRate.
     * @param {TaxRateUpdateArgs} args - Arguments to update one TaxRate.
     * @example
     * // Update one TaxRate
     * const taxRate = await prisma.taxRate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaxRateUpdateArgs>(args: SelectSubset<T, TaxRateUpdateArgs<ExtArgs>>): Prisma__TaxRateClient<$Result.GetResult<Prisma.$TaxRatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TaxRates.
     * @param {TaxRateDeleteManyArgs} args - Arguments to filter TaxRates to delete.
     * @example
     * // Delete a few TaxRates
     * const { count } = await prisma.taxRate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaxRateDeleteManyArgs>(args?: SelectSubset<T, TaxRateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaxRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxRateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaxRates
     * const taxRate = await prisma.taxRate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaxRateUpdateManyArgs>(args: SelectSubset<T, TaxRateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TaxRate.
     * @param {TaxRateUpsertArgs} args - Arguments to update or create a TaxRate.
     * @example
     * // Update or create a TaxRate
     * const taxRate = await prisma.taxRate.upsert({
     *   create: {
     *     // ... data to create a TaxRate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaxRate we want to update
     *   }
     * })
     */
    upsert<T extends TaxRateUpsertArgs>(args: SelectSubset<T, TaxRateUpsertArgs<ExtArgs>>): Prisma__TaxRateClient<$Result.GetResult<Prisma.$TaxRatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TaxRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxRateCountArgs} args - Arguments to filter TaxRates to count.
     * @example
     * // Count the number of TaxRates
     * const count = await prisma.taxRate.count({
     *   where: {
     *     // ... the filter for the TaxRates we want to count
     *   }
     * })
    **/
    count<T extends TaxRateCountArgs>(
      args?: Subset<T, TaxRateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaxRateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaxRate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxRateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaxRateAggregateArgs>(args: Subset<T, TaxRateAggregateArgs>): Prisma.PrismaPromise<GetTaxRateAggregateType<T>>

    /**
     * Group by TaxRate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxRateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaxRateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaxRateGroupByArgs['orderBy'] }
        : { orderBy?: TaxRateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaxRateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaxRateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaxRate model
   */
  readonly fields: TaxRateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaxRate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaxRateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaxRate model
   */ 
  interface TaxRateFieldRefs {
    readonly id: FieldRef<"TaxRate", 'String'>
    readonly countryCode: FieldRef<"TaxRate", 'String'>
    readonly stateCode: FieldRef<"TaxRate", 'String'>
    readonly name: FieldRef<"TaxRate", 'String'>
    readonly rate: FieldRef<"TaxRate", 'Decimal'>
    readonly isActive: FieldRef<"TaxRate", 'Boolean'>
    readonly isEU: FieldRef<"TaxRate", 'Boolean'>
    readonly createdAt: FieldRef<"TaxRate", 'DateTime'>
    readonly updatedAt: FieldRef<"TaxRate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaxRate findUnique
   */
  export type TaxRateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxRate
     */
    select?: TaxRateSelect<ExtArgs> | null
    /**
     * Filter, which TaxRate to fetch.
     */
    where: TaxRateWhereUniqueInput
  }

  /**
   * TaxRate findUniqueOrThrow
   */
  export type TaxRateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxRate
     */
    select?: TaxRateSelect<ExtArgs> | null
    /**
     * Filter, which TaxRate to fetch.
     */
    where: TaxRateWhereUniqueInput
  }

  /**
   * TaxRate findFirst
   */
  export type TaxRateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxRate
     */
    select?: TaxRateSelect<ExtArgs> | null
    /**
     * Filter, which TaxRate to fetch.
     */
    where?: TaxRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxRates to fetch.
     */
    orderBy?: TaxRateOrderByWithRelationInput | TaxRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaxRates.
     */
    cursor?: TaxRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaxRates.
     */
    distinct?: TaxRateScalarFieldEnum | TaxRateScalarFieldEnum[]
  }

  /**
   * TaxRate findFirstOrThrow
   */
  export type TaxRateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxRate
     */
    select?: TaxRateSelect<ExtArgs> | null
    /**
     * Filter, which TaxRate to fetch.
     */
    where?: TaxRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxRates to fetch.
     */
    orderBy?: TaxRateOrderByWithRelationInput | TaxRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaxRates.
     */
    cursor?: TaxRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaxRates.
     */
    distinct?: TaxRateScalarFieldEnum | TaxRateScalarFieldEnum[]
  }

  /**
   * TaxRate findMany
   */
  export type TaxRateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxRate
     */
    select?: TaxRateSelect<ExtArgs> | null
    /**
     * Filter, which TaxRates to fetch.
     */
    where?: TaxRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxRates to fetch.
     */
    orderBy?: TaxRateOrderByWithRelationInput | TaxRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaxRates.
     */
    cursor?: TaxRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxRates.
     */
    skip?: number
    distinct?: TaxRateScalarFieldEnum | TaxRateScalarFieldEnum[]
  }

  /**
   * TaxRate create
   */
  export type TaxRateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxRate
     */
    select?: TaxRateSelect<ExtArgs> | null
    /**
     * The data needed to create a TaxRate.
     */
    data: XOR<TaxRateCreateInput, TaxRateUncheckedCreateInput>
  }

  /**
   * TaxRate createMany
   */
  export type TaxRateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaxRates.
     */
    data: TaxRateCreateManyInput | TaxRateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaxRate createManyAndReturn
   */
  export type TaxRateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxRate
     */
    select?: TaxRateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TaxRates.
     */
    data: TaxRateCreateManyInput | TaxRateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaxRate update
   */
  export type TaxRateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxRate
     */
    select?: TaxRateSelect<ExtArgs> | null
    /**
     * The data needed to update a TaxRate.
     */
    data: XOR<TaxRateUpdateInput, TaxRateUncheckedUpdateInput>
    /**
     * Choose, which TaxRate to update.
     */
    where: TaxRateWhereUniqueInput
  }

  /**
   * TaxRate updateMany
   */
  export type TaxRateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaxRates.
     */
    data: XOR<TaxRateUpdateManyMutationInput, TaxRateUncheckedUpdateManyInput>
    /**
     * Filter which TaxRates to update
     */
    where?: TaxRateWhereInput
  }

  /**
   * TaxRate upsert
   */
  export type TaxRateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxRate
     */
    select?: TaxRateSelect<ExtArgs> | null
    /**
     * The filter to search for the TaxRate to update in case it exists.
     */
    where: TaxRateWhereUniqueInput
    /**
     * In case the TaxRate found by the `where` argument doesn't exist, create a new TaxRate with this data.
     */
    create: XOR<TaxRateCreateInput, TaxRateUncheckedCreateInput>
    /**
     * In case the TaxRate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaxRateUpdateInput, TaxRateUncheckedUpdateInput>
  }

  /**
   * TaxRate delete
   */
  export type TaxRateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxRate
     */
    select?: TaxRateSelect<ExtArgs> | null
    /**
     * Filter which TaxRate to delete.
     */
    where: TaxRateWhereUniqueInput
  }

  /**
   * TaxRate deleteMany
   */
  export type TaxRateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaxRates to delete
     */
    where?: TaxRateWhereInput
  }

  /**
   * TaxRate without action
   */
  export type TaxRateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxRate
     */
    select?: TaxRateSelect<ExtArgs> | null
  }


  /**
   * Model Bill
   */

  export type AggregateBill = {
    _count: BillCountAggregateOutputType | null
    _avg: BillAvgAggregateOutputType | null
    _sum: BillSumAggregateOutputType | null
    _min: BillMinAggregateOutputType | null
    _max: BillMaxAggregateOutputType | null
  }

  export type BillAvgAggregateOutputType = {
    amount: number | null
  }

  export type BillSumAggregateOutputType = {
    amount: number | null
  }

  export type BillMinAggregateOutputType = {
    id: string | null
    amount: number | null
    description: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BillMaxAggregateOutputType = {
    id: string | null
    amount: number | null
    description: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BillCountAggregateOutputType = {
    id: number
    amount: number
    description: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BillAvgAggregateInputType = {
    amount?: true
  }

  export type BillSumAggregateInputType = {
    amount?: true
  }

  export type BillMinAggregateInputType = {
    id?: true
    amount?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BillMaxAggregateInputType = {
    id?: true
    amount?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BillCountAggregateInputType = {
    id?: true
    amount?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bill to aggregate.
     */
    where?: BillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bills to fetch.
     */
    orderBy?: BillOrderByWithRelationInput | BillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bills
    **/
    _count?: true | BillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BillMaxAggregateInputType
  }

  export type GetBillAggregateType<T extends BillAggregateArgs> = {
        [P in keyof T & keyof AggregateBill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBill[P]>
      : GetScalarType<T[P], AggregateBill[P]>
  }




  export type BillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillWhereInput
    orderBy?: BillOrderByWithAggregationInput | BillOrderByWithAggregationInput[]
    by: BillScalarFieldEnum[] | BillScalarFieldEnum
    having?: BillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BillCountAggregateInputType | true
    _avg?: BillAvgAggregateInputType
    _sum?: BillSumAggregateInputType
    _min?: BillMinAggregateInputType
    _max?: BillMaxAggregateInputType
  }

  export type BillGroupByOutputType = {
    id: string
    amount: number
    description: string
    status: string
    createdAt: Date
    updatedAt: Date
    _count: BillCountAggregateOutputType | null
    _avg: BillAvgAggregateOutputType | null
    _sum: BillSumAggregateOutputType | null
    _min: BillMinAggregateOutputType | null
    _max: BillMaxAggregateOutputType | null
  }

  type GetBillGroupByPayload<T extends BillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BillGroupByOutputType[P]>
            : GetScalarType<T[P], BillGroupByOutputType[P]>
        }
      >
    >


  export type BillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["bill"]>

  export type BillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["bill"]>

  export type BillSelectScalar = {
    id?: boolean
    amount?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $BillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bill"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      amount: number
      description: string
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bill"]>
    composites: {}
  }

  type BillGetPayload<S extends boolean | null | undefined | BillDefaultArgs> = $Result.GetResult<Prisma.$BillPayload, S>

  type BillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BillFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BillCountAggregateInputType | true
    }

  export interface BillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bill'], meta: { name: 'Bill' } }
    /**
     * Find zero or one Bill that matches the filter.
     * @param {BillFindUniqueArgs} args - Arguments to find a Bill
     * @example
     * // Get one Bill
     * const bill = await prisma.bill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BillFindUniqueArgs>(args: SelectSubset<T, BillFindUniqueArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Bill that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BillFindUniqueOrThrowArgs} args - Arguments to find a Bill
     * @example
     * // Get one Bill
     * const bill = await prisma.bill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BillFindUniqueOrThrowArgs>(args: SelectSubset<T, BillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Bill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillFindFirstArgs} args - Arguments to find a Bill
     * @example
     * // Get one Bill
     * const bill = await prisma.bill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BillFindFirstArgs>(args?: SelectSubset<T, BillFindFirstArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Bill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillFindFirstOrThrowArgs} args - Arguments to find a Bill
     * @example
     * // Get one Bill
     * const bill = await prisma.bill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BillFindFirstOrThrowArgs>(args?: SelectSubset<T, BillFindFirstOrThrowArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Bills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bills
     * const bills = await prisma.bill.findMany()
     * 
     * // Get first 10 Bills
     * const bills = await prisma.bill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const billWithIdOnly = await prisma.bill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BillFindManyArgs>(args?: SelectSubset<T, BillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Bill.
     * @param {BillCreateArgs} args - Arguments to create a Bill.
     * @example
     * // Create one Bill
     * const Bill = await prisma.bill.create({
     *   data: {
     *     // ... data to create a Bill
     *   }
     * })
     * 
     */
    create<T extends BillCreateArgs>(args: SelectSubset<T, BillCreateArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Bills.
     * @param {BillCreateManyArgs} args - Arguments to create many Bills.
     * @example
     * // Create many Bills
     * const bill = await prisma.bill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BillCreateManyArgs>(args?: SelectSubset<T, BillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bills and returns the data saved in the database.
     * @param {BillCreateManyAndReturnArgs} args - Arguments to create many Bills.
     * @example
     * // Create many Bills
     * const bill = await prisma.bill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bills and only return the `id`
     * const billWithIdOnly = await prisma.bill.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BillCreateManyAndReturnArgs>(args?: SelectSubset<T, BillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Bill.
     * @param {BillDeleteArgs} args - Arguments to delete one Bill.
     * @example
     * // Delete one Bill
     * const Bill = await prisma.bill.delete({
     *   where: {
     *     // ... filter to delete one Bill
     *   }
     * })
     * 
     */
    delete<T extends BillDeleteArgs>(args: SelectSubset<T, BillDeleteArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Bill.
     * @param {BillUpdateArgs} args - Arguments to update one Bill.
     * @example
     * // Update one Bill
     * const bill = await prisma.bill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BillUpdateArgs>(args: SelectSubset<T, BillUpdateArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Bills.
     * @param {BillDeleteManyArgs} args - Arguments to filter Bills to delete.
     * @example
     * // Delete a few Bills
     * const { count } = await prisma.bill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BillDeleteManyArgs>(args?: SelectSubset<T, BillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bills
     * const bill = await prisma.bill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BillUpdateManyArgs>(args: SelectSubset<T, BillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bill.
     * @param {BillUpsertArgs} args - Arguments to update or create a Bill.
     * @example
     * // Update or create a Bill
     * const bill = await prisma.bill.upsert({
     *   create: {
     *     // ... data to create a Bill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bill we want to update
     *   }
     * })
     */
    upsert<T extends BillUpsertArgs>(args: SelectSubset<T, BillUpsertArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Bills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillCountArgs} args - Arguments to filter Bills to count.
     * @example
     * // Count the number of Bills
     * const count = await prisma.bill.count({
     *   where: {
     *     // ... the filter for the Bills we want to count
     *   }
     * })
    **/
    count<T extends BillCountArgs>(
      args?: Subset<T, BillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BillAggregateArgs>(args: Subset<T, BillAggregateArgs>): Prisma.PrismaPromise<GetBillAggregateType<T>>

    /**
     * Group by Bill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BillGroupByArgs['orderBy'] }
        : { orderBy?: BillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bill model
   */
  readonly fields: BillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bill model
   */ 
  interface BillFieldRefs {
    readonly id: FieldRef<"Bill", 'String'>
    readonly amount: FieldRef<"Bill", 'Float'>
    readonly description: FieldRef<"Bill", 'String'>
    readonly status: FieldRef<"Bill", 'String'>
    readonly createdAt: FieldRef<"Bill", 'DateTime'>
    readonly updatedAt: FieldRef<"Bill", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Bill findUnique
   */
  export type BillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Filter, which Bill to fetch.
     */
    where: BillWhereUniqueInput
  }

  /**
   * Bill findUniqueOrThrow
   */
  export type BillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Filter, which Bill to fetch.
     */
    where: BillWhereUniqueInput
  }

  /**
   * Bill findFirst
   */
  export type BillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Filter, which Bill to fetch.
     */
    where?: BillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bills to fetch.
     */
    orderBy?: BillOrderByWithRelationInput | BillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bills.
     */
    cursor?: BillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bills.
     */
    distinct?: BillScalarFieldEnum | BillScalarFieldEnum[]
  }

  /**
   * Bill findFirstOrThrow
   */
  export type BillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Filter, which Bill to fetch.
     */
    where?: BillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bills to fetch.
     */
    orderBy?: BillOrderByWithRelationInput | BillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bills.
     */
    cursor?: BillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bills.
     */
    distinct?: BillScalarFieldEnum | BillScalarFieldEnum[]
  }

  /**
   * Bill findMany
   */
  export type BillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Filter, which Bills to fetch.
     */
    where?: BillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bills to fetch.
     */
    orderBy?: BillOrderByWithRelationInput | BillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bills.
     */
    cursor?: BillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bills.
     */
    skip?: number
    distinct?: BillScalarFieldEnum | BillScalarFieldEnum[]
  }

  /**
   * Bill create
   */
  export type BillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * The data needed to create a Bill.
     */
    data: XOR<BillCreateInput, BillUncheckedCreateInput>
  }

  /**
   * Bill createMany
   */
  export type BillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bills.
     */
    data: BillCreateManyInput | BillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bill createManyAndReturn
   */
  export type BillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Bills.
     */
    data: BillCreateManyInput | BillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bill update
   */
  export type BillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * The data needed to update a Bill.
     */
    data: XOR<BillUpdateInput, BillUncheckedUpdateInput>
    /**
     * Choose, which Bill to update.
     */
    where: BillWhereUniqueInput
  }

  /**
   * Bill updateMany
   */
  export type BillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bills.
     */
    data: XOR<BillUpdateManyMutationInput, BillUncheckedUpdateManyInput>
    /**
     * Filter which Bills to update
     */
    where?: BillWhereInput
  }

  /**
   * Bill upsert
   */
  export type BillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * The filter to search for the Bill to update in case it exists.
     */
    where: BillWhereUniqueInput
    /**
     * In case the Bill found by the `where` argument doesn't exist, create a new Bill with this data.
     */
    create: XOR<BillCreateInput, BillUncheckedCreateInput>
    /**
     * In case the Bill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BillUpdateInput, BillUncheckedUpdateInput>
  }

  /**
   * Bill delete
   */
  export type BillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Filter which Bill to delete.
     */
    where: BillWhereUniqueInput
  }

  /**
   * Bill deleteMany
   */
  export type BillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bills to delete
     */
    where?: BillWhereInput
  }

  /**
   * Bill without action
   */
  export type BillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    amount: number | null
  }

  export type TransactionSumAggregateOutputType = {
    amount: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    amount: number | null
    type: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    amount: number | null
    type: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    amount: number
    type: number
    status: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    amount?: true
  }

  export type TransactionSumAggregateInputType = {
    amount?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    amount?: true
    type?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    amount?: true
    type?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    amount?: true
    type?: true
    status?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: string
    amount: number
    type: string
    status: string
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    type?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    type?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    amount?: boolean
    type?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      amount: number
      type: string
      status: string
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */ 
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'String'>
    readonly amount: FieldRef<"Transaction", 'Float'>
    readonly type: FieldRef<"Transaction", 'String'>
    readonly status: FieldRef<"Transaction", 'String'>
    readonly metadata: FieldRef<"Transaction", 'Json'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
    readonly updatedAt: FieldRef<"Transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
  }


  /**
   * Model RetryAttempt
   */

  export type AggregateRetryAttempt = {
    _count: RetryAttemptCountAggregateOutputType | null
    _avg: RetryAttemptAvgAggregateOutputType | null
    _sum: RetryAttemptSumAggregateOutputType | null
    _min: RetryAttemptMinAggregateOutputType | null
    _max: RetryAttemptMaxAggregateOutputType | null
  }

  export type RetryAttemptAvgAggregateOutputType = {
    attempts: number | null
  }

  export type RetryAttemptSumAggregateOutputType = {
    attempts: number | null
  }

  export type RetryAttemptMinAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    userId: string | null
    attempts: number | null
    lastAttemptAt: Date | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RetryAttemptMaxAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    userId: string | null
    attempts: number | null
    lastAttemptAt: Date | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RetryAttemptCountAggregateOutputType = {
    id: number
    invoiceId: number
    userId: number
    attempts: number
    lastAttemptAt: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RetryAttemptAvgAggregateInputType = {
    attempts?: true
  }

  export type RetryAttemptSumAggregateInputType = {
    attempts?: true
  }

  export type RetryAttemptMinAggregateInputType = {
    id?: true
    invoiceId?: true
    userId?: true
    attempts?: true
    lastAttemptAt?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RetryAttemptMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    userId?: true
    attempts?: true
    lastAttemptAt?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RetryAttemptCountAggregateInputType = {
    id?: true
    invoiceId?: true
    userId?: true
    attempts?: true
    lastAttemptAt?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RetryAttemptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RetryAttempt to aggregate.
     */
    where?: RetryAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RetryAttempts to fetch.
     */
    orderBy?: RetryAttemptOrderByWithRelationInput | RetryAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RetryAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RetryAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RetryAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RetryAttempts
    **/
    _count?: true | RetryAttemptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RetryAttemptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RetryAttemptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RetryAttemptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RetryAttemptMaxAggregateInputType
  }

  export type GetRetryAttemptAggregateType<T extends RetryAttemptAggregateArgs> = {
        [P in keyof T & keyof AggregateRetryAttempt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRetryAttempt[P]>
      : GetScalarType<T[P], AggregateRetryAttempt[P]>
  }




  export type RetryAttemptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RetryAttemptWhereInput
    orderBy?: RetryAttemptOrderByWithAggregationInput | RetryAttemptOrderByWithAggregationInput[]
    by: RetryAttemptScalarFieldEnum[] | RetryAttemptScalarFieldEnum
    having?: RetryAttemptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RetryAttemptCountAggregateInputType | true
    _avg?: RetryAttemptAvgAggregateInputType
    _sum?: RetryAttemptSumAggregateInputType
    _min?: RetryAttemptMinAggregateInputType
    _max?: RetryAttemptMaxAggregateInputType
  }

  export type RetryAttemptGroupByOutputType = {
    id: string
    invoiceId: string
    userId: string
    attempts: number
    lastAttemptAt: Date
    status: string
    createdAt: Date
    updatedAt: Date
    _count: RetryAttemptCountAggregateOutputType | null
    _avg: RetryAttemptAvgAggregateOutputType | null
    _sum: RetryAttemptSumAggregateOutputType | null
    _min: RetryAttemptMinAggregateOutputType | null
    _max: RetryAttemptMaxAggregateOutputType | null
  }

  type GetRetryAttemptGroupByPayload<T extends RetryAttemptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RetryAttemptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RetryAttemptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RetryAttemptGroupByOutputType[P]>
            : GetScalarType<T[P], RetryAttemptGroupByOutputType[P]>
        }
      >
    >


  export type RetryAttemptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    userId?: boolean
    attempts?: boolean
    lastAttemptAt?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["retryAttempt"]>

  export type RetryAttemptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    userId?: boolean
    attempts?: boolean
    lastAttemptAt?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["retryAttempt"]>

  export type RetryAttemptSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    userId?: boolean
    attempts?: boolean
    lastAttemptAt?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RetryAttemptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RetryAttemptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RetryAttemptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RetryAttempt"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceId: string
      userId: string
      attempts: number
      lastAttemptAt: Date
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["retryAttempt"]>
    composites: {}
  }

  type RetryAttemptGetPayload<S extends boolean | null | undefined | RetryAttemptDefaultArgs> = $Result.GetResult<Prisma.$RetryAttemptPayload, S>

  type RetryAttemptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RetryAttemptFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RetryAttemptCountAggregateInputType | true
    }

  export interface RetryAttemptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RetryAttempt'], meta: { name: 'RetryAttempt' } }
    /**
     * Find zero or one RetryAttempt that matches the filter.
     * @param {RetryAttemptFindUniqueArgs} args - Arguments to find a RetryAttempt
     * @example
     * // Get one RetryAttempt
     * const retryAttempt = await prisma.retryAttempt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RetryAttemptFindUniqueArgs>(args: SelectSubset<T, RetryAttemptFindUniqueArgs<ExtArgs>>): Prisma__RetryAttemptClient<$Result.GetResult<Prisma.$RetryAttemptPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RetryAttempt that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RetryAttemptFindUniqueOrThrowArgs} args - Arguments to find a RetryAttempt
     * @example
     * // Get one RetryAttempt
     * const retryAttempt = await prisma.retryAttempt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RetryAttemptFindUniqueOrThrowArgs>(args: SelectSubset<T, RetryAttemptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RetryAttemptClient<$Result.GetResult<Prisma.$RetryAttemptPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RetryAttempt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetryAttemptFindFirstArgs} args - Arguments to find a RetryAttempt
     * @example
     * // Get one RetryAttempt
     * const retryAttempt = await prisma.retryAttempt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RetryAttemptFindFirstArgs>(args?: SelectSubset<T, RetryAttemptFindFirstArgs<ExtArgs>>): Prisma__RetryAttemptClient<$Result.GetResult<Prisma.$RetryAttemptPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RetryAttempt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetryAttemptFindFirstOrThrowArgs} args - Arguments to find a RetryAttempt
     * @example
     * // Get one RetryAttempt
     * const retryAttempt = await prisma.retryAttempt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RetryAttemptFindFirstOrThrowArgs>(args?: SelectSubset<T, RetryAttemptFindFirstOrThrowArgs<ExtArgs>>): Prisma__RetryAttemptClient<$Result.GetResult<Prisma.$RetryAttemptPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RetryAttempts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetryAttemptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RetryAttempts
     * const retryAttempts = await prisma.retryAttempt.findMany()
     * 
     * // Get first 10 RetryAttempts
     * const retryAttempts = await prisma.retryAttempt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const retryAttemptWithIdOnly = await prisma.retryAttempt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RetryAttemptFindManyArgs>(args?: SelectSubset<T, RetryAttemptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RetryAttemptPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RetryAttempt.
     * @param {RetryAttemptCreateArgs} args - Arguments to create a RetryAttempt.
     * @example
     * // Create one RetryAttempt
     * const RetryAttempt = await prisma.retryAttempt.create({
     *   data: {
     *     // ... data to create a RetryAttempt
     *   }
     * })
     * 
     */
    create<T extends RetryAttemptCreateArgs>(args: SelectSubset<T, RetryAttemptCreateArgs<ExtArgs>>): Prisma__RetryAttemptClient<$Result.GetResult<Prisma.$RetryAttemptPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RetryAttempts.
     * @param {RetryAttemptCreateManyArgs} args - Arguments to create many RetryAttempts.
     * @example
     * // Create many RetryAttempts
     * const retryAttempt = await prisma.retryAttempt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RetryAttemptCreateManyArgs>(args?: SelectSubset<T, RetryAttemptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RetryAttempts and returns the data saved in the database.
     * @param {RetryAttemptCreateManyAndReturnArgs} args - Arguments to create many RetryAttempts.
     * @example
     * // Create many RetryAttempts
     * const retryAttempt = await prisma.retryAttempt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RetryAttempts and only return the `id`
     * const retryAttemptWithIdOnly = await prisma.retryAttempt.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RetryAttemptCreateManyAndReturnArgs>(args?: SelectSubset<T, RetryAttemptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RetryAttemptPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RetryAttempt.
     * @param {RetryAttemptDeleteArgs} args - Arguments to delete one RetryAttempt.
     * @example
     * // Delete one RetryAttempt
     * const RetryAttempt = await prisma.retryAttempt.delete({
     *   where: {
     *     // ... filter to delete one RetryAttempt
     *   }
     * })
     * 
     */
    delete<T extends RetryAttemptDeleteArgs>(args: SelectSubset<T, RetryAttemptDeleteArgs<ExtArgs>>): Prisma__RetryAttemptClient<$Result.GetResult<Prisma.$RetryAttemptPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RetryAttempt.
     * @param {RetryAttemptUpdateArgs} args - Arguments to update one RetryAttempt.
     * @example
     * // Update one RetryAttempt
     * const retryAttempt = await prisma.retryAttempt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RetryAttemptUpdateArgs>(args: SelectSubset<T, RetryAttemptUpdateArgs<ExtArgs>>): Prisma__RetryAttemptClient<$Result.GetResult<Prisma.$RetryAttemptPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RetryAttempts.
     * @param {RetryAttemptDeleteManyArgs} args - Arguments to filter RetryAttempts to delete.
     * @example
     * // Delete a few RetryAttempts
     * const { count } = await prisma.retryAttempt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RetryAttemptDeleteManyArgs>(args?: SelectSubset<T, RetryAttemptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RetryAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetryAttemptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RetryAttempts
     * const retryAttempt = await prisma.retryAttempt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RetryAttemptUpdateManyArgs>(args: SelectSubset<T, RetryAttemptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RetryAttempt.
     * @param {RetryAttemptUpsertArgs} args - Arguments to update or create a RetryAttempt.
     * @example
     * // Update or create a RetryAttempt
     * const retryAttempt = await prisma.retryAttempt.upsert({
     *   create: {
     *     // ... data to create a RetryAttempt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RetryAttempt we want to update
     *   }
     * })
     */
    upsert<T extends RetryAttemptUpsertArgs>(args: SelectSubset<T, RetryAttemptUpsertArgs<ExtArgs>>): Prisma__RetryAttemptClient<$Result.GetResult<Prisma.$RetryAttemptPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RetryAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetryAttemptCountArgs} args - Arguments to filter RetryAttempts to count.
     * @example
     * // Count the number of RetryAttempts
     * const count = await prisma.retryAttempt.count({
     *   where: {
     *     // ... the filter for the RetryAttempts we want to count
     *   }
     * })
    **/
    count<T extends RetryAttemptCountArgs>(
      args?: Subset<T, RetryAttemptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RetryAttemptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RetryAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetryAttemptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RetryAttemptAggregateArgs>(args: Subset<T, RetryAttemptAggregateArgs>): Prisma.PrismaPromise<GetRetryAttemptAggregateType<T>>

    /**
     * Group by RetryAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetryAttemptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RetryAttemptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RetryAttemptGroupByArgs['orderBy'] }
        : { orderBy?: RetryAttemptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RetryAttemptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRetryAttemptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RetryAttempt model
   */
  readonly fields: RetryAttemptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RetryAttempt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RetryAttemptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RetryAttempt model
   */ 
  interface RetryAttemptFieldRefs {
    readonly id: FieldRef<"RetryAttempt", 'String'>
    readonly invoiceId: FieldRef<"RetryAttempt", 'String'>
    readonly userId: FieldRef<"RetryAttempt", 'String'>
    readonly attempts: FieldRef<"RetryAttempt", 'Int'>
    readonly lastAttemptAt: FieldRef<"RetryAttempt", 'DateTime'>
    readonly status: FieldRef<"RetryAttempt", 'String'>
    readonly createdAt: FieldRef<"RetryAttempt", 'DateTime'>
    readonly updatedAt: FieldRef<"RetryAttempt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RetryAttempt findUnique
   */
  export type RetryAttemptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetryAttempt
     */
    select?: RetryAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetryAttemptInclude<ExtArgs> | null
    /**
     * Filter, which RetryAttempt to fetch.
     */
    where: RetryAttemptWhereUniqueInput
  }

  /**
   * RetryAttempt findUniqueOrThrow
   */
  export type RetryAttemptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetryAttempt
     */
    select?: RetryAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetryAttemptInclude<ExtArgs> | null
    /**
     * Filter, which RetryAttempt to fetch.
     */
    where: RetryAttemptWhereUniqueInput
  }

  /**
   * RetryAttempt findFirst
   */
  export type RetryAttemptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetryAttempt
     */
    select?: RetryAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetryAttemptInclude<ExtArgs> | null
    /**
     * Filter, which RetryAttempt to fetch.
     */
    where?: RetryAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RetryAttempts to fetch.
     */
    orderBy?: RetryAttemptOrderByWithRelationInput | RetryAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RetryAttempts.
     */
    cursor?: RetryAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RetryAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RetryAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RetryAttempts.
     */
    distinct?: RetryAttemptScalarFieldEnum | RetryAttemptScalarFieldEnum[]
  }

  /**
   * RetryAttempt findFirstOrThrow
   */
  export type RetryAttemptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetryAttempt
     */
    select?: RetryAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetryAttemptInclude<ExtArgs> | null
    /**
     * Filter, which RetryAttempt to fetch.
     */
    where?: RetryAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RetryAttempts to fetch.
     */
    orderBy?: RetryAttemptOrderByWithRelationInput | RetryAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RetryAttempts.
     */
    cursor?: RetryAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RetryAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RetryAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RetryAttempts.
     */
    distinct?: RetryAttemptScalarFieldEnum | RetryAttemptScalarFieldEnum[]
  }

  /**
   * RetryAttempt findMany
   */
  export type RetryAttemptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetryAttempt
     */
    select?: RetryAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetryAttemptInclude<ExtArgs> | null
    /**
     * Filter, which RetryAttempts to fetch.
     */
    where?: RetryAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RetryAttempts to fetch.
     */
    orderBy?: RetryAttemptOrderByWithRelationInput | RetryAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RetryAttempts.
     */
    cursor?: RetryAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RetryAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RetryAttempts.
     */
    skip?: number
    distinct?: RetryAttemptScalarFieldEnum | RetryAttemptScalarFieldEnum[]
  }

  /**
   * RetryAttempt create
   */
  export type RetryAttemptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetryAttempt
     */
    select?: RetryAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetryAttemptInclude<ExtArgs> | null
    /**
     * The data needed to create a RetryAttempt.
     */
    data: XOR<RetryAttemptCreateInput, RetryAttemptUncheckedCreateInput>
  }

  /**
   * RetryAttempt createMany
   */
  export type RetryAttemptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RetryAttempts.
     */
    data: RetryAttemptCreateManyInput | RetryAttemptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RetryAttempt createManyAndReturn
   */
  export type RetryAttemptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetryAttempt
     */
    select?: RetryAttemptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RetryAttempts.
     */
    data: RetryAttemptCreateManyInput | RetryAttemptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetryAttemptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RetryAttempt update
   */
  export type RetryAttemptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetryAttempt
     */
    select?: RetryAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetryAttemptInclude<ExtArgs> | null
    /**
     * The data needed to update a RetryAttempt.
     */
    data: XOR<RetryAttemptUpdateInput, RetryAttemptUncheckedUpdateInput>
    /**
     * Choose, which RetryAttempt to update.
     */
    where: RetryAttemptWhereUniqueInput
  }

  /**
   * RetryAttempt updateMany
   */
  export type RetryAttemptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RetryAttempts.
     */
    data: XOR<RetryAttemptUpdateManyMutationInput, RetryAttemptUncheckedUpdateManyInput>
    /**
     * Filter which RetryAttempts to update
     */
    where?: RetryAttemptWhereInput
  }

  /**
   * RetryAttempt upsert
   */
  export type RetryAttemptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetryAttempt
     */
    select?: RetryAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetryAttemptInclude<ExtArgs> | null
    /**
     * The filter to search for the RetryAttempt to update in case it exists.
     */
    where: RetryAttemptWhereUniqueInput
    /**
     * In case the RetryAttempt found by the `where` argument doesn't exist, create a new RetryAttempt with this data.
     */
    create: XOR<RetryAttemptCreateInput, RetryAttemptUncheckedCreateInput>
    /**
     * In case the RetryAttempt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RetryAttemptUpdateInput, RetryAttemptUncheckedUpdateInput>
  }

  /**
   * RetryAttempt delete
   */
  export type RetryAttemptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetryAttempt
     */
    select?: RetryAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetryAttemptInclude<ExtArgs> | null
    /**
     * Filter which RetryAttempt to delete.
     */
    where: RetryAttemptWhereUniqueInput
  }

  /**
   * RetryAttempt deleteMany
   */
  export type RetryAttemptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RetryAttempts to delete
     */
    where?: RetryAttemptWhereInput
  }

  /**
   * RetryAttempt without action
   */
  export type RetryAttemptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetryAttempt
     */
    select?: RetryAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetryAttemptInclude<ExtArgs> | null
  }


  /**
   * Model RetryLog
   */

  export type AggregateRetryLog = {
    _count: RetryLogCountAggregateOutputType | null
    _avg: RetryLogAvgAggregateOutputType | null
    _sum: RetryLogSumAggregateOutputType | null
    _min: RetryLogMinAggregateOutputType | null
    _max: RetryLogMaxAggregateOutputType | null
  }

  export type RetryLogAvgAggregateOutputType = {
    attempts: number | null
  }

  export type RetryLogSumAggregateOutputType = {
    attempts: number | null
  }

  export type RetryLogMinAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    userId: string | null
    status: string | null
    attempts: number | null
    createdAt: Date | null
  }

  export type RetryLogMaxAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    userId: string | null
    status: string | null
    attempts: number | null
    createdAt: Date | null
  }

  export type RetryLogCountAggregateOutputType = {
    id: number
    invoiceId: number
    userId: number
    status: number
    attempts: number
    createdAt: number
    _all: number
  }


  export type RetryLogAvgAggregateInputType = {
    attempts?: true
  }

  export type RetryLogSumAggregateInputType = {
    attempts?: true
  }

  export type RetryLogMinAggregateInputType = {
    id?: true
    invoiceId?: true
    userId?: true
    status?: true
    attempts?: true
    createdAt?: true
  }

  export type RetryLogMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    userId?: true
    status?: true
    attempts?: true
    createdAt?: true
  }

  export type RetryLogCountAggregateInputType = {
    id?: true
    invoiceId?: true
    userId?: true
    status?: true
    attempts?: true
    createdAt?: true
    _all?: true
  }

  export type RetryLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RetryLog to aggregate.
     */
    where?: RetryLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RetryLogs to fetch.
     */
    orderBy?: RetryLogOrderByWithRelationInput | RetryLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RetryLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RetryLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RetryLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RetryLogs
    **/
    _count?: true | RetryLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RetryLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RetryLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RetryLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RetryLogMaxAggregateInputType
  }

  export type GetRetryLogAggregateType<T extends RetryLogAggregateArgs> = {
        [P in keyof T & keyof AggregateRetryLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRetryLog[P]>
      : GetScalarType<T[P], AggregateRetryLog[P]>
  }




  export type RetryLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RetryLogWhereInput
    orderBy?: RetryLogOrderByWithAggregationInput | RetryLogOrderByWithAggregationInput[]
    by: RetryLogScalarFieldEnum[] | RetryLogScalarFieldEnum
    having?: RetryLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RetryLogCountAggregateInputType | true
    _avg?: RetryLogAvgAggregateInputType
    _sum?: RetryLogSumAggregateInputType
    _min?: RetryLogMinAggregateInputType
    _max?: RetryLogMaxAggregateInputType
  }

  export type RetryLogGroupByOutputType = {
    id: string
    invoiceId: string
    userId: string
    status: string
    attempts: number
    createdAt: Date
    _count: RetryLogCountAggregateOutputType | null
    _avg: RetryLogAvgAggregateOutputType | null
    _sum: RetryLogSumAggregateOutputType | null
    _min: RetryLogMinAggregateOutputType | null
    _max: RetryLogMaxAggregateOutputType | null
  }

  type GetRetryLogGroupByPayload<T extends RetryLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RetryLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RetryLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RetryLogGroupByOutputType[P]>
            : GetScalarType<T[P], RetryLogGroupByOutputType[P]>
        }
      >
    >


  export type RetryLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    userId?: boolean
    status?: boolean
    attempts?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["retryLog"]>

  export type RetryLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    userId?: boolean
    status?: boolean
    attempts?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["retryLog"]>

  export type RetryLogSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    userId?: boolean
    status?: boolean
    attempts?: boolean
    createdAt?: boolean
  }


  export type $RetryLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RetryLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceId: string
      userId: string
      status: string
      attempts: number
      createdAt: Date
    }, ExtArgs["result"]["retryLog"]>
    composites: {}
  }

  type RetryLogGetPayload<S extends boolean | null | undefined | RetryLogDefaultArgs> = $Result.GetResult<Prisma.$RetryLogPayload, S>

  type RetryLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RetryLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RetryLogCountAggregateInputType | true
    }

  export interface RetryLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RetryLog'], meta: { name: 'RetryLog' } }
    /**
     * Find zero or one RetryLog that matches the filter.
     * @param {RetryLogFindUniqueArgs} args - Arguments to find a RetryLog
     * @example
     * // Get one RetryLog
     * const retryLog = await prisma.retryLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RetryLogFindUniqueArgs>(args: SelectSubset<T, RetryLogFindUniqueArgs<ExtArgs>>): Prisma__RetryLogClient<$Result.GetResult<Prisma.$RetryLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RetryLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RetryLogFindUniqueOrThrowArgs} args - Arguments to find a RetryLog
     * @example
     * // Get one RetryLog
     * const retryLog = await prisma.retryLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RetryLogFindUniqueOrThrowArgs>(args: SelectSubset<T, RetryLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RetryLogClient<$Result.GetResult<Prisma.$RetryLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RetryLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetryLogFindFirstArgs} args - Arguments to find a RetryLog
     * @example
     * // Get one RetryLog
     * const retryLog = await prisma.retryLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RetryLogFindFirstArgs>(args?: SelectSubset<T, RetryLogFindFirstArgs<ExtArgs>>): Prisma__RetryLogClient<$Result.GetResult<Prisma.$RetryLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RetryLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetryLogFindFirstOrThrowArgs} args - Arguments to find a RetryLog
     * @example
     * // Get one RetryLog
     * const retryLog = await prisma.retryLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RetryLogFindFirstOrThrowArgs>(args?: SelectSubset<T, RetryLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__RetryLogClient<$Result.GetResult<Prisma.$RetryLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RetryLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetryLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RetryLogs
     * const retryLogs = await prisma.retryLog.findMany()
     * 
     * // Get first 10 RetryLogs
     * const retryLogs = await prisma.retryLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const retryLogWithIdOnly = await prisma.retryLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RetryLogFindManyArgs>(args?: SelectSubset<T, RetryLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RetryLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RetryLog.
     * @param {RetryLogCreateArgs} args - Arguments to create a RetryLog.
     * @example
     * // Create one RetryLog
     * const RetryLog = await prisma.retryLog.create({
     *   data: {
     *     // ... data to create a RetryLog
     *   }
     * })
     * 
     */
    create<T extends RetryLogCreateArgs>(args: SelectSubset<T, RetryLogCreateArgs<ExtArgs>>): Prisma__RetryLogClient<$Result.GetResult<Prisma.$RetryLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RetryLogs.
     * @param {RetryLogCreateManyArgs} args - Arguments to create many RetryLogs.
     * @example
     * // Create many RetryLogs
     * const retryLog = await prisma.retryLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RetryLogCreateManyArgs>(args?: SelectSubset<T, RetryLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RetryLogs and returns the data saved in the database.
     * @param {RetryLogCreateManyAndReturnArgs} args - Arguments to create many RetryLogs.
     * @example
     * // Create many RetryLogs
     * const retryLog = await prisma.retryLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RetryLogs and only return the `id`
     * const retryLogWithIdOnly = await prisma.retryLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RetryLogCreateManyAndReturnArgs>(args?: SelectSubset<T, RetryLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RetryLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RetryLog.
     * @param {RetryLogDeleteArgs} args - Arguments to delete one RetryLog.
     * @example
     * // Delete one RetryLog
     * const RetryLog = await prisma.retryLog.delete({
     *   where: {
     *     // ... filter to delete one RetryLog
     *   }
     * })
     * 
     */
    delete<T extends RetryLogDeleteArgs>(args: SelectSubset<T, RetryLogDeleteArgs<ExtArgs>>): Prisma__RetryLogClient<$Result.GetResult<Prisma.$RetryLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RetryLog.
     * @param {RetryLogUpdateArgs} args - Arguments to update one RetryLog.
     * @example
     * // Update one RetryLog
     * const retryLog = await prisma.retryLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RetryLogUpdateArgs>(args: SelectSubset<T, RetryLogUpdateArgs<ExtArgs>>): Prisma__RetryLogClient<$Result.GetResult<Prisma.$RetryLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RetryLogs.
     * @param {RetryLogDeleteManyArgs} args - Arguments to filter RetryLogs to delete.
     * @example
     * // Delete a few RetryLogs
     * const { count } = await prisma.retryLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RetryLogDeleteManyArgs>(args?: SelectSubset<T, RetryLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RetryLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetryLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RetryLogs
     * const retryLog = await prisma.retryLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RetryLogUpdateManyArgs>(args: SelectSubset<T, RetryLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RetryLog.
     * @param {RetryLogUpsertArgs} args - Arguments to update or create a RetryLog.
     * @example
     * // Update or create a RetryLog
     * const retryLog = await prisma.retryLog.upsert({
     *   create: {
     *     // ... data to create a RetryLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RetryLog we want to update
     *   }
     * })
     */
    upsert<T extends RetryLogUpsertArgs>(args: SelectSubset<T, RetryLogUpsertArgs<ExtArgs>>): Prisma__RetryLogClient<$Result.GetResult<Prisma.$RetryLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RetryLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetryLogCountArgs} args - Arguments to filter RetryLogs to count.
     * @example
     * // Count the number of RetryLogs
     * const count = await prisma.retryLog.count({
     *   where: {
     *     // ... the filter for the RetryLogs we want to count
     *   }
     * })
    **/
    count<T extends RetryLogCountArgs>(
      args?: Subset<T, RetryLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RetryLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RetryLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetryLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RetryLogAggregateArgs>(args: Subset<T, RetryLogAggregateArgs>): Prisma.PrismaPromise<GetRetryLogAggregateType<T>>

    /**
     * Group by RetryLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetryLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RetryLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RetryLogGroupByArgs['orderBy'] }
        : { orderBy?: RetryLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RetryLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRetryLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RetryLog model
   */
  readonly fields: RetryLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RetryLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RetryLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RetryLog model
   */ 
  interface RetryLogFieldRefs {
    readonly id: FieldRef<"RetryLog", 'String'>
    readonly invoiceId: FieldRef<"RetryLog", 'String'>
    readonly userId: FieldRef<"RetryLog", 'String'>
    readonly status: FieldRef<"RetryLog", 'String'>
    readonly attempts: FieldRef<"RetryLog", 'Int'>
    readonly createdAt: FieldRef<"RetryLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RetryLog findUnique
   */
  export type RetryLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetryLog
     */
    select?: RetryLogSelect<ExtArgs> | null
    /**
     * Filter, which RetryLog to fetch.
     */
    where: RetryLogWhereUniqueInput
  }

  /**
   * RetryLog findUniqueOrThrow
   */
  export type RetryLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetryLog
     */
    select?: RetryLogSelect<ExtArgs> | null
    /**
     * Filter, which RetryLog to fetch.
     */
    where: RetryLogWhereUniqueInput
  }

  /**
   * RetryLog findFirst
   */
  export type RetryLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetryLog
     */
    select?: RetryLogSelect<ExtArgs> | null
    /**
     * Filter, which RetryLog to fetch.
     */
    where?: RetryLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RetryLogs to fetch.
     */
    orderBy?: RetryLogOrderByWithRelationInput | RetryLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RetryLogs.
     */
    cursor?: RetryLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RetryLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RetryLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RetryLogs.
     */
    distinct?: RetryLogScalarFieldEnum | RetryLogScalarFieldEnum[]
  }

  /**
   * RetryLog findFirstOrThrow
   */
  export type RetryLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetryLog
     */
    select?: RetryLogSelect<ExtArgs> | null
    /**
     * Filter, which RetryLog to fetch.
     */
    where?: RetryLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RetryLogs to fetch.
     */
    orderBy?: RetryLogOrderByWithRelationInput | RetryLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RetryLogs.
     */
    cursor?: RetryLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RetryLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RetryLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RetryLogs.
     */
    distinct?: RetryLogScalarFieldEnum | RetryLogScalarFieldEnum[]
  }

  /**
   * RetryLog findMany
   */
  export type RetryLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetryLog
     */
    select?: RetryLogSelect<ExtArgs> | null
    /**
     * Filter, which RetryLogs to fetch.
     */
    where?: RetryLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RetryLogs to fetch.
     */
    orderBy?: RetryLogOrderByWithRelationInput | RetryLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RetryLogs.
     */
    cursor?: RetryLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RetryLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RetryLogs.
     */
    skip?: number
    distinct?: RetryLogScalarFieldEnum | RetryLogScalarFieldEnum[]
  }

  /**
   * RetryLog create
   */
  export type RetryLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetryLog
     */
    select?: RetryLogSelect<ExtArgs> | null
    /**
     * The data needed to create a RetryLog.
     */
    data: XOR<RetryLogCreateInput, RetryLogUncheckedCreateInput>
  }

  /**
   * RetryLog createMany
   */
  export type RetryLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RetryLogs.
     */
    data: RetryLogCreateManyInput | RetryLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RetryLog createManyAndReturn
   */
  export type RetryLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetryLog
     */
    select?: RetryLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RetryLogs.
     */
    data: RetryLogCreateManyInput | RetryLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RetryLog update
   */
  export type RetryLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetryLog
     */
    select?: RetryLogSelect<ExtArgs> | null
    /**
     * The data needed to update a RetryLog.
     */
    data: XOR<RetryLogUpdateInput, RetryLogUncheckedUpdateInput>
    /**
     * Choose, which RetryLog to update.
     */
    where: RetryLogWhereUniqueInput
  }

  /**
   * RetryLog updateMany
   */
  export type RetryLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RetryLogs.
     */
    data: XOR<RetryLogUpdateManyMutationInput, RetryLogUncheckedUpdateManyInput>
    /**
     * Filter which RetryLogs to update
     */
    where?: RetryLogWhereInput
  }

  /**
   * RetryLog upsert
   */
  export type RetryLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetryLog
     */
    select?: RetryLogSelect<ExtArgs> | null
    /**
     * The filter to search for the RetryLog to update in case it exists.
     */
    where: RetryLogWhereUniqueInput
    /**
     * In case the RetryLog found by the `where` argument doesn't exist, create a new RetryLog with this data.
     */
    create: XOR<RetryLogCreateInput, RetryLogUncheckedCreateInput>
    /**
     * In case the RetryLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RetryLogUpdateInput, RetryLogUncheckedUpdateInput>
  }

  /**
   * RetryLog delete
   */
  export type RetryLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetryLog
     */
    select?: RetryLogSelect<ExtArgs> | null
    /**
     * Filter which RetryLog to delete.
     */
    where: RetryLogWhereUniqueInput
  }

  /**
   * RetryLog deleteMany
   */
  export type RetryLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RetryLogs to delete
     */
    where?: RetryLogWhereInput
  }

  /**
   * RetryLog without action
   */
  export type RetryLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetryLog
     */
    select?: RetryLogSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    role: 'role'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const OrganizationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    stripeCustomerId: 'stripeCustomerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    stripeCustomerId: 'stripeCustomerId',
    name: 'name',
    email: 'email',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    status: 'status',
    planId: 'planId',
    stripeSubscriptionId: 'stripeSubscriptionId',
    currentPeriodStart: 'currentPeriodStart',
    currentPeriodEnd: 'currentPeriodEnd',
    cancelAtPeriodEnd: 'cancelAtPeriodEnd',
    cancelledAt: 'cancelledAt',
    pausedAt: 'pausedAt',
    resumesAt: 'resumesAt',
    trialEndsAt: 'trialEndsAt',
    billingCycleAnchor: 'billingCycleAnchor',
    proration: 'proration',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const PlanScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    basePrice: 'basePrice',
    currentPrice: 'currentPrice',
    currency: 'currency',
    interval: 'interval',
    stripePriceId: 'stripePriceId',
    isActive: 'isActive',
    sortOrder: 'sortOrder',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    marketSegment: 'marketSegment',
    costBasis: 'costBasis',
    churnRisk: 'churnRisk'
  };

  export type PlanScalarFieldEnum = (typeof PlanScalarFieldEnum)[keyof typeof PlanScalarFieldEnum]


  export const PlanFeatureScalarFieldEnum: {
    id: 'id',
    planId: 'planId',
    name: 'name',
    description: 'description',
    included: 'included',
    value: 'value',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlanFeatureScalarFieldEnum = (typeof PlanFeatureScalarFieldEnum)[keyof typeof PlanFeatureScalarFieldEnum]


  export const UsageLimitScalarFieldEnum: {
    id: 'id',
    planId: 'planId',
    featureKey: 'featureKey',
    limit: 'limit',
    interval: 'interval',
    overage: 'overage',
    overagePrice: 'overagePrice',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UsageLimitScalarFieldEnum = (typeof UsageLimitScalarFieldEnum)[keyof typeof UsageLimitScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    amount: 'amount',
    currency: 'currency',
    status: 'status',
    stripeInvoiceId: 'stripeInvoiceId',
    pdfUrl: 'pdfUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const UsageRecordScalarFieldEnum: {
    id: 'id',
    subscriptionId: 'subscriptionId',
    featureKey: 'featureKey',
    quantity: 'quantity',
    timestamp: 'timestamp',
    billingPeriodStart: 'billingPeriodStart',
    billingPeriodEnd: 'billingPeriodEnd',
    processed: 'processed',
    metadata: 'metadata'
  };

  export type UsageRecordScalarFieldEnum = (typeof UsageRecordScalarFieldEnum)[keyof typeof UsageRecordScalarFieldEnum]


  export const ReportScalarFieldEnum: {
    id: 'id',
    type: 'type',
    format: 'format',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    downloadUrl: 'downloadUrl',
    metadata: 'metadata'
  };

  export type ReportScalarFieldEnum = (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum]


  export const MetricScalarFieldEnum: {
    id: 'id',
    name: 'name',
    value: 'value',
    tags: 'tags',
    timestamp: 'timestamp',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MetricScalarFieldEnum = (typeof MetricScalarFieldEnum)[keyof typeof MetricScalarFieldEnum]


  export const EmailNotificationScalarFieldEnum: {
    id: 'id',
    type: 'type',
    status: 'status',
    to: 'to',
    subject: 'subject',
    body: 'body',
    sentAt: 'sentAt',
    createdAt: 'createdAt',
    metadata: 'metadata'
  };

  export type EmailNotificationScalarFieldEnum = (typeof EmailNotificationScalarFieldEnum)[keyof typeof EmailNotificationScalarFieldEnum]


  export const WebhookScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    url: 'url',
    secret: 'secret',
    events: 'events',
    status: 'status',
    retryConfig: 'retryConfig',
    lastSuccess: 'lastSuccess',
    lastFailure: 'lastFailure',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WebhookScalarFieldEnum = (typeof WebhookScalarFieldEnum)[keyof typeof WebhookScalarFieldEnum]


  export const WebhookDeliveryScalarFieldEnum: {
    id: 'id',
    webhookId: 'webhookId',
    payload: 'payload',
    status: 'status',
    statusCode: 'statusCode',
    response: 'response',
    error: 'error',
    retries: 'retries',
    createdAt: 'createdAt'
  };

  export type WebhookDeliveryScalarFieldEnum = (typeof WebhookDeliveryScalarFieldEnum)[keyof typeof WebhookDeliveryScalarFieldEnum]


  export const RefreshTokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    userId: 'userId',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RefreshTokenScalarFieldEnum = (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    currency: 'currency',
    status: 'status',
    stripePaymentId: 'stripePaymentId',
    userId: 'userId',
    customerId: 'customerId',
    subscriptionId: 'subscriptionId',
    orderId: 'orderId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const FinancingOfferScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    currency: 'currency',
    provider: 'provider',
    customerId: 'customerId',
    status: 'status',
    offerId: 'offerId',
    terms: 'terms',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FinancingOfferScalarFieldEnum = (typeof FinancingOfferScalarFieldEnum)[keyof typeof FinancingOfferScalarFieldEnum]


  export const CarbonEstimateScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    amount: 'amount',
    unit: 'unit',
    source: 'source',
    category: 'category',
    timestamp: 'timestamp',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CarbonEstimateScalarFieldEnum = (typeof CarbonEstimateScalarFieldEnum)[keyof typeof CarbonEstimateScalarFieldEnum]


  export const BillingRuleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    type: 'type',
    conditions: 'conditions',
    actions: 'actions',
    priority: 'priority',
    isActive: 'isActive',
    organizationId: 'organizationId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BillingRuleScalarFieldEnum = (typeof BillingRuleScalarFieldEnum)[keyof typeof BillingRuleScalarFieldEnum]


  export const BillingRuleTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    type: 'type',
    conditions: 'conditions',
    actions: 'actions',
    isDefault: 'isDefault',
    organizationId: 'organizationId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BillingRuleTemplateScalarFieldEnum = (typeof BillingRuleTemplateScalarFieldEnum)[keyof typeof BillingRuleTemplateScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    customerId: 'customerId',
    amount: 'amount',
    currency: 'currency',
    status: 'status',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const PriceHistoryScalarFieldEnum: {
    id: 'id',
    planId: 'planId',
    price: 'price',
    effectiveFrom: 'effectiveFrom',
    effectiveTo: 'effectiveTo',
    reason: 'reason',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type PriceHistoryScalarFieldEnum = (typeof PriceHistoryScalarFieldEnum)[keyof typeof PriceHistoryScalarFieldEnum]


  export const PriceTestScalarFieldEnum: {
    id: 'id',
    planId: 'planId',
    name: 'name',
    description: 'description',
    startDate: 'startDate',
    endDate: 'endDate',
    status: 'status',
    targetMetric: 'targetMetric',
    minConfidence: 'minConfidence',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PriceTestScalarFieldEnum = (typeof PriceTestScalarFieldEnum)[keyof typeof PriceTestScalarFieldEnum]


  export const PriceTestVariantScalarFieldEnum: {
    id: 'id',
    testId: 'testId',
    price: 'price',
    name: 'name',
    description: 'description',
    conversionRate: 'conversionRate',
    revenue: 'revenue',
    subscribers: 'subscribers',
    isControl: 'isControl',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PriceTestVariantScalarFieldEnum = (typeof PriceTestVariantScalarFieldEnum)[keyof typeof PriceTestVariantScalarFieldEnum]


  export const MarketBenchmarkScalarFieldEnum: {
    id: 'id',
    segment: 'segment',
    productType: 'productType',
    avgPrice: 'avgPrice',
    medianPrice: 'medianPrice',
    minPrice: 'minPrice',
    maxPrice: 'maxPrice',
    sampleSize: 'sampleSize',
    source: 'source',
    collectedAt: 'collectedAt',
    metadata: 'metadata'
  };

  export type MarketBenchmarkScalarFieldEnum = (typeof MarketBenchmarkScalarFieldEnum)[keyof typeof MarketBenchmarkScalarFieldEnum]


  export const RevenueRecognitionRuleScalarFieldEnum: {
    id: 'id',
    planId: 'planId',
    type: 'type',
    deferralPeriod: 'deferralPeriod',
    conditions: 'conditions',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RevenueRecognitionRuleScalarFieldEnum = (typeof RevenueRecognitionRuleScalarFieldEnum)[keyof typeof RevenueRecognitionRuleScalarFieldEnum]


  export const RevenueLedgerScalarFieldEnum: {
    id: 'id',
    subscriptionId: 'subscriptionId',
    amount: 'amount',
    currency: 'currency',
    recognizedDate: 'recognizedDate',
    deferredAmount: 'deferredAmount',
    deferredUntil: 'deferredUntil',
    type: 'type',
    status: 'status',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RevenueLedgerScalarFieldEnum = (typeof RevenueLedgerScalarFieldEnum)[keyof typeof RevenueLedgerScalarFieldEnum]


  export const ChurnPredictionScalarFieldEnum: {
    id: 'id',
    subscriptionId: 'subscriptionId',
    probability: 'probability',
    factors: 'factors',
    nextBillDate: 'nextBillDate',
    predictedDate: 'predictedDate',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChurnPredictionScalarFieldEnum = (typeof ChurnPredictionScalarFieldEnum)[keyof typeof ChurnPredictionScalarFieldEnum]


  export const CohortAnalysisScalarFieldEnum: {
    id: 'id',
    cohortDate: 'cohortDate',
    cohortSize: 'cohortSize',
    metric: 'metric',
    values: 'values',
    segment: 'segment',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CohortAnalysisScalarFieldEnum = (typeof CohortAnalysisScalarFieldEnum)[keyof typeof CohortAnalysisScalarFieldEnum]


  export const ForecastModelScalarFieldEnum: {
    id: 'id',
    name: 'name',
    config: 'config',
    metadata: 'metadata',
    status: 'status',
    createdAt: 'createdAt',
    lastTraining: 'lastTraining',
    metrics: 'metrics'
  };

  export type ForecastModelScalarFieldEnum = (typeof ForecastModelScalarFieldEnum)[keyof typeof ForecastModelScalarFieldEnum]


  export const TimeSeriesDataScalarFieldEnum: {
    id: 'id',
    timestamp: 'timestamp',
    value: 'value',
    metadata: 'metadata',
    modelId: 'modelId'
  };

  export type TimeSeriesDataScalarFieldEnum = (typeof TimeSeriesDataScalarFieldEnum)[keyof typeof TimeSeriesDataScalarFieldEnum]


  export const ForecastResultScalarFieldEnum: {
    id: 'id',
    timestamp: 'timestamp',
    value: 'value',
    lowerBound: 'lowerBound',
    upperBound: 'upperBound',
    confidence: 'confidence',
    metadata: 'metadata',
    modelId: 'modelId'
  };

  export type ForecastResultScalarFieldEnum = (typeof ForecastResultScalarFieldEnum)[keyof typeof ForecastResultScalarFieldEnum]


  export const MarketTrendScalarFieldEnum: {
    id: 'id',
    timestamp: 'timestamp',
    trend: 'trend',
    seasonality: 'seasonality',
    metadata: 'metadata'
  };

  export type MarketTrendScalarFieldEnum = (typeof MarketTrendScalarFieldEnum)[keyof typeof MarketTrendScalarFieldEnum]


  export const PredictionIntervalScalarFieldEnum: {
    id: 'id',
    timestamp: 'timestamp',
    lowerBound: 'lowerBound',
    upperBound: 'upperBound',
    confidence: 'confidence',
    metadata: 'metadata'
  };

  export type PredictionIntervalScalarFieldEnum = (typeof PredictionIntervalScalarFieldEnum)[keyof typeof PredictionIntervalScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    organizationId: 'organizationId',
    type: 'type',
    message: 'message',
    read: 'read',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const ApiKeyScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    name: 'name',
    key: 'key',
    lastUsed: 'lastUsed',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ApiKeyScalarFieldEnum = (typeof ApiKeyScalarFieldEnum)[keyof typeof ApiKeyScalarFieldEnum]


  export const TaxCalculationScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    amount: 'amount',
    taxRate: 'taxRate',
    taxAmount: 'taxAmount',
    country: 'country',
    state: 'state',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TaxCalculationScalarFieldEnum = (typeof TaxCalculationScalarFieldEnum)[keyof typeof TaxCalculationScalarFieldEnum]


  export const AlertScalarFieldEnum: {
    id: 'id',
    type: 'type',
    message: 'message',
    severity: 'severity',
    metadata: 'metadata',
    resolved: 'resolved',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AlertScalarFieldEnum = (typeof AlertScalarFieldEnum)[keyof typeof AlertScalarFieldEnum]


  export const TaxRateScalarFieldEnum: {
    id: 'id',
    countryCode: 'countryCode',
    stateCode: 'stateCode',
    name: 'name',
    rate: 'rate',
    isActive: 'isActive',
    isEU: 'isEU',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TaxRateScalarFieldEnum = (typeof TaxRateScalarFieldEnum)[keyof typeof TaxRateScalarFieldEnum]


  export const BillScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    description: 'description',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BillScalarFieldEnum = (typeof BillScalarFieldEnum)[keyof typeof BillScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    type: 'type',
    status: 'status',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const RetryAttemptScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    userId: 'userId',
    attempts: 'attempts',
    lastAttemptAt: 'lastAttemptAt',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RetryAttemptScalarFieldEnum = (typeof RetryAttemptScalarFieldEnum)[keyof typeof RetryAttemptScalarFieldEnum]


  export const RetryLogScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    userId: 'userId',
    status: 'status',
    attempts: 'attempts',
    createdAt: 'createdAt'
  };

  export type RetryLogScalarFieldEnum = (typeof RetryLogScalarFieldEnum)[keyof typeof RetryLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus'
   */
  export type EnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus[]'
   */
  export type ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json[]'
   */
  export type ListJsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    role?: StringFilter<"User"> | string
    notifications?: NotificationListRelationFilter
    refreshTokens?: RefreshTokenListRelationFilter
    payments?: PaymentListRelationFilter
    retryAttempts?: RetryAttemptListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: SortOrder
    notifications?: NotificationOrderByRelationAggregateInput
    refreshTokens?: RefreshTokenOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    retryAttempts?: RetryAttemptOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    role?: StringFilter<"User"> | string
    notifications?: NotificationListRelationFilter
    refreshTokens?: RefreshTokenListRelationFilter
    payments?: PaymentListRelationFilter
    retryAttempts?: RetryAttemptListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    role?: StringWithAggregatesFilter<"User"> | string
  }

  export type OrganizationWhereInput = {
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    id?: StringFilter<"Organization"> | string
    name?: StringFilter<"Organization"> | string
    email?: StringNullableFilter<"Organization"> | string | null
    stripeCustomerId?: StringNullableFilter<"Organization"> | string | null
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    notifications?: NotificationListRelationFilter
    webhooks?: WebhookListRelationFilter
    apiKeys?: ApiKeyListRelationFilter
    carbonEstimates?: CarbonEstimateListRelationFilter
    billingRules?: BillingRuleListRelationFilter
    billingTemplates?: BillingRuleTemplateListRelationFilter
    orders?: OrderListRelationFilter
  }

  export type OrganizationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    notifications?: NotificationOrderByRelationAggregateInput
    webhooks?: WebhookOrderByRelationAggregateInput
    apiKeys?: ApiKeyOrderByRelationAggregateInput
    carbonEstimates?: CarbonEstimateOrderByRelationAggregateInput
    billingRules?: BillingRuleOrderByRelationAggregateInput
    billingTemplates?: BillingRuleTemplateOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
  }

  export type OrganizationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    name?: StringFilter<"Organization"> | string
    email?: StringNullableFilter<"Organization"> | string | null
    stripeCustomerId?: StringNullableFilter<"Organization"> | string | null
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    notifications?: NotificationListRelationFilter
    webhooks?: WebhookListRelationFilter
    apiKeys?: ApiKeyListRelationFilter
    carbonEstimates?: CarbonEstimateListRelationFilter
    billingRules?: BillingRuleListRelationFilter
    billingTemplates?: BillingRuleTemplateListRelationFilter
    orders?: OrderListRelationFilter
  }, "id">

  export type OrganizationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrganizationCountOrderByAggregateInput
    _max?: OrganizationMaxOrderByAggregateInput
    _min?: OrganizationMinOrderByAggregateInput
  }

  export type OrganizationScalarWhereWithAggregatesInput = {
    AND?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    OR?: OrganizationScalarWhereWithAggregatesInput[]
    NOT?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Organization"> | string
    name?: StringWithAggregatesFilter<"Organization"> | string
    email?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    stripeCustomerId?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: StringFilter<"Customer"> | string
    userId?: StringFilter<"Customer"> | string
    stripeCustomerId?: StringNullableFilter<"Customer"> | string | null
    name?: StringNullableFilter<"Customer"> | string | null
    email?: StringFilter<"Customer"> | string
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    payments?: PaymentListRelationFilter
    subscription?: XOR<SubscriptionNullableRelationFilter, SubscriptionWhereInput> | null
    taxCalculations?: TaxCalculationListRelationFilter
    orders?: OrderListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    payments?: PaymentOrderByRelationAggregateInput
    subscription?: SubscriptionOrderByWithRelationInput
    taxCalculations?: TaxCalculationOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    stripeCustomerId?: string
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    userId?: StringFilter<"Customer"> | string
    name?: StringNullableFilter<"Customer"> | string | null
    email?: StringFilter<"Customer"> | string
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    payments?: PaymentListRelationFilter
    subscription?: XOR<SubscriptionNullableRelationFilter, SubscriptionWhereInput> | null
    taxCalculations?: TaxCalculationListRelationFilter
    orders?: OrderListRelationFilter
  }, "id" | "stripeCustomerId">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Customer"> | string
    userId?: StringWithAggregatesFilter<"Customer"> | string
    stripeCustomerId?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    name?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    email?: StringWithAggregatesFilter<"Customer"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: StringFilter<"Subscription"> | string
    customerId?: StringFilter<"Subscription"> | string
    status?: EnumSubscriptionStatusFilter<"Subscription"> | $Enums.SubscriptionStatus
    planId?: StringFilter<"Subscription"> | string
    stripeSubscriptionId?: StringNullableFilter<"Subscription"> | string | null
    currentPeriodStart?: DateTimeFilter<"Subscription"> | Date | string
    currentPeriodEnd?: DateTimeFilter<"Subscription"> | Date | string
    cancelAtPeriodEnd?: BoolFilter<"Subscription"> | boolean
    cancelledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    pausedAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    resumesAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    trialEndsAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    billingCycleAnchor?: DateTimeFilter<"Subscription"> | Date | string
    proration?: JsonNullableFilter<"Subscription">
    metadata?: JsonNullableFilter<"Subscription">
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    plan?: XOR<PlanRelationFilter, PlanWhereInput>
    payments?: PaymentListRelationFilter
    usageRecords?: UsageRecordListRelationFilter
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    status?: SortOrder
    planId?: SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    pausedAt?: SortOrderInput | SortOrder
    resumesAt?: SortOrderInput | SortOrder
    trialEndsAt?: SortOrderInput | SortOrder
    billingCycleAnchor?: SortOrder
    proration?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    plan?: PlanOrderByWithRelationInput
    payments?: PaymentOrderByRelationAggregateInput
    usageRecords?: UsageRecordOrderByRelationAggregateInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    customerId?: string
    stripeSubscriptionId?: string
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    status?: EnumSubscriptionStatusFilter<"Subscription"> | $Enums.SubscriptionStatus
    planId?: StringFilter<"Subscription"> | string
    currentPeriodStart?: DateTimeFilter<"Subscription"> | Date | string
    currentPeriodEnd?: DateTimeFilter<"Subscription"> | Date | string
    cancelAtPeriodEnd?: BoolFilter<"Subscription"> | boolean
    cancelledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    pausedAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    resumesAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    trialEndsAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    billingCycleAnchor?: DateTimeFilter<"Subscription"> | Date | string
    proration?: JsonNullableFilter<"Subscription">
    metadata?: JsonNullableFilter<"Subscription">
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    plan?: XOR<PlanRelationFilter, PlanWhereInput>
    payments?: PaymentListRelationFilter
    usageRecords?: UsageRecordListRelationFilter
  }, "id" | "customerId" | "stripeSubscriptionId">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    status?: SortOrder
    planId?: SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    pausedAt?: SortOrderInput | SortOrder
    resumesAt?: SortOrderInput | SortOrder
    trialEndsAt?: SortOrderInput | SortOrder
    billingCycleAnchor?: SortOrder
    proration?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subscription"> | string
    customerId?: StringWithAggregatesFilter<"Subscription"> | string
    status?: EnumSubscriptionStatusWithAggregatesFilter<"Subscription"> | $Enums.SubscriptionStatus
    planId?: StringWithAggregatesFilter<"Subscription"> | string
    stripeSubscriptionId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    currentPeriodStart?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    currentPeriodEnd?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    cancelAtPeriodEnd?: BoolWithAggregatesFilter<"Subscription"> | boolean
    cancelledAt?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    pausedAt?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    resumesAt?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    trialEndsAt?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    billingCycleAnchor?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    proration?: JsonNullableWithAggregatesFilter<"Subscription">
    metadata?: JsonNullableWithAggregatesFilter<"Subscription">
    createdAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
  }

  export type PlanWhereInput = {
    AND?: PlanWhereInput | PlanWhereInput[]
    OR?: PlanWhereInput[]
    NOT?: PlanWhereInput | PlanWhereInput[]
    id?: StringFilter<"Plan"> | string
    name?: StringFilter<"Plan"> | string
    description?: StringNullableFilter<"Plan"> | string | null
    basePrice?: FloatFilter<"Plan"> | number
    currentPrice?: FloatFilter<"Plan"> | number
    currency?: StringFilter<"Plan"> | string
    interval?: StringFilter<"Plan"> | string
    stripePriceId?: StringNullableFilter<"Plan"> | string | null
    isActive?: BoolFilter<"Plan"> | boolean
    sortOrder?: IntFilter<"Plan"> | number
    metadata?: JsonNullableFilter<"Plan">
    createdAt?: DateTimeFilter<"Plan"> | Date | string
    updatedAt?: DateTimeFilter<"Plan"> | Date | string
    marketSegment?: StringNullableFilter<"Plan"> | string | null
    costBasis?: FloatNullableFilter<"Plan"> | number | null
    churnRisk?: FloatNullableFilter<"Plan"> | number | null
    features?: PlanFeatureListRelationFilter
    usageLimits?: UsageLimitListRelationFilter
    priceHistory?: PriceHistoryListRelationFilter
    priceTests?: PriceTestListRelationFilter
    revenueRules?: RevenueRecognitionRuleListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
  }

  export type PlanOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    basePrice?: SortOrder
    currentPrice?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    stripePriceId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    marketSegment?: SortOrderInput | SortOrder
    costBasis?: SortOrderInput | SortOrder
    churnRisk?: SortOrderInput | SortOrder
    features?: PlanFeatureOrderByRelationAggregateInput
    usageLimits?: UsageLimitOrderByRelationAggregateInput
    priceHistory?: PriceHistoryOrderByRelationAggregateInput
    priceTests?: PriceTestOrderByRelationAggregateInput
    revenueRules?: RevenueRecognitionRuleOrderByRelationAggregateInput
    subscriptions?: SubscriptionOrderByRelationAggregateInput
  }

  export type PlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PlanWhereInput | PlanWhereInput[]
    OR?: PlanWhereInput[]
    NOT?: PlanWhereInput | PlanWhereInput[]
    name?: StringFilter<"Plan"> | string
    description?: StringNullableFilter<"Plan"> | string | null
    basePrice?: FloatFilter<"Plan"> | number
    currentPrice?: FloatFilter<"Plan"> | number
    currency?: StringFilter<"Plan"> | string
    interval?: StringFilter<"Plan"> | string
    stripePriceId?: StringNullableFilter<"Plan"> | string | null
    isActive?: BoolFilter<"Plan"> | boolean
    sortOrder?: IntFilter<"Plan"> | number
    metadata?: JsonNullableFilter<"Plan">
    createdAt?: DateTimeFilter<"Plan"> | Date | string
    updatedAt?: DateTimeFilter<"Plan"> | Date | string
    marketSegment?: StringNullableFilter<"Plan"> | string | null
    costBasis?: FloatNullableFilter<"Plan"> | number | null
    churnRisk?: FloatNullableFilter<"Plan"> | number | null
    features?: PlanFeatureListRelationFilter
    usageLimits?: UsageLimitListRelationFilter
    priceHistory?: PriceHistoryListRelationFilter
    priceTests?: PriceTestListRelationFilter
    revenueRules?: RevenueRecognitionRuleListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
  }, "id">

  export type PlanOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    basePrice?: SortOrder
    currentPrice?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    stripePriceId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    marketSegment?: SortOrderInput | SortOrder
    costBasis?: SortOrderInput | SortOrder
    churnRisk?: SortOrderInput | SortOrder
    _count?: PlanCountOrderByAggregateInput
    _avg?: PlanAvgOrderByAggregateInput
    _max?: PlanMaxOrderByAggregateInput
    _min?: PlanMinOrderByAggregateInput
    _sum?: PlanSumOrderByAggregateInput
  }

  export type PlanScalarWhereWithAggregatesInput = {
    AND?: PlanScalarWhereWithAggregatesInput | PlanScalarWhereWithAggregatesInput[]
    OR?: PlanScalarWhereWithAggregatesInput[]
    NOT?: PlanScalarWhereWithAggregatesInput | PlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Plan"> | string
    name?: StringWithAggregatesFilter<"Plan"> | string
    description?: StringNullableWithAggregatesFilter<"Plan"> | string | null
    basePrice?: FloatWithAggregatesFilter<"Plan"> | number
    currentPrice?: FloatWithAggregatesFilter<"Plan"> | number
    currency?: StringWithAggregatesFilter<"Plan"> | string
    interval?: StringWithAggregatesFilter<"Plan"> | string
    stripePriceId?: StringNullableWithAggregatesFilter<"Plan"> | string | null
    isActive?: BoolWithAggregatesFilter<"Plan"> | boolean
    sortOrder?: IntWithAggregatesFilter<"Plan"> | number
    metadata?: JsonNullableWithAggregatesFilter<"Plan">
    createdAt?: DateTimeWithAggregatesFilter<"Plan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Plan"> | Date | string
    marketSegment?: StringNullableWithAggregatesFilter<"Plan"> | string | null
    costBasis?: FloatNullableWithAggregatesFilter<"Plan"> | number | null
    churnRisk?: FloatNullableWithAggregatesFilter<"Plan"> | number | null
  }

  export type PlanFeatureWhereInput = {
    AND?: PlanFeatureWhereInput | PlanFeatureWhereInput[]
    OR?: PlanFeatureWhereInput[]
    NOT?: PlanFeatureWhereInput | PlanFeatureWhereInput[]
    id?: StringFilter<"PlanFeature"> | string
    planId?: StringFilter<"PlanFeature"> | string
    name?: StringFilter<"PlanFeature"> | string
    description?: StringNullableFilter<"PlanFeature"> | string | null
    included?: BoolFilter<"PlanFeature"> | boolean
    value?: StringNullableFilter<"PlanFeature"> | string | null
    sortOrder?: IntFilter<"PlanFeature"> | number
    createdAt?: DateTimeFilter<"PlanFeature"> | Date | string
    updatedAt?: DateTimeFilter<"PlanFeature"> | Date | string
    plan?: XOR<PlanRelationFilter, PlanWhereInput>
  }

  export type PlanFeatureOrderByWithRelationInput = {
    id?: SortOrder
    planId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    included?: SortOrder
    value?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    plan?: PlanOrderByWithRelationInput
  }

  export type PlanFeatureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PlanFeatureWhereInput | PlanFeatureWhereInput[]
    OR?: PlanFeatureWhereInput[]
    NOT?: PlanFeatureWhereInput | PlanFeatureWhereInput[]
    planId?: StringFilter<"PlanFeature"> | string
    name?: StringFilter<"PlanFeature"> | string
    description?: StringNullableFilter<"PlanFeature"> | string | null
    included?: BoolFilter<"PlanFeature"> | boolean
    value?: StringNullableFilter<"PlanFeature"> | string | null
    sortOrder?: IntFilter<"PlanFeature"> | number
    createdAt?: DateTimeFilter<"PlanFeature"> | Date | string
    updatedAt?: DateTimeFilter<"PlanFeature"> | Date | string
    plan?: XOR<PlanRelationFilter, PlanWhereInput>
  }, "id">

  export type PlanFeatureOrderByWithAggregationInput = {
    id?: SortOrder
    planId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    included?: SortOrder
    value?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlanFeatureCountOrderByAggregateInput
    _avg?: PlanFeatureAvgOrderByAggregateInput
    _max?: PlanFeatureMaxOrderByAggregateInput
    _min?: PlanFeatureMinOrderByAggregateInput
    _sum?: PlanFeatureSumOrderByAggregateInput
  }

  export type PlanFeatureScalarWhereWithAggregatesInput = {
    AND?: PlanFeatureScalarWhereWithAggregatesInput | PlanFeatureScalarWhereWithAggregatesInput[]
    OR?: PlanFeatureScalarWhereWithAggregatesInput[]
    NOT?: PlanFeatureScalarWhereWithAggregatesInput | PlanFeatureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlanFeature"> | string
    planId?: StringWithAggregatesFilter<"PlanFeature"> | string
    name?: StringWithAggregatesFilter<"PlanFeature"> | string
    description?: StringNullableWithAggregatesFilter<"PlanFeature"> | string | null
    included?: BoolWithAggregatesFilter<"PlanFeature"> | boolean
    value?: StringNullableWithAggregatesFilter<"PlanFeature"> | string | null
    sortOrder?: IntWithAggregatesFilter<"PlanFeature"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PlanFeature"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PlanFeature"> | Date | string
  }

  export type UsageLimitWhereInput = {
    AND?: UsageLimitWhereInput | UsageLimitWhereInput[]
    OR?: UsageLimitWhereInput[]
    NOT?: UsageLimitWhereInput | UsageLimitWhereInput[]
    id?: StringFilter<"UsageLimit"> | string
    planId?: StringFilter<"UsageLimit"> | string
    featureKey?: StringFilter<"UsageLimit"> | string
    limit?: FloatFilter<"UsageLimit"> | number
    interval?: StringFilter<"UsageLimit"> | string
    overage?: BoolFilter<"UsageLimit"> | boolean
    overagePrice?: FloatNullableFilter<"UsageLimit"> | number | null
    createdAt?: DateTimeFilter<"UsageLimit"> | Date | string
    updatedAt?: DateTimeFilter<"UsageLimit"> | Date | string
    plan?: XOR<PlanRelationFilter, PlanWhereInput>
  }

  export type UsageLimitOrderByWithRelationInput = {
    id?: SortOrder
    planId?: SortOrder
    featureKey?: SortOrder
    limit?: SortOrder
    interval?: SortOrder
    overage?: SortOrder
    overagePrice?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    plan?: PlanOrderByWithRelationInput
  }

  export type UsageLimitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UsageLimitWhereInput | UsageLimitWhereInput[]
    OR?: UsageLimitWhereInput[]
    NOT?: UsageLimitWhereInput | UsageLimitWhereInput[]
    planId?: StringFilter<"UsageLimit"> | string
    featureKey?: StringFilter<"UsageLimit"> | string
    limit?: FloatFilter<"UsageLimit"> | number
    interval?: StringFilter<"UsageLimit"> | string
    overage?: BoolFilter<"UsageLimit"> | boolean
    overagePrice?: FloatNullableFilter<"UsageLimit"> | number | null
    createdAt?: DateTimeFilter<"UsageLimit"> | Date | string
    updatedAt?: DateTimeFilter<"UsageLimit"> | Date | string
    plan?: XOR<PlanRelationFilter, PlanWhereInput>
  }, "id">

  export type UsageLimitOrderByWithAggregationInput = {
    id?: SortOrder
    planId?: SortOrder
    featureKey?: SortOrder
    limit?: SortOrder
    interval?: SortOrder
    overage?: SortOrder
    overagePrice?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UsageLimitCountOrderByAggregateInput
    _avg?: UsageLimitAvgOrderByAggregateInput
    _max?: UsageLimitMaxOrderByAggregateInput
    _min?: UsageLimitMinOrderByAggregateInput
    _sum?: UsageLimitSumOrderByAggregateInput
  }

  export type UsageLimitScalarWhereWithAggregatesInput = {
    AND?: UsageLimitScalarWhereWithAggregatesInput | UsageLimitScalarWhereWithAggregatesInput[]
    OR?: UsageLimitScalarWhereWithAggregatesInput[]
    NOT?: UsageLimitScalarWhereWithAggregatesInput | UsageLimitScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UsageLimit"> | string
    planId?: StringWithAggregatesFilter<"UsageLimit"> | string
    featureKey?: StringWithAggregatesFilter<"UsageLimit"> | string
    limit?: FloatWithAggregatesFilter<"UsageLimit"> | number
    interval?: StringWithAggregatesFilter<"UsageLimit"> | string
    overage?: BoolWithAggregatesFilter<"UsageLimit"> | boolean
    overagePrice?: FloatNullableWithAggregatesFilter<"UsageLimit"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"UsageLimit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UsageLimit"> | Date | string
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: StringFilter<"Invoice"> | string
    organizationId?: StringFilter<"Invoice"> | string
    amount?: FloatFilter<"Invoice"> | number
    currency?: StringFilter<"Invoice"> | string
    status?: StringFilter<"Invoice"> | string
    stripeInvoiceId?: StringNullableFilter<"Invoice"> | string | null
    pdfUrl?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    stripeInvoiceId?: SortOrderInput | SortOrder
    pdfUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    organizationId?: StringFilter<"Invoice"> | string
    amount?: FloatFilter<"Invoice"> | number
    currency?: StringFilter<"Invoice"> | string
    status?: StringFilter<"Invoice"> | string
    stripeInvoiceId?: StringNullableFilter<"Invoice"> | string | null
    pdfUrl?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
  }, "id">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    stripeInvoiceId?: SortOrderInput | SortOrder
    pdfUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invoice"> | string
    organizationId?: StringWithAggregatesFilter<"Invoice"> | string
    amount?: FloatWithAggregatesFilter<"Invoice"> | number
    currency?: StringWithAggregatesFilter<"Invoice"> | string
    status?: StringWithAggregatesFilter<"Invoice"> | string
    stripeInvoiceId?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    pdfUrl?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
  }

  export type UsageRecordWhereInput = {
    AND?: UsageRecordWhereInput | UsageRecordWhereInput[]
    OR?: UsageRecordWhereInput[]
    NOT?: UsageRecordWhereInput | UsageRecordWhereInput[]
    id?: StringFilter<"UsageRecord"> | string
    subscriptionId?: StringFilter<"UsageRecord"> | string
    featureKey?: StringFilter<"UsageRecord"> | string
    quantity?: FloatFilter<"UsageRecord"> | number
    timestamp?: DateTimeFilter<"UsageRecord"> | Date | string
    billingPeriodStart?: DateTimeFilter<"UsageRecord"> | Date | string
    billingPeriodEnd?: DateTimeFilter<"UsageRecord"> | Date | string
    processed?: BoolFilter<"UsageRecord"> | boolean
    metadata?: JsonNullableFilter<"UsageRecord">
    subscription?: XOR<SubscriptionRelationFilter, SubscriptionWhereInput>
  }

  export type UsageRecordOrderByWithRelationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    featureKey?: SortOrder
    quantity?: SortOrder
    timestamp?: SortOrder
    billingPeriodStart?: SortOrder
    billingPeriodEnd?: SortOrder
    processed?: SortOrder
    metadata?: SortOrderInput | SortOrder
    subscription?: SubscriptionOrderByWithRelationInput
  }

  export type UsageRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UsageRecordWhereInput | UsageRecordWhereInput[]
    OR?: UsageRecordWhereInput[]
    NOT?: UsageRecordWhereInput | UsageRecordWhereInput[]
    subscriptionId?: StringFilter<"UsageRecord"> | string
    featureKey?: StringFilter<"UsageRecord"> | string
    quantity?: FloatFilter<"UsageRecord"> | number
    timestamp?: DateTimeFilter<"UsageRecord"> | Date | string
    billingPeriodStart?: DateTimeFilter<"UsageRecord"> | Date | string
    billingPeriodEnd?: DateTimeFilter<"UsageRecord"> | Date | string
    processed?: BoolFilter<"UsageRecord"> | boolean
    metadata?: JsonNullableFilter<"UsageRecord">
    subscription?: XOR<SubscriptionRelationFilter, SubscriptionWhereInput>
  }, "id">

  export type UsageRecordOrderByWithAggregationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    featureKey?: SortOrder
    quantity?: SortOrder
    timestamp?: SortOrder
    billingPeriodStart?: SortOrder
    billingPeriodEnd?: SortOrder
    processed?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: UsageRecordCountOrderByAggregateInput
    _avg?: UsageRecordAvgOrderByAggregateInput
    _max?: UsageRecordMaxOrderByAggregateInput
    _min?: UsageRecordMinOrderByAggregateInput
    _sum?: UsageRecordSumOrderByAggregateInput
  }

  export type UsageRecordScalarWhereWithAggregatesInput = {
    AND?: UsageRecordScalarWhereWithAggregatesInput | UsageRecordScalarWhereWithAggregatesInput[]
    OR?: UsageRecordScalarWhereWithAggregatesInput[]
    NOT?: UsageRecordScalarWhereWithAggregatesInput | UsageRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UsageRecord"> | string
    subscriptionId?: StringWithAggregatesFilter<"UsageRecord"> | string
    featureKey?: StringWithAggregatesFilter<"UsageRecord"> | string
    quantity?: FloatWithAggregatesFilter<"UsageRecord"> | number
    timestamp?: DateTimeWithAggregatesFilter<"UsageRecord"> | Date | string
    billingPeriodStart?: DateTimeWithAggregatesFilter<"UsageRecord"> | Date | string
    billingPeriodEnd?: DateTimeWithAggregatesFilter<"UsageRecord"> | Date | string
    processed?: BoolWithAggregatesFilter<"UsageRecord"> | boolean
    metadata?: JsonNullableWithAggregatesFilter<"UsageRecord">
  }

  export type ReportWhereInput = {
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    id?: StringFilter<"Report"> | string
    type?: StringFilter<"Report"> | string
    format?: StringFilter<"Report"> | string
    status?: StringFilter<"Report"> | string
    createdAt?: DateTimeFilter<"Report"> | Date | string
    updatedAt?: DateTimeFilter<"Report"> | Date | string
    createdBy?: StringFilter<"Report"> | string
    downloadUrl?: StringNullableFilter<"Report"> | string | null
    metadata?: JsonNullableFilter<"Report">
  }

  export type ReportOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    format?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    downloadUrl?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
  }

  export type ReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    type?: StringFilter<"Report"> | string
    format?: StringFilter<"Report"> | string
    status?: StringFilter<"Report"> | string
    createdAt?: DateTimeFilter<"Report"> | Date | string
    updatedAt?: DateTimeFilter<"Report"> | Date | string
    createdBy?: StringFilter<"Report"> | string
    downloadUrl?: StringNullableFilter<"Report"> | string | null
    metadata?: JsonNullableFilter<"Report">
  }, "id">

  export type ReportOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    format?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    downloadUrl?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: ReportCountOrderByAggregateInput
    _max?: ReportMaxOrderByAggregateInput
    _min?: ReportMinOrderByAggregateInput
  }

  export type ReportScalarWhereWithAggregatesInput = {
    AND?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    OR?: ReportScalarWhereWithAggregatesInput[]
    NOT?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Report"> | string
    type?: StringWithAggregatesFilter<"Report"> | string
    format?: StringWithAggregatesFilter<"Report"> | string
    status?: StringWithAggregatesFilter<"Report"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Report"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Report"> | Date | string
    createdBy?: StringWithAggregatesFilter<"Report"> | string
    downloadUrl?: StringNullableWithAggregatesFilter<"Report"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Report">
  }

  export type MetricWhereInput = {
    AND?: MetricWhereInput | MetricWhereInput[]
    OR?: MetricWhereInput[]
    NOT?: MetricWhereInput | MetricWhereInput[]
    id?: StringFilter<"Metric"> | string
    name?: StringFilter<"Metric"> | string
    value?: FloatFilter<"Metric"> | number
    tags?: JsonNullableFilter<"Metric">
    timestamp?: DateTimeFilter<"Metric"> | Date | string
    createdAt?: DateTimeFilter<"Metric"> | Date | string
    updatedAt?: DateTimeFilter<"Metric"> | Date | string
  }

  export type MetricOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    tags?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MetricWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MetricWhereInput | MetricWhereInput[]
    OR?: MetricWhereInput[]
    NOT?: MetricWhereInput | MetricWhereInput[]
    name?: StringFilter<"Metric"> | string
    value?: FloatFilter<"Metric"> | number
    tags?: JsonNullableFilter<"Metric">
    timestamp?: DateTimeFilter<"Metric"> | Date | string
    createdAt?: DateTimeFilter<"Metric"> | Date | string
    updatedAt?: DateTimeFilter<"Metric"> | Date | string
  }, "id">

  export type MetricOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    tags?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MetricCountOrderByAggregateInput
    _avg?: MetricAvgOrderByAggregateInput
    _max?: MetricMaxOrderByAggregateInput
    _min?: MetricMinOrderByAggregateInput
    _sum?: MetricSumOrderByAggregateInput
  }

  export type MetricScalarWhereWithAggregatesInput = {
    AND?: MetricScalarWhereWithAggregatesInput | MetricScalarWhereWithAggregatesInput[]
    OR?: MetricScalarWhereWithAggregatesInput[]
    NOT?: MetricScalarWhereWithAggregatesInput | MetricScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Metric"> | string
    name?: StringWithAggregatesFilter<"Metric"> | string
    value?: FloatWithAggregatesFilter<"Metric"> | number
    tags?: JsonNullableWithAggregatesFilter<"Metric">
    timestamp?: DateTimeWithAggregatesFilter<"Metric"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Metric"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Metric"> | Date | string
  }

  export type EmailNotificationWhereInput = {
    AND?: EmailNotificationWhereInput | EmailNotificationWhereInput[]
    OR?: EmailNotificationWhereInput[]
    NOT?: EmailNotificationWhereInput | EmailNotificationWhereInput[]
    id?: StringFilter<"EmailNotification"> | string
    type?: StringFilter<"EmailNotification"> | string
    status?: StringFilter<"EmailNotification"> | string
    to?: StringFilter<"EmailNotification"> | string
    subject?: StringFilter<"EmailNotification"> | string
    body?: StringFilter<"EmailNotification"> | string
    sentAt?: DateTimeNullableFilter<"EmailNotification"> | Date | string | null
    createdAt?: DateTimeFilter<"EmailNotification"> | Date | string
    metadata?: JsonNullableFilter<"EmailNotification">
  }

  export type EmailNotificationOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    to?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
  }

  export type EmailNotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmailNotificationWhereInput | EmailNotificationWhereInput[]
    OR?: EmailNotificationWhereInput[]
    NOT?: EmailNotificationWhereInput | EmailNotificationWhereInput[]
    type?: StringFilter<"EmailNotification"> | string
    status?: StringFilter<"EmailNotification"> | string
    to?: StringFilter<"EmailNotification"> | string
    subject?: StringFilter<"EmailNotification"> | string
    body?: StringFilter<"EmailNotification"> | string
    sentAt?: DateTimeNullableFilter<"EmailNotification"> | Date | string | null
    createdAt?: DateTimeFilter<"EmailNotification"> | Date | string
    metadata?: JsonNullableFilter<"EmailNotification">
  }, "id">

  export type EmailNotificationOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    to?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: EmailNotificationCountOrderByAggregateInput
    _max?: EmailNotificationMaxOrderByAggregateInput
    _min?: EmailNotificationMinOrderByAggregateInput
  }

  export type EmailNotificationScalarWhereWithAggregatesInput = {
    AND?: EmailNotificationScalarWhereWithAggregatesInput | EmailNotificationScalarWhereWithAggregatesInput[]
    OR?: EmailNotificationScalarWhereWithAggregatesInput[]
    NOT?: EmailNotificationScalarWhereWithAggregatesInput | EmailNotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailNotification"> | string
    type?: StringWithAggregatesFilter<"EmailNotification"> | string
    status?: StringWithAggregatesFilter<"EmailNotification"> | string
    to?: StringWithAggregatesFilter<"EmailNotification"> | string
    subject?: StringWithAggregatesFilter<"EmailNotification"> | string
    body?: StringWithAggregatesFilter<"EmailNotification"> | string
    sentAt?: DateTimeNullableWithAggregatesFilter<"EmailNotification"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EmailNotification"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"EmailNotification">
  }

  export type WebhookWhereInput = {
    AND?: WebhookWhereInput | WebhookWhereInput[]
    OR?: WebhookWhereInput[]
    NOT?: WebhookWhereInput | WebhookWhereInput[]
    id?: StringFilter<"Webhook"> | string
    organizationId?: StringFilter<"Webhook"> | string
    url?: StringFilter<"Webhook"> | string
    secret?: StringFilter<"Webhook"> | string
    events?: StringNullableListFilter<"Webhook">
    status?: StringFilter<"Webhook"> | string
    retryConfig?: JsonFilter<"Webhook">
    lastSuccess?: DateTimeNullableFilter<"Webhook"> | Date | string | null
    lastFailure?: DateTimeNullableFilter<"Webhook"> | Date | string | null
    createdAt?: DateTimeFilter<"Webhook"> | Date | string
    updatedAt?: DateTimeFilter<"Webhook"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    deliveries?: WebhookDeliveryListRelationFilter
  }

  export type WebhookOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    events?: SortOrder
    status?: SortOrder
    retryConfig?: SortOrder
    lastSuccess?: SortOrderInput | SortOrder
    lastFailure?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    deliveries?: WebhookDeliveryOrderByRelationAggregateInput
  }

  export type WebhookWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WebhookWhereInput | WebhookWhereInput[]
    OR?: WebhookWhereInput[]
    NOT?: WebhookWhereInput | WebhookWhereInput[]
    organizationId?: StringFilter<"Webhook"> | string
    url?: StringFilter<"Webhook"> | string
    secret?: StringFilter<"Webhook"> | string
    events?: StringNullableListFilter<"Webhook">
    status?: StringFilter<"Webhook"> | string
    retryConfig?: JsonFilter<"Webhook">
    lastSuccess?: DateTimeNullableFilter<"Webhook"> | Date | string | null
    lastFailure?: DateTimeNullableFilter<"Webhook"> | Date | string | null
    createdAt?: DateTimeFilter<"Webhook"> | Date | string
    updatedAt?: DateTimeFilter<"Webhook"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    deliveries?: WebhookDeliveryListRelationFilter
  }, "id">

  export type WebhookOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    events?: SortOrder
    status?: SortOrder
    retryConfig?: SortOrder
    lastSuccess?: SortOrderInput | SortOrder
    lastFailure?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WebhookCountOrderByAggregateInput
    _max?: WebhookMaxOrderByAggregateInput
    _min?: WebhookMinOrderByAggregateInput
  }

  export type WebhookScalarWhereWithAggregatesInput = {
    AND?: WebhookScalarWhereWithAggregatesInput | WebhookScalarWhereWithAggregatesInput[]
    OR?: WebhookScalarWhereWithAggregatesInput[]
    NOT?: WebhookScalarWhereWithAggregatesInput | WebhookScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Webhook"> | string
    organizationId?: StringWithAggregatesFilter<"Webhook"> | string
    url?: StringWithAggregatesFilter<"Webhook"> | string
    secret?: StringWithAggregatesFilter<"Webhook"> | string
    events?: StringNullableListFilter<"Webhook">
    status?: StringWithAggregatesFilter<"Webhook"> | string
    retryConfig?: JsonWithAggregatesFilter<"Webhook">
    lastSuccess?: DateTimeNullableWithAggregatesFilter<"Webhook"> | Date | string | null
    lastFailure?: DateTimeNullableWithAggregatesFilter<"Webhook"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Webhook"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Webhook"> | Date | string
  }

  export type WebhookDeliveryWhereInput = {
    AND?: WebhookDeliveryWhereInput | WebhookDeliveryWhereInput[]
    OR?: WebhookDeliveryWhereInput[]
    NOT?: WebhookDeliveryWhereInput | WebhookDeliveryWhereInput[]
    id?: StringFilter<"WebhookDelivery"> | string
    webhookId?: StringFilter<"WebhookDelivery"> | string
    payload?: JsonFilter<"WebhookDelivery">
    status?: StringFilter<"WebhookDelivery"> | string
    statusCode?: IntNullableFilter<"WebhookDelivery"> | number | null
    response?: StringNullableFilter<"WebhookDelivery"> | string | null
    error?: StringNullableFilter<"WebhookDelivery"> | string | null
    retries?: IntFilter<"WebhookDelivery"> | number
    createdAt?: DateTimeFilter<"WebhookDelivery"> | Date | string
    webhook?: XOR<WebhookRelationFilter, WebhookWhereInput>
  }

  export type WebhookDeliveryOrderByWithRelationInput = {
    id?: SortOrder
    webhookId?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    statusCode?: SortOrderInput | SortOrder
    response?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    retries?: SortOrder
    createdAt?: SortOrder
    webhook?: WebhookOrderByWithRelationInput
  }

  export type WebhookDeliveryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WebhookDeliveryWhereInput | WebhookDeliveryWhereInput[]
    OR?: WebhookDeliveryWhereInput[]
    NOT?: WebhookDeliveryWhereInput | WebhookDeliveryWhereInput[]
    webhookId?: StringFilter<"WebhookDelivery"> | string
    payload?: JsonFilter<"WebhookDelivery">
    status?: StringFilter<"WebhookDelivery"> | string
    statusCode?: IntNullableFilter<"WebhookDelivery"> | number | null
    response?: StringNullableFilter<"WebhookDelivery"> | string | null
    error?: StringNullableFilter<"WebhookDelivery"> | string | null
    retries?: IntFilter<"WebhookDelivery"> | number
    createdAt?: DateTimeFilter<"WebhookDelivery"> | Date | string
    webhook?: XOR<WebhookRelationFilter, WebhookWhereInput>
  }, "id">

  export type WebhookDeliveryOrderByWithAggregationInput = {
    id?: SortOrder
    webhookId?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    statusCode?: SortOrderInput | SortOrder
    response?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    retries?: SortOrder
    createdAt?: SortOrder
    _count?: WebhookDeliveryCountOrderByAggregateInput
    _avg?: WebhookDeliveryAvgOrderByAggregateInput
    _max?: WebhookDeliveryMaxOrderByAggregateInput
    _min?: WebhookDeliveryMinOrderByAggregateInput
    _sum?: WebhookDeliverySumOrderByAggregateInput
  }

  export type WebhookDeliveryScalarWhereWithAggregatesInput = {
    AND?: WebhookDeliveryScalarWhereWithAggregatesInput | WebhookDeliveryScalarWhereWithAggregatesInput[]
    OR?: WebhookDeliveryScalarWhereWithAggregatesInput[]
    NOT?: WebhookDeliveryScalarWhereWithAggregatesInput | WebhookDeliveryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WebhookDelivery"> | string
    webhookId?: StringWithAggregatesFilter<"WebhookDelivery"> | string
    payload?: JsonWithAggregatesFilter<"WebhookDelivery">
    status?: StringWithAggregatesFilter<"WebhookDelivery"> | string
    statusCode?: IntNullableWithAggregatesFilter<"WebhookDelivery"> | number | null
    response?: StringNullableWithAggregatesFilter<"WebhookDelivery"> | string | null
    error?: StringNullableWithAggregatesFilter<"WebhookDelivery"> | string | null
    retries?: IntWithAggregatesFilter<"WebhookDelivery"> | number
    createdAt?: DateTimeWithAggregatesFilter<"WebhookDelivery"> | Date | string
  }

  export type RefreshTokenWhereInput = {
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    updatedAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type RefreshTokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type RefreshTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    userId?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    updatedAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type RefreshTokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RefreshTokenCountOrderByAggregateInput
    _max?: RefreshTokenMaxOrderByAggregateInput
    _min?: RefreshTokenMinOrderByAggregateInput
  }

  export type RefreshTokenScalarWhereWithAggregatesInput = {
    AND?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    OR?: RefreshTokenScalarWhereWithAggregatesInput[]
    NOT?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RefreshToken"> | string
    token?: StringWithAggregatesFilter<"RefreshToken"> | string
    userId?: StringWithAggregatesFilter<"RefreshToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: StringFilter<"Payment"> | string
    stripePaymentId?: StringFilter<"Payment"> | string
    userId?: StringFilter<"Payment"> | string
    customerId?: StringNullableFilter<"Payment"> | string | null
    subscriptionId?: StringNullableFilter<"Payment"> | string | null
    orderId?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    customer?: XOR<CustomerNullableRelationFilter, CustomerWhereInput> | null
    subscription?: XOR<SubscriptionNullableRelationFilter, SubscriptionWhereInput> | null
    order?: XOR<OrderNullableRelationFilter, OrderWhereInput> | null
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    stripePaymentId?: SortOrder
    userId?: SortOrder
    customerId?: SortOrderInput | SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
    subscription?: SubscriptionOrderByWithRelationInput
    order?: OrderOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    stripePaymentId?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: StringFilter<"Payment"> | string
    userId?: StringFilter<"Payment"> | string
    customerId?: StringNullableFilter<"Payment"> | string | null
    subscriptionId?: StringNullableFilter<"Payment"> | string | null
    orderId?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    customer?: XOR<CustomerNullableRelationFilter, CustomerWhereInput> | null
    subscription?: XOR<SubscriptionNullableRelationFilter, SubscriptionWhereInput> | null
    order?: XOR<OrderNullableRelationFilter, OrderWhereInput> | null
  }, "id" | "stripePaymentId">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    stripePaymentId?: SortOrder
    userId?: SortOrder
    customerId?: SortOrderInput | SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    amount?: FloatWithAggregatesFilter<"Payment"> | number
    currency?: StringWithAggregatesFilter<"Payment"> | string
    status?: StringWithAggregatesFilter<"Payment"> | string
    stripePaymentId?: StringWithAggregatesFilter<"Payment"> | string
    userId?: StringWithAggregatesFilter<"Payment"> | string
    customerId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    subscriptionId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    orderId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type FinancingOfferWhereInput = {
    AND?: FinancingOfferWhereInput | FinancingOfferWhereInput[]
    OR?: FinancingOfferWhereInput[]
    NOT?: FinancingOfferWhereInput | FinancingOfferWhereInput[]
    id?: StringFilter<"FinancingOffer"> | string
    amount?: FloatFilter<"FinancingOffer"> | number
    currency?: StringFilter<"FinancingOffer"> | string
    provider?: StringFilter<"FinancingOffer"> | string
    customerId?: StringFilter<"FinancingOffer"> | string
    status?: StringFilter<"FinancingOffer"> | string
    offerId?: StringFilter<"FinancingOffer"> | string
    terms?: JsonFilter<"FinancingOffer">
    metadata?: JsonNullableFilter<"FinancingOffer">
    createdAt?: DateTimeFilter<"FinancingOffer"> | Date | string
    updatedAt?: DateTimeFilter<"FinancingOffer"> | Date | string
  }

  export type FinancingOfferOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    provider?: SortOrder
    customerId?: SortOrder
    status?: SortOrder
    offerId?: SortOrder
    terms?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FinancingOfferWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FinancingOfferWhereInput | FinancingOfferWhereInput[]
    OR?: FinancingOfferWhereInput[]
    NOT?: FinancingOfferWhereInput | FinancingOfferWhereInput[]
    amount?: FloatFilter<"FinancingOffer"> | number
    currency?: StringFilter<"FinancingOffer"> | string
    provider?: StringFilter<"FinancingOffer"> | string
    customerId?: StringFilter<"FinancingOffer"> | string
    status?: StringFilter<"FinancingOffer"> | string
    offerId?: StringFilter<"FinancingOffer"> | string
    terms?: JsonFilter<"FinancingOffer">
    metadata?: JsonNullableFilter<"FinancingOffer">
    createdAt?: DateTimeFilter<"FinancingOffer"> | Date | string
    updatedAt?: DateTimeFilter<"FinancingOffer"> | Date | string
  }, "id">

  export type FinancingOfferOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    provider?: SortOrder
    customerId?: SortOrder
    status?: SortOrder
    offerId?: SortOrder
    terms?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FinancingOfferCountOrderByAggregateInput
    _avg?: FinancingOfferAvgOrderByAggregateInput
    _max?: FinancingOfferMaxOrderByAggregateInput
    _min?: FinancingOfferMinOrderByAggregateInput
    _sum?: FinancingOfferSumOrderByAggregateInput
  }

  export type FinancingOfferScalarWhereWithAggregatesInput = {
    AND?: FinancingOfferScalarWhereWithAggregatesInput | FinancingOfferScalarWhereWithAggregatesInput[]
    OR?: FinancingOfferScalarWhereWithAggregatesInput[]
    NOT?: FinancingOfferScalarWhereWithAggregatesInput | FinancingOfferScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FinancingOffer"> | string
    amount?: FloatWithAggregatesFilter<"FinancingOffer"> | number
    currency?: StringWithAggregatesFilter<"FinancingOffer"> | string
    provider?: StringWithAggregatesFilter<"FinancingOffer"> | string
    customerId?: StringWithAggregatesFilter<"FinancingOffer"> | string
    status?: StringWithAggregatesFilter<"FinancingOffer"> | string
    offerId?: StringWithAggregatesFilter<"FinancingOffer"> | string
    terms?: JsonWithAggregatesFilter<"FinancingOffer">
    metadata?: JsonNullableWithAggregatesFilter<"FinancingOffer">
    createdAt?: DateTimeWithAggregatesFilter<"FinancingOffer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FinancingOffer"> | Date | string
  }

  export type CarbonEstimateWhereInput = {
    AND?: CarbonEstimateWhereInput | CarbonEstimateWhereInput[]
    OR?: CarbonEstimateWhereInput[]
    NOT?: CarbonEstimateWhereInput | CarbonEstimateWhereInput[]
    id?: StringFilter<"CarbonEstimate"> | string
    organizationId?: StringFilter<"CarbonEstimate"> | string
    amount?: FloatFilter<"CarbonEstimate"> | number
    unit?: StringFilter<"CarbonEstimate"> | string
    source?: StringFilter<"CarbonEstimate"> | string
    category?: StringFilter<"CarbonEstimate"> | string
    timestamp?: DateTimeFilter<"CarbonEstimate"> | Date | string
    metadata?: JsonNullableFilter<"CarbonEstimate">
    createdAt?: DateTimeFilter<"CarbonEstimate"> | Date | string
    updatedAt?: DateTimeFilter<"CarbonEstimate"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
  }

  export type CarbonEstimateOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    source?: SortOrder
    category?: SortOrder
    timestamp?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
  }

  export type CarbonEstimateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CarbonEstimateWhereInput | CarbonEstimateWhereInput[]
    OR?: CarbonEstimateWhereInput[]
    NOT?: CarbonEstimateWhereInput | CarbonEstimateWhereInput[]
    organizationId?: StringFilter<"CarbonEstimate"> | string
    amount?: FloatFilter<"CarbonEstimate"> | number
    unit?: StringFilter<"CarbonEstimate"> | string
    source?: StringFilter<"CarbonEstimate"> | string
    category?: StringFilter<"CarbonEstimate"> | string
    timestamp?: DateTimeFilter<"CarbonEstimate"> | Date | string
    metadata?: JsonNullableFilter<"CarbonEstimate">
    createdAt?: DateTimeFilter<"CarbonEstimate"> | Date | string
    updatedAt?: DateTimeFilter<"CarbonEstimate"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
  }, "id">

  export type CarbonEstimateOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    source?: SortOrder
    category?: SortOrder
    timestamp?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CarbonEstimateCountOrderByAggregateInput
    _avg?: CarbonEstimateAvgOrderByAggregateInput
    _max?: CarbonEstimateMaxOrderByAggregateInput
    _min?: CarbonEstimateMinOrderByAggregateInput
    _sum?: CarbonEstimateSumOrderByAggregateInput
  }

  export type CarbonEstimateScalarWhereWithAggregatesInput = {
    AND?: CarbonEstimateScalarWhereWithAggregatesInput | CarbonEstimateScalarWhereWithAggregatesInput[]
    OR?: CarbonEstimateScalarWhereWithAggregatesInput[]
    NOT?: CarbonEstimateScalarWhereWithAggregatesInput | CarbonEstimateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CarbonEstimate"> | string
    organizationId?: StringWithAggregatesFilter<"CarbonEstimate"> | string
    amount?: FloatWithAggregatesFilter<"CarbonEstimate"> | number
    unit?: StringWithAggregatesFilter<"CarbonEstimate"> | string
    source?: StringWithAggregatesFilter<"CarbonEstimate"> | string
    category?: StringWithAggregatesFilter<"CarbonEstimate"> | string
    timestamp?: DateTimeWithAggregatesFilter<"CarbonEstimate"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"CarbonEstimate">
    createdAt?: DateTimeWithAggregatesFilter<"CarbonEstimate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CarbonEstimate"> | Date | string
  }

  export type BillingRuleWhereInput = {
    AND?: BillingRuleWhereInput | BillingRuleWhereInput[]
    OR?: BillingRuleWhereInput[]
    NOT?: BillingRuleWhereInput | BillingRuleWhereInput[]
    id?: StringFilter<"BillingRule"> | string
    name?: StringFilter<"BillingRule"> | string
    description?: StringNullableFilter<"BillingRule"> | string | null
    type?: StringFilter<"BillingRule"> | string
    conditions?: JsonNullableListFilter<"BillingRule">
    actions?: JsonNullableListFilter<"BillingRule">
    priority?: IntFilter<"BillingRule"> | number
    isActive?: BoolFilter<"BillingRule"> | boolean
    organizationId?: StringFilter<"BillingRule"> | string
    createdAt?: DateTimeFilter<"BillingRule"> | Date | string
    updatedAt?: DateTimeFilter<"BillingRule"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
  }

  export type BillingRuleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    conditions?: SortOrder
    actions?: SortOrder
    priority?: SortOrder
    isActive?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
  }

  export type BillingRuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BillingRuleWhereInput | BillingRuleWhereInput[]
    OR?: BillingRuleWhereInput[]
    NOT?: BillingRuleWhereInput | BillingRuleWhereInput[]
    name?: StringFilter<"BillingRule"> | string
    description?: StringNullableFilter<"BillingRule"> | string | null
    type?: StringFilter<"BillingRule"> | string
    conditions?: JsonNullableListFilter<"BillingRule">
    actions?: JsonNullableListFilter<"BillingRule">
    priority?: IntFilter<"BillingRule"> | number
    isActive?: BoolFilter<"BillingRule"> | boolean
    organizationId?: StringFilter<"BillingRule"> | string
    createdAt?: DateTimeFilter<"BillingRule"> | Date | string
    updatedAt?: DateTimeFilter<"BillingRule"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
  }, "id">

  export type BillingRuleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    conditions?: SortOrder
    actions?: SortOrder
    priority?: SortOrder
    isActive?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BillingRuleCountOrderByAggregateInput
    _avg?: BillingRuleAvgOrderByAggregateInput
    _max?: BillingRuleMaxOrderByAggregateInput
    _min?: BillingRuleMinOrderByAggregateInput
    _sum?: BillingRuleSumOrderByAggregateInput
  }

  export type BillingRuleScalarWhereWithAggregatesInput = {
    AND?: BillingRuleScalarWhereWithAggregatesInput | BillingRuleScalarWhereWithAggregatesInput[]
    OR?: BillingRuleScalarWhereWithAggregatesInput[]
    NOT?: BillingRuleScalarWhereWithAggregatesInput | BillingRuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BillingRule"> | string
    name?: StringWithAggregatesFilter<"BillingRule"> | string
    description?: StringNullableWithAggregatesFilter<"BillingRule"> | string | null
    type?: StringWithAggregatesFilter<"BillingRule"> | string
    conditions?: JsonNullableListFilter<"BillingRule">
    actions?: JsonNullableListFilter<"BillingRule">
    priority?: IntWithAggregatesFilter<"BillingRule"> | number
    isActive?: BoolWithAggregatesFilter<"BillingRule"> | boolean
    organizationId?: StringWithAggregatesFilter<"BillingRule"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BillingRule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BillingRule"> | Date | string
  }

  export type BillingRuleTemplateWhereInput = {
    AND?: BillingRuleTemplateWhereInput | BillingRuleTemplateWhereInput[]
    OR?: BillingRuleTemplateWhereInput[]
    NOT?: BillingRuleTemplateWhereInput | BillingRuleTemplateWhereInput[]
    id?: StringFilter<"BillingRuleTemplate"> | string
    name?: StringFilter<"BillingRuleTemplate"> | string
    description?: StringNullableFilter<"BillingRuleTemplate"> | string | null
    type?: StringFilter<"BillingRuleTemplate"> | string
    conditions?: JsonNullableListFilter<"BillingRuleTemplate">
    actions?: JsonNullableListFilter<"BillingRuleTemplate">
    isDefault?: BoolFilter<"BillingRuleTemplate"> | boolean
    organizationId?: StringFilter<"BillingRuleTemplate"> | string
    createdAt?: DateTimeFilter<"BillingRuleTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"BillingRuleTemplate"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
  }

  export type BillingRuleTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    conditions?: SortOrder
    actions?: SortOrder
    isDefault?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
  }

  export type BillingRuleTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BillingRuleTemplateWhereInput | BillingRuleTemplateWhereInput[]
    OR?: BillingRuleTemplateWhereInput[]
    NOT?: BillingRuleTemplateWhereInput | BillingRuleTemplateWhereInput[]
    name?: StringFilter<"BillingRuleTemplate"> | string
    description?: StringNullableFilter<"BillingRuleTemplate"> | string | null
    type?: StringFilter<"BillingRuleTemplate"> | string
    conditions?: JsonNullableListFilter<"BillingRuleTemplate">
    actions?: JsonNullableListFilter<"BillingRuleTemplate">
    isDefault?: BoolFilter<"BillingRuleTemplate"> | boolean
    organizationId?: StringFilter<"BillingRuleTemplate"> | string
    createdAt?: DateTimeFilter<"BillingRuleTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"BillingRuleTemplate"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
  }, "id">

  export type BillingRuleTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    conditions?: SortOrder
    actions?: SortOrder
    isDefault?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BillingRuleTemplateCountOrderByAggregateInput
    _max?: BillingRuleTemplateMaxOrderByAggregateInput
    _min?: BillingRuleTemplateMinOrderByAggregateInput
  }

  export type BillingRuleTemplateScalarWhereWithAggregatesInput = {
    AND?: BillingRuleTemplateScalarWhereWithAggregatesInput | BillingRuleTemplateScalarWhereWithAggregatesInput[]
    OR?: BillingRuleTemplateScalarWhereWithAggregatesInput[]
    NOT?: BillingRuleTemplateScalarWhereWithAggregatesInput | BillingRuleTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BillingRuleTemplate"> | string
    name?: StringWithAggregatesFilter<"BillingRuleTemplate"> | string
    description?: StringNullableWithAggregatesFilter<"BillingRuleTemplate"> | string | null
    type?: StringWithAggregatesFilter<"BillingRuleTemplate"> | string
    conditions?: JsonNullableListFilter<"BillingRuleTemplate">
    actions?: JsonNullableListFilter<"BillingRuleTemplate">
    isDefault?: BoolWithAggregatesFilter<"BillingRuleTemplate"> | boolean
    organizationId?: StringWithAggregatesFilter<"BillingRuleTemplate"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BillingRuleTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BillingRuleTemplate"> | Date | string
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: StringFilter<"Order"> | string
    organizationId?: StringFilter<"Order"> | string
    customerId?: StringFilter<"Order"> | string
    amount?: FloatFilter<"Order"> | number
    currency?: StringFilter<"Order"> | string
    status?: StringFilter<"Order"> | string
    metadata?: JsonNullableFilter<"Order">
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    payments?: PaymentListRelationFilter
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    customerId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
    payments?: PaymentOrderByRelationAggregateInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    organizationId?: StringFilter<"Order"> | string
    customerId?: StringFilter<"Order"> | string
    amount?: FloatFilter<"Order"> | number
    currency?: StringFilter<"Order"> | string
    status?: StringFilter<"Order"> | string
    metadata?: JsonNullableFilter<"Order">
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    payments?: PaymentListRelationFilter
  }, "id">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    customerId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Order"> | string
    organizationId?: StringWithAggregatesFilter<"Order"> | string
    customerId?: StringWithAggregatesFilter<"Order"> | string
    amount?: FloatWithAggregatesFilter<"Order"> | number
    currency?: StringWithAggregatesFilter<"Order"> | string
    status?: StringWithAggregatesFilter<"Order"> | string
    metadata?: JsonNullableWithAggregatesFilter<"Order">
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
  }

  export type PriceHistoryWhereInput = {
    AND?: PriceHistoryWhereInput | PriceHistoryWhereInput[]
    OR?: PriceHistoryWhereInput[]
    NOT?: PriceHistoryWhereInput | PriceHistoryWhereInput[]
    id?: StringFilter<"PriceHistory"> | string
    planId?: StringFilter<"PriceHistory"> | string
    price?: FloatFilter<"PriceHistory"> | number
    effectiveFrom?: DateTimeFilter<"PriceHistory"> | Date | string
    effectiveTo?: DateTimeNullableFilter<"PriceHistory"> | Date | string | null
    reason?: StringNullableFilter<"PriceHistory"> | string | null
    metadata?: JsonNullableFilter<"PriceHistory">
    createdAt?: DateTimeFilter<"PriceHistory"> | Date | string
    plan?: XOR<PlanRelationFilter, PlanWhereInput>
  }

  export type PriceHistoryOrderByWithRelationInput = {
    id?: SortOrder
    planId?: SortOrder
    price?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    plan?: PlanOrderByWithRelationInput
  }

  export type PriceHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PriceHistoryWhereInput | PriceHistoryWhereInput[]
    OR?: PriceHistoryWhereInput[]
    NOT?: PriceHistoryWhereInput | PriceHistoryWhereInput[]
    planId?: StringFilter<"PriceHistory"> | string
    price?: FloatFilter<"PriceHistory"> | number
    effectiveFrom?: DateTimeFilter<"PriceHistory"> | Date | string
    effectiveTo?: DateTimeNullableFilter<"PriceHistory"> | Date | string | null
    reason?: StringNullableFilter<"PriceHistory"> | string | null
    metadata?: JsonNullableFilter<"PriceHistory">
    createdAt?: DateTimeFilter<"PriceHistory"> | Date | string
    plan?: XOR<PlanRelationFilter, PlanWhereInput>
  }, "id">

  export type PriceHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    planId?: SortOrder
    price?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PriceHistoryCountOrderByAggregateInput
    _avg?: PriceHistoryAvgOrderByAggregateInput
    _max?: PriceHistoryMaxOrderByAggregateInput
    _min?: PriceHistoryMinOrderByAggregateInput
    _sum?: PriceHistorySumOrderByAggregateInput
  }

  export type PriceHistoryScalarWhereWithAggregatesInput = {
    AND?: PriceHistoryScalarWhereWithAggregatesInput | PriceHistoryScalarWhereWithAggregatesInput[]
    OR?: PriceHistoryScalarWhereWithAggregatesInput[]
    NOT?: PriceHistoryScalarWhereWithAggregatesInput | PriceHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PriceHistory"> | string
    planId?: StringWithAggregatesFilter<"PriceHistory"> | string
    price?: FloatWithAggregatesFilter<"PriceHistory"> | number
    effectiveFrom?: DateTimeWithAggregatesFilter<"PriceHistory"> | Date | string
    effectiveTo?: DateTimeNullableWithAggregatesFilter<"PriceHistory"> | Date | string | null
    reason?: StringNullableWithAggregatesFilter<"PriceHistory"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"PriceHistory">
    createdAt?: DateTimeWithAggregatesFilter<"PriceHistory"> | Date | string
  }

  export type PriceTestWhereInput = {
    AND?: PriceTestWhereInput | PriceTestWhereInput[]
    OR?: PriceTestWhereInput[]
    NOT?: PriceTestWhereInput | PriceTestWhereInput[]
    id?: StringFilter<"PriceTest"> | string
    planId?: StringFilter<"PriceTest"> | string
    name?: StringFilter<"PriceTest"> | string
    description?: StringNullableFilter<"PriceTest"> | string | null
    startDate?: DateTimeFilter<"PriceTest"> | Date | string
    endDate?: DateTimeNullableFilter<"PriceTest"> | Date | string | null
    status?: StringFilter<"PriceTest"> | string
    targetMetric?: StringFilter<"PriceTest"> | string
    minConfidence?: FloatFilter<"PriceTest"> | number
    metadata?: JsonNullableFilter<"PriceTest">
    createdAt?: DateTimeFilter<"PriceTest"> | Date | string
    updatedAt?: DateTimeFilter<"PriceTest"> | Date | string
    plan?: XOR<PlanRelationFilter, PlanWhereInput>
    variants?: PriceTestVariantListRelationFilter
  }

  export type PriceTestOrderByWithRelationInput = {
    id?: SortOrder
    planId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    status?: SortOrder
    targetMetric?: SortOrder
    minConfidence?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    plan?: PlanOrderByWithRelationInput
    variants?: PriceTestVariantOrderByRelationAggregateInput
  }

  export type PriceTestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PriceTestWhereInput | PriceTestWhereInput[]
    OR?: PriceTestWhereInput[]
    NOT?: PriceTestWhereInput | PriceTestWhereInput[]
    planId?: StringFilter<"PriceTest"> | string
    name?: StringFilter<"PriceTest"> | string
    description?: StringNullableFilter<"PriceTest"> | string | null
    startDate?: DateTimeFilter<"PriceTest"> | Date | string
    endDate?: DateTimeNullableFilter<"PriceTest"> | Date | string | null
    status?: StringFilter<"PriceTest"> | string
    targetMetric?: StringFilter<"PriceTest"> | string
    minConfidence?: FloatFilter<"PriceTest"> | number
    metadata?: JsonNullableFilter<"PriceTest">
    createdAt?: DateTimeFilter<"PriceTest"> | Date | string
    updatedAt?: DateTimeFilter<"PriceTest"> | Date | string
    plan?: XOR<PlanRelationFilter, PlanWhereInput>
    variants?: PriceTestVariantListRelationFilter
  }, "id">

  export type PriceTestOrderByWithAggregationInput = {
    id?: SortOrder
    planId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    status?: SortOrder
    targetMetric?: SortOrder
    minConfidence?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PriceTestCountOrderByAggregateInput
    _avg?: PriceTestAvgOrderByAggregateInput
    _max?: PriceTestMaxOrderByAggregateInput
    _min?: PriceTestMinOrderByAggregateInput
    _sum?: PriceTestSumOrderByAggregateInput
  }

  export type PriceTestScalarWhereWithAggregatesInput = {
    AND?: PriceTestScalarWhereWithAggregatesInput | PriceTestScalarWhereWithAggregatesInput[]
    OR?: PriceTestScalarWhereWithAggregatesInput[]
    NOT?: PriceTestScalarWhereWithAggregatesInput | PriceTestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PriceTest"> | string
    planId?: StringWithAggregatesFilter<"PriceTest"> | string
    name?: StringWithAggregatesFilter<"PriceTest"> | string
    description?: StringNullableWithAggregatesFilter<"PriceTest"> | string | null
    startDate?: DateTimeWithAggregatesFilter<"PriceTest"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"PriceTest"> | Date | string | null
    status?: StringWithAggregatesFilter<"PriceTest"> | string
    targetMetric?: StringWithAggregatesFilter<"PriceTest"> | string
    minConfidence?: FloatWithAggregatesFilter<"PriceTest"> | number
    metadata?: JsonNullableWithAggregatesFilter<"PriceTest">
    createdAt?: DateTimeWithAggregatesFilter<"PriceTest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PriceTest"> | Date | string
  }

  export type PriceTestVariantWhereInput = {
    AND?: PriceTestVariantWhereInput | PriceTestVariantWhereInput[]
    OR?: PriceTestVariantWhereInput[]
    NOT?: PriceTestVariantWhereInput | PriceTestVariantWhereInput[]
    id?: StringFilter<"PriceTestVariant"> | string
    testId?: StringFilter<"PriceTestVariant"> | string
    price?: FloatFilter<"PriceTestVariant"> | number
    name?: StringFilter<"PriceTestVariant"> | string
    description?: StringNullableFilter<"PriceTestVariant"> | string | null
    conversionRate?: FloatNullableFilter<"PriceTestVariant"> | number | null
    revenue?: FloatNullableFilter<"PriceTestVariant"> | number | null
    subscribers?: IntFilter<"PriceTestVariant"> | number
    isControl?: BoolFilter<"PriceTestVariant"> | boolean
    metadata?: JsonNullableFilter<"PriceTestVariant">
    createdAt?: DateTimeFilter<"PriceTestVariant"> | Date | string
    updatedAt?: DateTimeFilter<"PriceTestVariant"> | Date | string
    test?: XOR<PriceTestRelationFilter, PriceTestWhereInput>
  }

  export type PriceTestVariantOrderByWithRelationInput = {
    id?: SortOrder
    testId?: SortOrder
    price?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    conversionRate?: SortOrderInput | SortOrder
    revenue?: SortOrderInput | SortOrder
    subscribers?: SortOrder
    isControl?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    test?: PriceTestOrderByWithRelationInput
  }

  export type PriceTestVariantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PriceTestVariantWhereInput | PriceTestVariantWhereInput[]
    OR?: PriceTestVariantWhereInput[]
    NOT?: PriceTestVariantWhereInput | PriceTestVariantWhereInput[]
    testId?: StringFilter<"PriceTestVariant"> | string
    price?: FloatFilter<"PriceTestVariant"> | number
    name?: StringFilter<"PriceTestVariant"> | string
    description?: StringNullableFilter<"PriceTestVariant"> | string | null
    conversionRate?: FloatNullableFilter<"PriceTestVariant"> | number | null
    revenue?: FloatNullableFilter<"PriceTestVariant"> | number | null
    subscribers?: IntFilter<"PriceTestVariant"> | number
    isControl?: BoolFilter<"PriceTestVariant"> | boolean
    metadata?: JsonNullableFilter<"PriceTestVariant">
    createdAt?: DateTimeFilter<"PriceTestVariant"> | Date | string
    updatedAt?: DateTimeFilter<"PriceTestVariant"> | Date | string
    test?: XOR<PriceTestRelationFilter, PriceTestWhereInput>
  }, "id">

  export type PriceTestVariantOrderByWithAggregationInput = {
    id?: SortOrder
    testId?: SortOrder
    price?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    conversionRate?: SortOrderInput | SortOrder
    revenue?: SortOrderInput | SortOrder
    subscribers?: SortOrder
    isControl?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PriceTestVariantCountOrderByAggregateInput
    _avg?: PriceTestVariantAvgOrderByAggregateInput
    _max?: PriceTestVariantMaxOrderByAggregateInput
    _min?: PriceTestVariantMinOrderByAggregateInput
    _sum?: PriceTestVariantSumOrderByAggregateInput
  }

  export type PriceTestVariantScalarWhereWithAggregatesInput = {
    AND?: PriceTestVariantScalarWhereWithAggregatesInput | PriceTestVariantScalarWhereWithAggregatesInput[]
    OR?: PriceTestVariantScalarWhereWithAggregatesInput[]
    NOT?: PriceTestVariantScalarWhereWithAggregatesInput | PriceTestVariantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PriceTestVariant"> | string
    testId?: StringWithAggregatesFilter<"PriceTestVariant"> | string
    price?: FloatWithAggregatesFilter<"PriceTestVariant"> | number
    name?: StringWithAggregatesFilter<"PriceTestVariant"> | string
    description?: StringNullableWithAggregatesFilter<"PriceTestVariant"> | string | null
    conversionRate?: FloatNullableWithAggregatesFilter<"PriceTestVariant"> | number | null
    revenue?: FloatNullableWithAggregatesFilter<"PriceTestVariant"> | number | null
    subscribers?: IntWithAggregatesFilter<"PriceTestVariant"> | number
    isControl?: BoolWithAggregatesFilter<"PriceTestVariant"> | boolean
    metadata?: JsonNullableWithAggregatesFilter<"PriceTestVariant">
    createdAt?: DateTimeWithAggregatesFilter<"PriceTestVariant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PriceTestVariant"> | Date | string
  }

  export type MarketBenchmarkWhereInput = {
    AND?: MarketBenchmarkWhereInput | MarketBenchmarkWhereInput[]
    OR?: MarketBenchmarkWhereInput[]
    NOT?: MarketBenchmarkWhereInput | MarketBenchmarkWhereInput[]
    id?: StringFilter<"MarketBenchmark"> | string
    segment?: StringFilter<"MarketBenchmark"> | string
    productType?: StringFilter<"MarketBenchmark"> | string
    avgPrice?: FloatFilter<"MarketBenchmark"> | number
    medianPrice?: FloatFilter<"MarketBenchmark"> | number
    minPrice?: FloatFilter<"MarketBenchmark"> | number
    maxPrice?: FloatFilter<"MarketBenchmark"> | number
    sampleSize?: IntFilter<"MarketBenchmark"> | number
    source?: StringFilter<"MarketBenchmark"> | string
    collectedAt?: DateTimeFilter<"MarketBenchmark"> | Date | string
    metadata?: JsonNullableFilter<"MarketBenchmark">
  }

  export type MarketBenchmarkOrderByWithRelationInput = {
    id?: SortOrder
    segment?: SortOrder
    productType?: SortOrder
    avgPrice?: SortOrder
    medianPrice?: SortOrder
    minPrice?: SortOrder
    maxPrice?: SortOrder
    sampleSize?: SortOrder
    source?: SortOrder
    collectedAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
  }

  export type MarketBenchmarkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MarketBenchmarkWhereInput | MarketBenchmarkWhereInput[]
    OR?: MarketBenchmarkWhereInput[]
    NOT?: MarketBenchmarkWhereInput | MarketBenchmarkWhereInput[]
    segment?: StringFilter<"MarketBenchmark"> | string
    productType?: StringFilter<"MarketBenchmark"> | string
    avgPrice?: FloatFilter<"MarketBenchmark"> | number
    medianPrice?: FloatFilter<"MarketBenchmark"> | number
    minPrice?: FloatFilter<"MarketBenchmark"> | number
    maxPrice?: FloatFilter<"MarketBenchmark"> | number
    sampleSize?: IntFilter<"MarketBenchmark"> | number
    source?: StringFilter<"MarketBenchmark"> | string
    collectedAt?: DateTimeFilter<"MarketBenchmark"> | Date | string
    metadata?: JsonNullableFilter<"MarketBenchmark">
  }, "id">

  export type MarketBenchmarkOrderByWithAggregationInput = {
    id?: SortOrder
    segment?: SortOrder
    productType?: SortOrder
    avgPrice?: SortOrder
    medianPrice?: SortOrder
    minPrice?: SortOrder
    maxPrice?: SortOrder
    sampleSize?: SortOrder
    source?: SortOrder
    collectedAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: MarketBenchmarkCountOrderByAggregateInput
    _avg?: MarketBenchmarkAvgOrderByAggregateInput
    _max?: MarketBenchmarkMaxOrderByAggregateInput
    _min?: MarketBenchmarkMinOrderByAggregateInput
    _sum?: MarketBenchmarkSumOrderByAggregateInput
  }

  export type MarketBenchmarkScalarWhereWithAggregatesInput = {
    AND?: MarketBenchmarkScalarWhereWithAggregatesInput | MarketBenchmarkScalarWhereWithAggregatesInput[]
    OR?: MarketBenchmarkScalarWhereWithAggregatesInput[]
    NOT?: MarketBenchmarkScalarWhereWithAggregatesInput | MarketBenchmarkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MarketBenchmark"> | string
    segment?: StringWithAggregatesFilter<"MarketBenchmark"> | string
    productType?: StringWithAggregatesFilter<"MarketBenchmark"> | string
    avgPrice?: FloatWithAggregatesFilter<"MarketBenchmark"> | number
    medianPrice?: FloatWithAggregatesFilter<"MarketBenchmark"> | number
    minPrice?: FloatWithAggregatesFilter<"MarketBenchmark"> | number
    maxPrice?: FloatWithAggregatesFilter<"MarketBenchmark"> | number
    sampleSize?: IntWithAggregatesFilter<"MarketBenchmark"> | number
    source?: StringWithAggregatesFilter<"MarketBenchmark"> | string
    collectedAt?: DateTimeWithAggregatesFilter<"MarketBenchmark"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"MarketBenchmark">
  }

  export type RevenueRecognitionRuleWhereInput = {
    AND?: RevenueRecognitionRuleWhereInput | RevenueRecognitionRuleWhereInput[]
    OR?: RevenueRecognitionRuleWhereInput[]
    NOT?: RevenueRecognitionRuleWhereInput | RevenueRecognitionRuleWhereInput[]
    id?: StringFilter<"RevenueRecognitionRule"> | string
    planId?: StringFilter<"RevenueRecognitionRule"> | string
    type?: StringFilter<"RevenueRecognitionRule"> | string
    deferralPeriod?: IntNullableFilter<"RevenueRecognitionRule"> | number | null
    conditions?: JsonNullableFilter<"RevenueRecognitionRule">
    metadata?: JsonNullableFilter<"RevenueRecognitionRule">
    createdAt?: DateTimeFilter<"RevenueRecognitionRule"> | Date | string
    updatedAt?: DateTimeFilter<"RevenueRecognitionRule"> | Date | string
    plan?: XOR<PlanRelationFilter, PlanWhereInput>
  }

  export type RevenueRecognitionRuleOrderByWithRelationInput = {
    id?: SortOrder
    planId?: SortOrder
    type?: SortOrder
    deferralPeriod?: SortOrderInput | SortOrder
    conditions?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    plan?: PlanOrderByWithRelationInput
  }

  export type RevenueRecognitionRuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RevenueRecognitionRuleWhereInput | RevenueRecognitionRuleWhereInput[]
    OR?: RevenueRecognitionRuleWhereInput[]
    NOT?: RevenueRecognitionRuleWhereInput | RevenueRecognitionRuleWhereInput[]
    planId?: StringFilter<"RevenueRecognitionRule"> | string
    type?: StringFilter<"RevenueRecognitionRule"> | string
    deferralPeriod?: IntNullableFilter<"RevenueRecognitionRule"> | number | null
    conditions?: JsonNullableFilter<"RevenueRecognitionRule">
    metadata?: JsonNullableFilter<"RevenueRecognitionRule">
    createdAt?: DateTimeFilter<"RevenueRecognitionRule"> | Date | string
    updatedAt?: DateTimeFilter<"RevenueRecognitionRule"> | Date | string
    plan?: XOR<PlanRelationFilter, PlanWhereInput>
  }, "id">

  export type RevenueRecognitionRuleOrderByWithAggregationInput = {
    id?: SortOrder
    planId?: SortOrder
    type?: SortOrder
    deferralPeriod?: SortOrderInput | SortOrder
    conditions?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RevenueRecognitionRuleCountOrderByAggregateInput
    _avg?: RevenueRecognitionRuleAvgOrderByAggregateInput
    _max?: RevenueRecognitionRuleMaxOrderByAggregateInput
    _min?: RevenueRecognitionRuleMinOrderByAggregateInput
    _sum?: RevenueRecognitionRuleSumOrderByAggregateInput
  }

  export type RevenueRecognitionRuleScalarWhereWithAggregatesInput = {
    AND?: RevenueRecognitionRuleScalarWhereWithAggregatesInput | RevenueRecognitionRuleScalarWhereWithAggregatesInput[]
    OR?: RevenueRecognitionRuleScalarWhereWithAggregatesInput[]
    NOT?: RevenueRecognitionRuleScalarWhereWithAggregatesInput | RevenueRecognitionRuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RevenueRecognitionRule"> | string
    planId?: StringWithAggregatesFilter<"RevenueRecognitionRule"> | string
    type?: StringWithAggregatesFilter<"RevenueRecognitionRule"> | string
    deferralPeriod?: IntNullableWithAggregatesFilter<"RevenueRecognitionRule"> | number | null
    conditions?: JsonNullableWithAggregatesFilter<"RevenueRecognitionRule">
    metadata?: JsonNullableWithAggregatesFilter<"RevenueRecognitionRule">
    createdAt?: DateTimeWithAggregatesFilter<"RevenueRecognitionRule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RevenueRecognitionRule"> | Date | string
  }

  export type RevenueLedgerWhereInput = {
    AND?: RevenueLedgerWhereInput | RevenueLedgerWhereInput[]
    OR?: RevenueLedgerWhereInput[]
    NOT?: RevenueLedgerWhereInput | RevenueLedgerWhereInput[]
    id?: StringFilter<"RevenueLedger"> | string
    subscriptionId?: StringFilter<"RevenueLedger"> | string
    amount?: FloatFilter<"RevenueLedger"> | number
    currency?: StringFilter<"RevenueLedger"> | string
    recognizedDate?: DateTimeFilter<"RevenueLedger"> | Date | string
    deferredAmount?: FloatNullableFilter<"RevenueLedger"> | number | null
    deferredUntil?: DateTimeNullableFilter<"RevenueLedger"> | Date | string | null
    type?: StringFilter<"RevenueLedger"> | string
    status?: StringFilter<"RevenueLedger"> | string
    metadata?: JsonNullableFilter<"RevenueLedger">
    createdAt?: DateTimeFilter<"RevenueLedger"> | Date | string
    updatedAt?: DateTimeFilter<"RevenueLedger"> | Date | string
  }

  export type RevenueLedgerOrderByWithRelationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    recognizedDate?: SortOrder
    deferredAmount?: SortOrderInput | SortOrder
    deferredUntil?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RevenueLedgerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RevenueLedgerWhereInput | RevenueLedgerWhereInput[]
    OR?: RevenueLedgerWhereInput[]
    NOT?: RevenueLedgerWhereInput | RevenueLedgerWhereInput[]
    subscriptionId?: StringFilter<"RevenueLedger"> | string
    amount?: FloatFilter<"RevenueLedger"> | number
    currency?: StringFilter<"RevenueLedger"> | string
    recognizedDate?: DateTimeFilter<"RevenueLedger"> | Date | string
    deferredAmount?: FloatNullableFilter<"RevenueLedger"> | number | null
    deferredUntil?: DateTimeNullableFilter<"RevenueLedger"> | Date | string | null
    type?: StringFilter<"RevenueLedger"> | string
    status?: StringFilter<"RevenueLedger"> | string
    metadata?: JsonNullableFilter<"RevenueLedger">
    createdAt?: DateTimeFilter<"RevenueLedger"> | Date | string
    updatedAt?: DateTimeFilter<"RevenueLedger"> | Date | string
  }, "id">

  export type RevenueLedgerOrderByWithAggregationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    recognizedDate?: SortOrder
    deferredAmount?: SortOrderInput | SortOrder
    deferredUntil?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RevenueLedgerCountOrderByAggregateInput
    _avg?: RevenueLedgerAvgOrderByAggregateInput
    _max?: RevenueLedgerMaxOrderByAggregateInput
    _min?: RevenueLedgerMinOrderByAggregateInput
    _sum?: RevenueLedgerSumOrderByAggregateInput
  }

  export type RevenueLedgerScalarWhereWithAggregatesInput = {
    AND?: RevenueLedgerScalarWhereWithAggregatesInput | RevenueLedgerScalarWhereWithAggregatesInput[]
    OR?: RevenueLedgerScalarWhereWithAggregatesInput[]
    NOT?: RevenueLedgerScalarWhereWithAggregatesInput | RevenueLedgerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RevenueLedger"> | string
    subscriptionId?: StringWithAggregatesFilter<"RevenueLedger"> | string
    amount?: FloatWithAggregatesFilter<"RevenueLedger"> | number
    currency?: StringWithAggregatesFilter<"RevenueLedger"> | string
    recognizedDate?: DateTimeWithAggregatesFilter<"RevenueLedger"> | Date | string
    deferredAmount?: FloatNullableWithAggregatesFilter<"RevenueLedger"> | number | null
    deferredUntil?: DateTimeNullableWithAggregatesFilter<"RevenueLedger"> | Date | string | null
    type?: StringWithAggregatesFilter<"RevenueLedger"> | string
    status?: StringWithAggregatesFilter<"RevenueLedger"> | string
    metadata?: JsonNullableWithAggregatesFilter<"RevenueLedger">
    createdAt?: DateTimeWithAggregatesFilter<"RevenueLedger"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RevenueLedger"> | Date | string
  }

  export type ChurnPredictionWhereInput = {
    AND?: ChurnPredictionWhereInput | ChurnPredictionWhereInput[]
    OR?: ChurnPredictionWhereInput[]
    NOT?: ChurnPredictionWhereInput | ChurnPredictionWhereInput[]
    id?: StringFilter<"ChurnPrediction"> | string
    subscriptionId?: StringFilter<"ChurnPrediction"> | string
    probability?: FloatFilter<"ChurnPrediction"> | number
    factors?: JsonFilter<"ChurnPrediction">
    nextBillDate?: DateTimeFilter<"ChurnPrediction"> | Date | string
    predictedDate?: DateTimeFilter<"ChurnPrediction"> | Date | string
    metadata?: JsonNullableFilter<"ChurnPrediction">
    createdAt?: DateTimeFilter<"ChurnPrediction"> | Date | string
    updatedAt?: DateTimeFilter<"ChurnPrediction"> | Date | string
  }

  export type ChurnPredictionOrderByWithRelationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    probability?: SortOrder
    factors?: SortOrder
    nextBillDate?: SortOrder
    predictedDate?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChurnPredictionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChurnPredictionWhereInput | ChurnPredictionWhereInput[]
    OR?: ChurnPredictionWhereInput[]
    NOT?: ChurnPredictionWhereInput | ChurnPredictionWhereInput[]
    subscriptionId?: StringFilter<"ChurnPrediction"> | string
    probability?: FloatFilter<"ChurnPrediction"> | number
    factors?: JsonFilter<"ChurnPrediction">
    nextBillDate?: DateTimeFilter<"ChurnPrediction"> | Date | string
    predictedDate?: DateTimeFilter<"ChurnPrediction"> | Date | string
    metadata?: JsonNullableFilter<"ChurnPrediction">
    createdAt?: DateTimeFilter<"ChurnPrediction"> | Date | string
    updatedAt?: DateTimeFilter<"ChurnPrediction"> | Date | string
  }, "id">

  export type ChurnPredictionOrderByWithAggregationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    probability?: SortOrder
    factors?: SortOrder
    nextBillDate?: SortOrder
    predictedDate?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChurnPredictionCountOrderByAggregateInput
    _avg?: ChurnPredictionAvgOrderByAggregateInput
    _max?: ChurnPredictionMaxOrderByAggregateInput
    _min?: ChurnPredictionMinOrderByAggregateInput
    _sum?: ChurnPredictionSumOrderByAggregateInput
  }

  export type ChurnPredictionScalarWhereWithAggregatesInput = {
    AND?: ChurnPredictionScalarWhereWithAggregatesInput | ChurnPredictionScalarWhereWithAggregatesInput[]
    OR?: ChurnPredictionScalarWhereWithAggregatesInput[]
    NOT?: ChurnPredictionScalarWhereWithAggregatesInput | ChurnPredictionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChurnPrediction"> | string
    subscriptionId?: StringWithAggregatesFilter<"ChurnPrediction"> | string
    probability?: FloatWithAggregatesFilter<"ChurnPrediction"> | number
    factors?: JsonWithAggregatesFilter<"ChurnPrediction">
    nextBillDate?: DateTimeWithAggregatesFilter<"ChurnPrediction"> | Date | string
    predictedDate?: DateTimeWithAggregatesFilter<"ChurnPrediction"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"ChurnPrediction">
    createdAt?: DateTimeWithAggregatesFilter<"ChurnPrediction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChurnPrediction"> | Date | string
  }

  export type CohortAnalysisWhereInput = {
    AND?: CohortAnalysisWhereInput | CohortAnalysisWhereInput[]
    OR?: CohortAnalysisWhereInput[]
    NOT?: CohortAnalysisWhereInput | CohortAnalysisWhereInput[]
    id?: StringFilter<"CohortAnalysis"> | string
    cohortDate?: DateTimeFilter<"CohortAnalysis"> | Date | string
    cohortSize?: IntFilter<"CohortAnalysis"> | number
    metric?: StringFilter<"CohortAnalysis"> | string
    values?: JsonFilter<"CohortAnalysis">
    segment?: StringNullableFilter<"CohortAnalysis"> | string | null
    metadata?: JsonNullableFilter<"CohortAnalysis">
    createdAt?: DateTimeFilter<"CohortAnalysis"> | Date | string
    updatedAt?: DateTimeFilter<"CohortAnalysis"> | Date | string
  }

  export type CohortAnalysisOrderByWithRelationInput = {
    id?: SortOrder
    cohortDate?: SortOrder
    cohortSize?: SortOrder
    metric?: SortOrder
    values?: SortOrder
    segment?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CohortAnalysisWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CohortAnalysisWhereInput | CohortAnalysisWhereInput[]
    OR?: CohortAnalysisWhereInput[]
    NOT?: CohortAnalysisWhereInput | CohortAnalysisWhereInput[]
    cohortDate?: DateTimeFilter<"CohortAnalysis"> | Date | string
    cohortSize?: IntFilter<"CohortAnalysis"> | number
    metric?: StringFilter<"CohortAnalysis"> | string
    values?: JsonFilter<"CohortAnalysis">
    segment?: StringNullableFilter<"CohortAnalysis"> | string | null
    metadata?: JsonNullableFilter<"CohortAnalysis">
    createdAt?: DateTimeFilter<"CohortAnalysis"> | Date | string
    updatedAt?: DateTimeFilter<"CohortAnalysis"> | Date | string
  }, "id">

  export type CohortAnalysisOrderByWithAggregationInput = {
    id?: SortOrder
    cohortDate?: SortOrder
    cohortSize?: SortOrder
    metric?: SortOrder
    values?: SortOrder
    segment?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CohortAnalysisCountOrderByAggregateInput
    _avg?: CohortAnalysisAvgOrderByAggregateInput
    _max?: CohortAnalysisMaxOrderByAggregateInput
    _min?: CohortAnalysisMinOrderByAggregateInput
    _sum?: CohortAnalysisSumOrderByAggregateInput
  }

  export type CohortAnalysisScalarWhereWithAggregatesInput = {
    AND?: CohortAnalysisScalarWhereWithAggregatesInput | CohortAnalysisScalarWhereWithAggregatesInput[]
    OR?: CohortAnalysisScalarWhereWithAggregatesInput[]
    NOT?: CohortAnalysisScalarWhereWithAggregatesInput | CohortAnalysisScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CohortAnalysis"> | string
    cohortDate?: DateTimeWithAggregatesFilter<"CohortAnalysis"> | Date | string
    cohortSize?: IntWithAggregatesFilter<"CohortAnalysis"> | number
    metric?: StringWithAggregatesFilter<"CohortAnalysis"> | string
    values?: JsonWithAggregatesFilter<"CohortAnalysis">
    segment?: StringNullableWithAggregatesFilter<"CohortAnalysis"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"CohortAnalysis">
    createdAt?: DateTimeWithAggregatesFilter<"CohortAnalysis"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CohortAnalysis"> | Date | string
  }

  export type ForecastModelWhereInput = {
    AND?: ForecastModelWhereInput | ForecastModelWhereInput[]
    OR?: ForecastModelWhereInput[]
    NOT?: ForecastModelWhereInput | ForecastModelWhereInput[]
    id?: StringFilter<"ForecastModel"> | string
    name?: StringFilter<"ForecastModel"> | string
    config?: JsonFilter<"ForecastModel">
    metadata?: JsonNullableFilter<"ForecastModel">
    status?: StringFilter<"ForecastModel"> | string
    createdAt?: DateTimeFilter<"ForecastModel"> | Date | string
    lastTraining?: DateTimeNullableFilter<"ForecastModel"> | Date | string | null
    metrics?: JsonNullableFilter<"ForecastModel">
    forecasts?: ForecastResultListRelationFilter
    timeSeriesData?: TimeSeriesDataListRelationFilter
  }

  export type ForecastModelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    config?: SortOrder
    metadata?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    lastTraining?: SortOrderInput | SortOrder
    metrics?: SortOrderInput | SortOrder
    forecasts?: ForecastResultOrderByRelationAggregateInput
    timeSeriesData?: TimeSeriesDataOrderByRelationAggregateInput
  }

  export type ForecastModelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ForecastModelWhereInput | ForecastModelWhereInput[]
    OR?: ForecastModelWhereInput[]
    NOT?: ForecastModelWhereInput | ForecastModelWhereInput[]
    name?: StringFilter<"ForecastModel"> | string
    config?: JsonFilter<"ForecastModel">
    metadata?: JsonNullableFilter<"ForecastModel">
    status?: StringFilter<"ForecastModel"> | string
    createdAt?: DateTimeFilter<"ForecastModel"> | Date | string
    lastTraining?: DateTimeNullableFilter<"ForecastModel"> | Date | string | null
    metrics?: JsonNullableFilter<"ForecastModel">
    forecasts?: ForecastResultListRelationFilter
    timeSeriesData?: TimeSeriesDataListRelationFilter
  }, "id">

  export type ForecastModelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    config?: SortOrder
    metadata?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    lastTraining?: SortOrderInput | SortOrder
    metrics?: SortOrderInput | SortOrder
    _count?: ForecastModelCountOrderByAggregateInput
    _max?: ForecastModelMaxOrderByAggregateInput
    _min?: ForecastModelMinOrderByAggregateInput
  }

  export type ForecastModelScalarWhereWithAggregatesInput = {
    AND?: ForecastModelScalarWhereWithAggregatesInput | ForecastModelScalarWhereWithAggregatesInput[]
    OR?: ForecastModelScalarWhereWithAggregatesInput[]
    NOT?: ForecastModelScalarWhereWithAggregatesInput | ForecastModelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ForecastModel"> | string
    name?: StringWithAggregatesFilter<"ForecastModel"> | string
    config?: JsonWithAggregatesFilter<"ForecastModel">
    metadata?: JsonNullableWithAggregatesFilter<"ForecastModel">
    status?: StringWithAggregatesFilter<"ForecastModel"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ForecastModel"> | Date | string
    lastTraining?: DateTimeNullableWithAggregatesFilter<"ForecastModel"> | Date | string | null
    metrics?: JsonNullableWithAggregatesFilter<"ForecastModel">
  }

  export type TimeSeriesDataWhereInput = {
    AND?: TimeSeriesDataWhereInput | TimeSeriesDataWhereInput[]
    OR?: TimeSeriesDataWhereInput[]
    NOT?: TimeSeriesDataWhereInput | TimeSeriesDataWhereInput[]
    id?: StringFilter<"TimeSeriesData"> | string
    timestamp?: DateTimeFilter<"TimeSeriesData"> | Date | string
    value?: FloatFilter<"TimeSeriesData"> | number
    metadata?: JsonNullableFilter<"TimeSeriesData">
    modelId?: StringFilter<"TimeSeriesData"> | string
    model?: XOR<ForecastModelRelationFilter, ForecastModelWhereInput>
  }

  export type TimeSeriesDataOrderByWithRelationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    value?: SortOrder
    metadata?: SortOrderInput | SortOrder
    modelId?: SortOrder
    model?: ForecastModelOrderByWithRelationInput
  }

  export type TimeSeriesDataWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TimeSeriesDataWhereInput | TimeSeriesDataWhereInput[]
    OR?: TimeSeriesDataWhereInput[]
    NOT?: TimeSeriesDataWhereInput | TimeSeriesDataWhereInput[]
    timestamp?: DateTimeFilter<"TimeSeriesData"> | Date | string
    value?: FloatFilter<"TimeSeriesData"> | number
    metadata?: JsonNullableFilter<"TimeSeriesData">
    modelId?: StringFilter<"TimeSeriesData"> | string
    model?: XOR<ForecastModelRelationFilter, ForecastModelWhereInput>
  }, "id">

  export type TimeSeriesDataOrderByWithAggregationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    value?: SortOrder
    metadata?: SortOrderInput | SortOrder
    modelId?: SortOrder
    _count?: TimeSeriesDataCountOrderByAggregateInput
    _avg?: TimeSeriesDataAvgOrderByAggregateInput
    _max?: TimeSeriesDataMaxOrderByAggregateInput
    _min?: TimeSeriesDataMinOrderByAggregateInput
    _sum?: TimeSeriesDataSumOrderByAggregateInput
  }

  export type TimeSeriesDataScalarWhereWithAggregatesInput = {
    AND?: TimeSeriesDataScalarWhereWithAggregatesInput | TimeSeriesDataScalarWhereWithAggregatesInput[]
    OR?: TimeSeriesDataScalarWhereWithAggregatesInput[]
    NOT?: TimeSeriesDataScalarWhereWithAggregatesInput | TimeSeriesDataScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TimeSeriesData"> | string
    timestamp?: DateTimeWithAggregatesFilter<"TimeSeriesData"> | Date | string
    value?: FloatWithAggregatesFilter<"TimeSeriesData"> | number
    metadata?: JsonNullableWithAggregatesFilter<"TimeSeriesData">
    modelId?: StringWithAggregatesFilter<"TimeSeriesData"> | string
  }

  export type ForecastResultWhereInput = {
    AND?: ForecastResultWhereInput | ForecastResultWhereInput[]
    OR?: ForecastResultWhereInput[]
    NOT?: ForecastResultWhereInput | ForecastResultWhereInput[]
    id?: StringFilter<"ForecastResult"> | string
    timestamp?: DateTimeFilter<"ForecastResult"> | Date | string
    value?: FloatFilter<"ForecastResult"> | number
    lowerBound?: FloatNullableFilter<"ForecastResult"> | number | null
    upperBound?: FloatNullableFilter<"ForecastResult"> | number | null
    confidence?: FloatNullableFilter<"ForecastResult"> | number | null
    metadata?: JsonNullableFilter<"ForecastResult">
    modelId?: StringFilter<"ForecastResult"> | string
    model?: XOR<ForecastModelRelationFilter, ForecastModelWhereInput>
  }

  export type ForecastResultOrderByWithRelationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    value?: SortOrder
    lowerBound?: SortOrderInput | SortOrder
    upperBound?: SortOrderInput | SortOrder
    confidence?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    modelId?: SortOrder
    model?: ForecastModelOrderByWithRelationInput
  }

  export type ForecastResultWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ForecastResultWhereInput | ForecastResultWhereInput[]
    OR?: ForecastResultWhereInput[]
    NOT?: ForecastResultWhereInput | ForecastResultWhereInput[]
    timestamp?: DateTimeFilter<"ForecastResult"> | Date | string
    value?: FloatFilter<"ForecastResult"> | number
    lowerBound?: FloatNullableFilter<"ForecastResult"> | number | null
    upperBound?: FloatNullableFilter<"ForecastResult"> | number | null
    confidence?: FloatNullableFilter<"ForecastResult"> | number | null
    metadata?: JsonNullableFilter<"ForecastResult">
    modelId?: StringFilter<"ForecastResult"> | string
    model?: XOR<ForecastModelRelationFilter, ForecastModelWhereInput>
  }, "id">

  export type ForecastResultOrderByWithAggregationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    value?: SortOrder
    lowerBound?: SortOrderInput | SortOrder
    upperBound?: SortOrderInput | SortOrder
    confidence?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    modelId?: SortOrder
    _count?: ForecastResultCountOrderByAggregateInput
    _avg?: ForecastResultAvgOrderByAggregateInput
    _max?: ForecastResultMaxOrderByAggregateInput
    _min?: ForecastResultMinOrderByAggregateInput
    _sum?: ForecastResultSumOrderByAggregateInput
  }

  export type ForecastResultScalarWhereWithAggregatesInput = {
    AND?: ForecastResultScalarWhereWithAggregatesInput | ForecastResultScalarWhereWithAggregatesInput[]
    OR?: ForecastResultScalarWhereWithAggregatesInput[]
    NOT?: ForecastResultScalarWhereWithAggregatesInput | ForecastResultScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ForecastResult"> | string
    timestamp?: DateTimeWithAggregatesFilter<"ForecastResult"> | Date | string
    value?: FloatWithAggregatesFilter<"ForecastResult"> | number
    lowerBound?: FloatNullableWithAggregatesFilter<"ForecastResult"> | number | null
    upperBound?: FloatNullableWithAggregatesFilter<"ForecastResult"> | number | null
    confidence?: FloatNullableWithAggregatesFilter<"ForecastResult"> | number | null
    metadata?: JsonNullableWithAggregatesFilter<"ForecastResult">
    modelId?: StringWithAggregatesFilter<"ForecastResult"> | string
  }

  export type MarketTrendWhereInput = {
    AND?: MarketTrendWhereInput | MarketTrendWhereInput[]
    OR?: MarketTrendWhereInput[]
    NOT?: MarketTrendWhereInput | MarketTrendWhereInput[]
    id?: StringFilter<"MarketTrend"> | string
    timestamp?: DateTimeFilter<"MarketTrend"> | Date | string
    trend?: FloatFilter<"MarketTrend"> | number
    seasonality?: FloatNullableFilter<"MarketTrend"> | number | null
    metadata?: JsonNullableFilter<"MarketTrend">
  }

  export type MarketTrendOrderByWithRelationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    trend?: SortOrder
    seasonality?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
  }

  export type MarketTrendWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MarketTrendWhereInput | MarketTrendWhereInput[]
    OR?: MarketTrendWhereInput[]
    NOT?: MarketTrendWhereInput | MarketTrendWhereInput[]
    timestamp?: DateTimeFilter<"MarketTrend"> | Date | string
    trend?: FloatFilter<"MarketTrend"> | number
    seasonality?: FloatNullableFilter<"MarketTrend"> | number | null
    metadata?: JsonNullableFilter<"MarketTrend">
  }, "id">

  export type MarketTrendOrderByWithAggregationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    trend?: SortOrder
    seasonality?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: MarketTrendCountOrderByAggregateInput
    _avg?: MarketTrendAvgOrderByAggregateInput
    _max?: MarketTrendMaxOrderByAggregateInput
    _min?: MarketTrendMinOrderByAggregateInput
    _sum?: MarketTrendSumOrderByAggregateInput
  }

  export type MarketTrendScalarWhereWithAggregatesInput = {
    AND?: MarketTrendScalarWhereWithAggregatesInput | MarketTrendScalarWhereWithAggregatesInput[]
    OR?: MarketTrendScalarWhereWithAggregatesInput[]
    NOT?: MarketTrendScalarWhereWithAggregatesInput | MarketTrendScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MarketTrend"> | string
    timestamp?: DateTimeWithAggregatesFilter<"MarketTrend"> | Date | string
    trend?: FloatWithAggregatesFilter<"MarketTrend"> | number
    seasonality?: FloatNullableWithAggregatesFilter<"MarketTrend"> | number | null
    metadata?: JsonNullableWithAggregatesFilter<"MarketTrend">
  }

  export type PredictionIntervalWhereInput = {
    AND?: PredictionIntervalWhereInput | PredictionIntervalWhereInput[]
    OR?: PredictionIntervalWhereInput[]
    NOT?: PredictionIntervalWhereInput | PredictionIntervalWhereInput[]
    id?: StringFilter<"PredictionInterval"> | string
    timestamp?: DateTimeFilter<"PredictionInterval"> | Date | string
    lowerBound?: FloatFilter<"PredictionInterval"> | number
    upperBound?: FloatFilter<"PredictionInterval"> | number
    confidence?: FloatFilter<"PredictionInterval"> | number
    metadata?: JsonNullableFilter<"PredictionInterval">
  }

  export type PredictionIntervalOrderByWithRelationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    lowerBound?: SortOrder
    upperBound?: SortOrder
    confidence?: SortOrder
    metadata?: SortOrderInput | SortOrder
  }

  export type PredictionIntervalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PredictionIntervalWhereInput | PredictionIntervalWhereInput[]
    OR?: PredictionIntervalWhereInput[]
    NOT?: PredictionIntervalWhereInput | PredictionIntervalWhereInput[]
    timestamp?: DateTimeFilter<"PredictionInterval"> | Date | string
    lowerBound?: FloatFilter<"PredictionInterval"> | number
    upperBound?: FloatFilter<"PredictionInterval"> | number
    confidence?: FloatFilter<"PredictionInterval"> | number
    metadata?: JsonNullableFilter<"PredictionInterval">
  }, "id">

  export type PredictionIntervalOrderByWithAggregationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    lowerBound?: SortOrder
    upperBound?: SortOrder
    confidence?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: PredictionIntervalCountOrderByAggregateInput
    _avg?: PredictionIntervalAvgOrderByAggregateInput
    _max?: PredictionIntervalMaxOrderByAggregateInput
    _min?: PredictionIntervalMinOrderByAggregateInput
    _sum?: PredictionIntervalSumOrderByAggregateInput
  }

  export type PredictionIntervalScalarWhereWithAggregatesInput = {
    AND?: PredictionIntervalScalarWhereWithAggregatesInput | PredictionIntervalScalarWhereWithAggregatesInput[]
    OR?: PredictionIntervalScalarWhereWithAggregatesInput[]
    NOT?: PredictionIntervalScalarWhereWithAggregatesInput | PredictionIntervalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PredictionInterval"> | string
    timestamp?: DateTimeWithAggregatesFilter<"PredictionInterval"> | Date | string
    lowerBound?: FloatWithAggregatesFilter<"PredictionInterval"> | number
    upperBound?: FloatWithAggregatesFilter<"PredictionInterval"> | number
    confidence?: FloatWithAggregatesFilter<"PredictionInterval"> | number
    metadata?: JsonNullableWithAggregatesFilter<"PredictionInterval">
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    organizationId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    organizationId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    organization?: OrganizationOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    organizationId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    organizationId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    organizationId?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type ApiKeyWhereInput = {
    AND?: ApiKeyWhereInput | ApiKeyWhereInput[]
    OR?: ApiKeyWhereInput[]
    NOT?: ApiKeyWhereInput | ApiKeyWhereInput[]
    id?: StringFilter<"ApiKey"> | string
    organizationId?: StringFilter<"ApiKey"> | string
    name?: StringFilter<"ApiKey"> | string
    key?: StringFilter<"ApiKey"> | string
    lastUsed?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    updatedAt?: DateTimeFilter<"ApiKey"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
  }

  export type ApiKeyOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    key?: SortOrder
    lastUsed?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
  }

  export type ApiKeyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: ApiKeyWhereInput | ApiKeyWhereInput[]
    OR?: ApiKeyWhereInput[]
    NOT?: ApiKeyWhereInput | ApiKeyWhereInput[]
    organizationId?: StringFilter<"ApiKey"> | string
    name?: StringFilter<"ApiKey"> | string
    lastUsed?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    updatedAt?: DateTimeFilter<"ApiKey"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
  }, "id" | "key">

  export type ApiKeyOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    key?: SortOrder
    lastUsed?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ApiKeyCountOrderByAggregateInput
    _max?: ApiKeyMaxOrderByAggregateInput
    _min?: ApiKeyMinOrderByAggregateInput
  }

  export type ApiKeyScalarWhereWithAggregatesInput = {
    AND?: ApiKeyScalarWhereWithAggregatesInput | ApiKeyScalarWhereWithAggregatesInput[]
    OR?: ApiKeyScalarWhereWithAggregatesInput[]
    NOT?: ApiKeyScalarWhereWithAggregatesInput | ApiKeyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApiKey"> | string
    organizationId?: StringWithAggregatesFilter<"ApiKey"> | string
    name?: StringWithAggregatesFilter<"ApiKey"> | string
    key?: StringWithAggregatesFilter<"ApiKey"> | string
    lastUsed?: DateTimeNullableWithAggregatesFilter<"ApiKey"> | Date | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"ApiKey"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ApiKey"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ApiKey"> | Date | string
  }

  export type TaxCalculationWhereInput = {
    AND?: TaxCalculationWhereInput | TaxCalculationWhereInput[]
    OR?: TaxCalculationWhereInput[]
    NOT?: TaxCalculationWhereInput | TaxCalculationWhereInput[]
    id?: StringFilter<"TaxCalculation"> | string
    customerId?: StringFilter<"TaxCalculation"> | string
    amount?: FloatFilter<"TaxCalculation"> | number
    taxRate?: FloatFilter<"TaxCalculation"> | number
    taxAmount?: FloatFilter<"TaxCalculation"> | number
    country?: StringFilter<"TaxCalculation"> | string
    state?: StringNullableFilter<"TaxCalculation"> | string | null
    createdAt?: DateTimeFilter<"TaxCalculation"> | Date | string
    updatedAt?: DateTimeFilter<"TaxCalculation"> | Date | string
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
  }

  export type TaxCalculationOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    amount?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    country?: SortOrder
    state?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
  }

  export type TaxCalculationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaxCalculationWhereInput | TaxCalculationWhereInput[]
    OR?: TaxCalculationWhereInput[]
    NOT?: TaxCalculationWhereInput | TaxCalculationWhereInput[]
    customerId?: StringFilter<"TaxCalculation"> | string
    amount?: FloatFilter<"TaxCalculation"> | number
    taxRate?: FloatFilter<"TaxCalculation"> | number
    taxAmount?: FloatFilter<"TaxCalculation"> | number
    country?: StringFilter<"TaxCalculation"> | string
    state?: StringNullableFilter<"TaxCalculation"> | string | null
    createdAt?: DateTimeFilter<"TaxCalculation"> | Date | string
    updatedAt?: DateTimeFilter<"TaxCalculation"> | Date | string
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
  }, "id">

  export type TaxCalculationOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    amount?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    country?: SortOrder
    state?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TaxCalculationCountOrderByAggregateInput
    _avg?: TaxCalculationAvgOrderByAggregateInput
    _max?: TaxCalculationMaxOrderByAggregateInput
    _min?: TaxCalculationMinOrderByAggregateInput
    _sum?: TaxCalculationSumOrderByAggregateInput
  }

  export type TaxCalculationScalarWhereWithAggregatesInput = {
    AND?: TaxCalculationScalarWhereWithAggregatesInput | TaxCalculationScalarWhereWithAggregatesInput[]
    OR?: TaxCalculationScalarWhereWithAggregatesInput[]
    NOT?: TaxCalculationScalarWhereWithAggregatesInput | TaxCalculationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TaxCalculation"> | string
    customerId?: StringWithAggregatesFilter<"TaxCalculation"> | string
    amount?: FloatWithAggregatesFilter<"TaxCalculation"> | number
    taxRate?: FloatWithAggregatesFilter<"TaxCalculation"> | number
    taxAmount?: FloatWithAggregatesFilter<"TaxCalculation"> | number
    country?: StringWithAggregatesFilter<"TaxCalculation"> | string
    state?: StringNullableWithAggregatesFilter<"TaxCalculation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TaxCalculation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TaxCalculation"> | Date | string
  }

  export type AlertWhereInput = {
    AND?: AlertWhereInput | AlertWhereInput[]
    OR?: AlertWhereInput[]
    NOT?: AlertWhereInput | AlertWhereInput[]
    id?: StringFilter<"Alert"> | string
    type?: StringFilter<"Alert"> | string
    message?: StringFilter<"Alert"> | string
    severity?: StringFilter<"Alert"> | string
    metadata?: JsonNullableFilter<"Alert">
    resolved?: BoolFilter<"Alert"> | boolean
    createdAt?: DateTimeFilter<"Alert"> | Date | string
    updatedAt?: DateTimeFilter<"Alert"> | Date | string
  }

  export type AlertOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    message?: SortOrder
    severity?: SortOrder
    metadata?: SortOrderInput | SortOrder
    resolved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AlertWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AlertWhereInput | AlertWhereInput[]
    OR?: AlertWhereInput[]
    NOT?: AlertWhereInput | AlertWhereInput[]
    type?: StringFilter<"Alert"> | string
    message?: StringFilter<"Alert"> | string
    severity?: StringFilter<"Alert"> | string
    metadata?: JsonNullableFilter<"Alert">
    resolved?: BoolFilter<"Alert"> | boolean
    createdAt?: DateTimeFilter<"Alert"> | Date | string
    updatedAt?: DateTimeFilter<"Alert"> | Date | string
  }, "id">

  export type AlertOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    message?: SortOrder
    severity?: SortOrder
    metadata?: SortOrderInput | SortOrder
    resolved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AlertCountOrderByAggregateInput
    _max?: AlertMaxOrderByAggregateInput
    _min?: AlertMinOrderByAggregateInput
  }

  export type AlertScalarWhereWithAggregatesInput = {
    AND?: AlertScalarWhereWithAggregatesInput | AlertScalarWhereWithAggregatesInput[]
    OR?: AlertScalarWhereWithAggregatesInput[]
    NOT?: AlertScalarWhereWithAggregatesInput | AlertScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Alert"> | string
    type?: StringWithAggregatesFilter<"Alert"> | string
    message?: StringWithAggregatesFilter<"Alert"> | string
    severity?: StringWithAggregatesFilter<"Alert"> | string
    metadata?: JsonNullableWithAggregatesFilter<"Alert">
    resolved?: BoolWithAggregatesFilter<"Alert"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Alert"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Alert"> | Date | string
  }

  export type TaxRateWhereInput = {
    AND?: TaxRateWhereInput | TaxRateWhereInput[]
    OR?: TaxRateWhereInput[]
    NOT?: TaxRateWhereInput | TaxRateWhereInput[]
    id?: StringFilter<"TaxRate"> | string
    countryCode?: StringFilter<"TaxRate"> | string
    stateCode?: StringNullableFilter<"TaxRate"> | string | null
    name?: StringFilter<"TaxRate"> | string
    rate?: DecimalFilter<"TaxRate"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolFilter<"TaxRate"> | boolean
    isEU?: BoolFilter<"TaxRate"> | boolean
    createdAt?: DateTimeFilter<"TaxRate"> | Date | string
    updatedAt?: DateTimeFilter<"TaxRate"> | Date | string
  }

  export type TaxRateOrderByWithRelationInput = {
    id?: SortOrder
    countryCode?: SortOrder
    stateCode?: SortOrderInput | SortOrder
    name?: SortOrder
    rate?: SortOrder
    isActive?: SortOrder
    isEU?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaxRateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaxRateWhereInput | TaxRateWhereInput[]
    OR?: TaxRateWhereInput[]
    NOT?: TaxRateWhereInput | TaxRateWhereInput[]
    countryCode?: StringFilter<"TaxRate"> | string
    stateCode?: StringNullableFilter<"TaxRate"> | string | null
    name?: StringFilter<"TaxRate"> | string
    rate?: DecimalFilter<"TaxRate"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolFilter<"TaxRate"> | boolean
    isEU?: BoolFilter<"TaxRate"> | boolean
    createdAt?: DateTimeFilter<"TaxRate"> | Date | string
    updatedAt?: DateTimeFilter<"TaxRate"> | Date | string
  }, "id">

  export type TaxRateOrderByWithAggregationInput = {
    id?: SortOrder
    countryCode?: SortOrder
    stateCode?: SortOrderInput | SortOrder
    name?: SortOrder
    rate?: SortOrder
    isActive?: SortOrder
    isEU?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TaxRateCountOrderByAggregateInput
    _avg?: TaxRateAvgOrderByAggregateInput
    _max?: TaxRateMaxOrderByAggregateInput
    _min?: TaxRateMinOrderByAggregateInput
    _sum?: TaxRateSumOrderByAggregateInput
  }

  export type TaxRateScalarWhereWithAggregatesInput = {
    AND?: TaxRateScalarWhereWithAggregatesInput | TaxRateScalarWhereWithAggregatesInput[]
    OR?: TaxRateScalarWhereWithAggregatesInput[]
    NOT?: TaxRateScalarWhereWithAggregatesInput | TaxRateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TaxRate"> | string
    countryCode?: StringWithAggregatesFilter<"TaxRate"> | string
    stateCode?: StringNullableWithAggregatesFilter<"TaxRate"> | string | null
    name?: StringWithAggregatesFilter<"TaxRate"> | string
    rate?: DecimalWithAggregatesFilter<"TaxRate"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolWithAggregatesFilter<"TaxRate"> | boolean
    isEU?: BoolWithAggregatesFilter<"TaxRate"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TaxRate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TaxRate"> | Date | string
  }

  export type BillWhereInput = {
    AND?: BillWhereInput | BillWhereInput[]
    OR?: BillWhereInput[]
    NOT?: BillWhereInput | BillWhereInput[]
    id?: StringFilter<"Bill"> | string
    amount?: FloatFilter<"Bill"> | number
    description?: StringFilter<"Bill"> | string
    status?: StringFilter<"Bill"> | string
    createdAt?: DateTimeFilter<"Bill"> | Date | string
    updatedAt?: DateTimeFilter<"Bill"> | Date | string
  }

  export type BillOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BillWhereInput | BillWhereInput[]
    OR?: BillWhereInput[]
    NOT?: BillWhereInput | BillWhereInput[]
    amount?: FloatFilter<"Bill"> | number
    description?: StringFilter<"Bill"> | string
    status?: StringFilter<"Bill"> | string
    createdAt?: DateTimeFilter<"Bill"> | Date | string
    updatedAt?: DateTimeFilter<"Bill"> | Date | string
  }, "id">

  export type BillOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BillCountOrderByAggregateInput
    _avg?: BillAvgOrderByAggregateInput
    _max?: BillMaxOrderByAggregateInput
    _min?: BillMinOrderByAggregateInput
    _sum?: BillSumOrderByAggregateInput
  }

  export type BillScalarWhereWithAggregatesInput = {
    AND?: BillScalarWhereWithAggregatesInput | BillScalarWhereWithAggregatesInput[]
    OR?: BillScalarWhereWithAggregatesInput[]
    NOT?: BillScalarWhereWithAggregatesInput | BillScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Bill"> | string
    amount?: FloatWithAggregatesFilter<"Bill"> | number
    description?: StringWithAggregatesFilter<"Bill"> | string
    status?: StringWithAggregatesFilter<"Bill"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Bill"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Bill"> | Date | string
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: StringFilter<"Transaction"> | string
    amount?: FloatFilter<"Transaction"> | number
    type?: StringFilter<"Transaction"> | string
    status?: StringFilter<"Transaction"> | string
    metadata?: JsonNullableFilter<"Transaction">
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    amount?: FloatFilter<"Transaction"> | number
    type?: StringFilter<"Transaction"> | string
    status?: StringFilter<"Transaction"> | string
    metadata?: JsonNullableFilter<"Transaction">
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
  }, "id">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transaction"> | string
    amount?: FloatWithAggregatesFilter<"Transaction"> | number
    type?: StringWithAggregatesFilter<"Transaction"> | string
    status?: StringWithAggregatesFilter<"Transaction"> | string
    metadata?: JsonNullableWithAggregatesFilter<"Transaction">
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
  }

  export type RetryAttemptWhereInput = {
    AND?: RetryAttemptWhereInput | RetryAttemptWhereInput[]
    OR?: RetryAttemptWhereInput[]
    NOT?: RetryAttemptWhereInput | RetryAttemptWhereInput[]
    id?: StringFilter<"RetryAttempt"> | string
    invoiceId?: StringFilter<"RetryAttempt"> | string
    userId?: StringFilter<"RetryAttempt"> | string
    attempts?: IntFilter<"RetryAttempt"> | number
    lastAttemptAt?: DateTimeFilter<"RetryAttempt"> | Date | string
    status?: StringFilter<"RetryAttempt"> | string
    createdAt?: DateTimeFilter<"RetryAttempt"> | Date | string
    updatedAt?: DateTimeFilter<"RetryAttempt"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type RetryAttemptOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    userId?: SortOrder
    attempts?: SortOrder
    lastAttemptAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type RetryAttemptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    invoiceId?: string
    AND?: RetryAttemptWhereInput | RetryAttemptWhereInput[]
    OR?: RetryAttemptWhereInput[]
    NOT?: RetryAttemptWhereInput | RetryAttemptWhereInput[]
    userId?: StringFilter<"RetryAttempt"> | string
    attempts?: IntFilter<"RetryAttempt"> | number
    lastAttemptAt?: DateTimeFilter<"RetryAttempt"> | Date | string
    status?: StringFilter<"RetryAttempt"> | string
    createdAt?: DateTimeFilter<"RetryAttempt"> | Date | string
    updatedAt?: DateTimeFilter<"RetryAttempt"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "invoiceId">

  export type RetryAttemptOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    userId?: SortOrder
    attempts?: SortOrder
    lastAttemptAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RetryAttemptCountOrderByAggregateInput
    _avg?: RetryAttemptAvgOrderByAggregateInput
    _max?: RetryAttemptMaxOrderByAggregateInput
    _min?: RetryAttemptMinOrderByAggregateInput
    _sum?: RetryAttemptSumOrderByAggregateInput
  }

  export type RetryAttemptScalarWhereWithAggregatesInput = {
    AND?: RetryAttemptScalarWhereWithAggregatesInput | RetryAttemptScalarWhereWithAggregatesInput[]
    OR?: RetryAttemptScalarWhereWithAggregatesInput[]
    NOT?: RetryAttemptScalarWhereWithAggregatesInput | RetryAttemptScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RetryAttempt"> | string
    invoiceId?: StringWithAggregatesFilter<"RetryAttempt"> | string
    userId?: StringWithAggregatesFilter<"RetryAttempt"> | string
    attempts?: IntWithAggregatesFilter<"RetryAttempt"> | number
    lastAttemptAt?: DateTimeWithAggregatesFilter<"RetryAttempt"> | Date | string
    status?: StringWithAggregatesFilter<"RetryAttempt"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RetryAttempt"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RetryAttempt"> | Date | string
  }

  export type RetryLogWhereInput = {
    AND?: RetryLogWhereInput | RetryLogWhereInput[]
    OR?: RetryLogWhereInput[]
    NOT?: RetryLogWhereInput | RetryLogWhereInput[]
    id?: StringFilter<"RetryLog"> | string
    invoiceId?: StringFilter<"RetryLog"> | string
    userId?: StringFilter<"RetryLog"> | string
    status?: StringFilter<"RetryLog"> | string
    attempts?: IntFilter<"RetryLog"> | number
    createdAt?: DateTimeFilter<"RetryLog"> | Date | string
  }

  export type RetryLogOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    createdAt?: SortOrder
  }

  export type RetryLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RetryLogWhereInput | RetryLogWhereInput[]
    OR?: RetryLogWhereInput[]
    NOT?: RetryLogWhereInput | RetryLogWhereInput[]
    invoiceId?: StringFilter<"RetryLog"> | string
    userId?: StringFilter<"RetryLog"> | string
    status?: StringFilter<"RetryLog"> | string
    attempts?: IntFilter<"RetryLog"> | number
    createdAt?: DateTimeFilter<"RetryLog"> | Date | string
  }, "id">

  export type RetryLogOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    createdAt?: SortOrder
    _count?: RetryLogCountOrderByAggregateInput
    _avg?: RetryLogAvgOrderByAggregateInput
    _max?: RetryLogMaxOrderByAggregateInput
    _min?: RetryLogMinOrderByAggregateInput
    _sum?: RetryLogSumOrderByAggregateInput
  }

  export type RetryLogScalarWhereWithAggregatesInput = {
    AND?: RetryLogScalarWhereWithAggregatesInput | RetryLogScalarWhereWithAggregatesInput[]
    OR?: RetryLogScalarWhereWithAggregatesInput[]
    NOT?: RetryLogScalarWhereWithAggregatesInput | RetryLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RetryLog"> | string
    invoiceId?: StringWithAggregatesFilter<"RetryLog"> | string
    userId?: StringWithAggregatesFilter<"RetryLog"> | string
    status?: StringWithAggregatesFilter<"RetryLog"> | string
    attempts?: IntWithAggregatesFilter<"RetryLog"> | number
    createdAt?: DateTimeWithAggregatesFilter<"RetryLog"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name?: string | null
    email: string
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: string
    notifications?: NotificationCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    retryAttempts?: RetryAttemptCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name?: string | null
    email: string
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: string
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    retryAttempts?: RetryAttemptUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    retryAttempts?: RetryAttemptUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    retryAttempts?: RetryAttemptUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name?: string | null
    email: string
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type OrganizationCreateInput = {
    id?: string
    name: string
    email?: string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationCreateNestedManyWithoutOrganizationInput
    webhooks?: WebhookCreateNestedManyWithoutOrganizationInput
    apiKeys?: ApiKeyCreateNestedManyWithoutOrganizationInput
    carbonEstimates?: CarbonEstimateCreateNestedManyWithoutOrganizationInput
    billingRules?: BillingRuleCreateNestedManyWithoutOrganizationInput
    billingTemplates?: BillingRuleTemplateCreateNestedManyWithoutOrganizationInput
    orders?: OrderCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateInput = {
    id?: string
    name: string
    email?: string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrganizationInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutOrganizationInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutOrganizationInput
    carbonEstimates?: CarbonEstimateUncheckedCreateNestedManyWithoutOrganizationInput
    billingRules?: BillingRuleUncheckedCreateNestedManyWithoutOrganizationInput
    billingTemplates?: BillingRuleTemplateUncheckedCreateNestedManyWithoutOrganizationInput
    orders?: OrderUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUpdateManyWithoutOrganizationNestedInput
    webhooks?: WebhookUpdateManyWithoutOrganizationNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutOrganizationNestedInput
    carbonEstimates?: CarbonEstimateUpdateManyWithoutOrganizationNestedInput
    billingRules?: BillingRuleUpdateManyWithoutOrganizationNestedInput
    billingTemplates?: BillingRuleTemplateUpdateManyWithoutOrganizationNestedInput
    orders?: OrderUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutOrganizationNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutOrganizationNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutOrganizationNestedInput
    carbonEstimates?: CarbonEstimateUncheckedUpdateManyWithoutOrganizationNestedInput
    billingRules?: BillingRuleUncheckedUpdateManyWithoutOrganizationNestedInput
    billingTemplates?: BillingRuleTemplateUncheckedUpdateManyWithoutOrganizationNestedInput
    orders?: OrderUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationCreateManyInput = {
    id?: string
    name: string
    email?: string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateInput = {
    id?: string
    userId: string
    stripeCustomerId?: string | null
    name?: string | null
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentCreateNestedManyWithoutCustomerInput
    subscription?: SubscriptionCreateNestedOneWithoutCustomerInput
    taxCalculations?: TaxCalculationCreateNestedManyWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: string
    userId: string
    stripeCustomerId?: string | null
    name?: string | null
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutCustomerInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutCustomerInput
    taxCalculations?: TaxCalculationUncheckedCreateNestedManyWithoutCustomerInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUpdateManyWithoutCustomerNestedInput
    subscription?: SubscriptionUpdateOneWithoutCustomerNestedInput
    taxCalculations?: TaxCalculationUpdateManyWithoutCustomerNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutCustomerNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutCustomerNestedInput
    taxCalculations?: TaxCalculationUncheckedUpdateManyWithoutCustomerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: string
    userId: string
    stripeCustomerId?: string | null
    name?: string | null
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateInput = {
    id?: string
    status: $Enums.SubscriptionStatus
    stripeSubscriptionId?: string | null
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    cancelledAt?: Date | string | null
    pausedAt?: Date | string | null
    resumesAt?: Date | string | null
    trialEndsAt?: Date | string | null
    billingCycleAnchor: Date | string
    proration?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutSubscriptionInput
    plan: PlanCreateNestedOneWithoutSubscriptionsInput
    payments?: PaymentCreateNestedManyWithoutSubscriptionInput
    usageRecords?: UsageRecordCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: string
    customerId: string
    status: $Enums.SubscriptionStatus
    planId: string
    stripeSubscriptionId?: string | null
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    cancelledAt?: Date | string | null
    pausedAt?: Date | string | null
    resumesAt?: Date | string | null
    trialEndsAt?: Date | string | null
    billingCycleAnchor: Date | string
    proration?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutSubscriptionInput
    usageRecords?: UsageRecordUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resumesAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billingCycleAnchor?: DateTimeFieldUpdateOperationsInput | Date | string
    proration?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutSubscriptionNestedInput
    plan?: PlanUpdateOneRequiredWithoutSubscriptionsNestedInput
    payments?: PaymentUpdateManyWithoutSubscriptionNestedInput
    usageRecords?: UsageRecordUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    planId?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resumesAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billingCycleAnchor?: DateTimeFieldUpdateOperationsInput | Date | string
    proration?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutSubscriptionNestedInput
    usageRecords?: UsageRecordUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionCreateManyInput = {
    id?: string
    customerId: string
    status: $Enums.SubscriptionStatus
    planId: string
    stripeSubscriptionId?: string | null
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    cancelledAt?: Date | string | null
    pausedAt?: Date | string | null
    resumesAt?: Date | string | null
    trialEndsAt?: Date | string | null
    billingCycleAnchor: Date | string
    proration?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resumesAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billingCycleAnchor?: DateTimeFieldUpdateOperationsInput | Date | string
    proration?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    planId?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resumesAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billingCycleAnchor?: DateTimeFieldUpdateOperationsInput | Date | string
    proration?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanCreateInput = {
    id?: string
    name: string
    description?: string | null
    basePrice: number
    currentPrice: number
    currency?: string
    interval?: string
    stripePriceId?: string | null
    isActive?: boolean
    sortOrder?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    marketSegment?: string | null
    costBasis?: number | null
    churnRisk?: number | null
    features?: PlanFeatureCreateNestedManyWithoutPlanInput
    usageLimits?: UsageLimitCreateNestedManyWithoutPlanInput
    priceHistory?: PriceHistoryCreateNestedManyWithoutPlanInput
    priceTests?: PriceTestCreateNestedManyWithoutPlanInput
    revenueRules?: RevenueRecognitionRuleCreateNestedManyWithoutPlanInput
    subscriptions?: SubscriptionCreateNestedManyWithoutPlanInput
  }

  export type PlanUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    basePrice: number
    currentPrice: number
    currency?: string
    interval?: string
    stripePriceId?: string | null
    isActive?: boolean
    sortOrder?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    marketSegment?: string | null
    costBasis?: number | null
    churnRisk?: number | null
    features?: PlanFeatureUncheckedCreateNestedManyWithoutPlanInput
    usageLimits?: UsageLimitUncheckedCreateNestedManyWithoutPlanInput
    priceHistory?: PriceHistoryUncheckedCreateNestedManyWithoutPlanInput
    priceTests?: PriceTestUncheckedCreateNestedManyWithoutPlanInput
    revenueRules?: RevenueRecognitionRuleUncheckedCreateNestedManyWithoutPlanInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    interval?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    marketSegment?: NullableStringFieldUpdateOperationsInput | string | null
    costBasis?: NullableFloatFieldUpdateOperationsInput | number | null
    churnRisk?: NullableFloatFieldUpdateOperationsInput | number | null
    features?: PlanFeatureUpdateManyWithoutPlanNestedInput
    usageLimits?: UsageLimitUpdateManyWithoutPlanNestedInput
    priceHistory?: PriceHistoryUpdateManyWithoutPlanNestedInput
    priceTests?: PriceTestUpdateManyWithoutPlanNestedInput
    revenueRules?: RevenueRecognitionRuleUpdateManyWithoutPlanNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    interval?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    marketSegment?: NullableStringFieldUpdateOperationsInput | string | null
    costBasis?: NullableFloatFieldUpdateOperationsInput | number | null
    churnRisk?: NullableFloatFieldUpdateOperationsInput | number | null
    features?: PlanFeatureUncheckedUpdateManyWithoutPlanNestedInput
    usageLimits?: UsageLimitUncheckedUpdateManyWithoutPlanNestedInput
    priceHistory?: PriceHistoryUncheckedUpdateManyWithoutPlanNestedInput
    priceTests?: PriceTestUncheckedUpdateManyWithoutPlanNestedInput
    revenueRules?: RevenueRecognitionRuleUncheckedUpdateManyWithoutPlanNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type PlanCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    basePrice: number
    currentPrice: number
    currency?: string
    interval?: string
    stripePriceId?: string | null
    isActive?: boolean
    sortOrder?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    marketSegment?: string | null
    costBasis?: number | null
    churnRisk?: number | null
  }

  export type PlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    interval?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    marketSegment?: NullableStringFieldUpdateOperationsInput | string | null
    costBasis?: NullableFloatFieldUpdateOperationsInput | number | null
    churnRisk?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type PlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    interval?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    marketSegment?: NullableStringFieldUpdateOperationsInput | string | null
    costBasis?: NullableFloatFieldUpdateOperationsInput | number | null
    churnRisk?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type PlanFeatureCreateInput = {
    id?: string
    name: string
    description?: string | null
    included?: boolean
    value?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    plan: PlanCreateNestedOneWithoutFeaturesInput
  }

  export type PlanFeatureUncheckedCreateInput = {
    id?: string
    planId: string
    name: string
    description?: string | null
    included?: boolean
    value?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanFeatureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    included?: BoolFieldUpdateOperationsInput | boolean
    value?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneRequiredWithoutFeaturesNestedInput
  }

  export type PlanFeatureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    included?: BoolFieldUpdateOperationsInput | boolean
    value?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanFeatureCreateManyInput = {
    id?: string
    planId: string
    name: string
    description?: string | null
    included?: boolean
    value?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanFeatureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    included?: BoolFieldUpdateOperationsInput | boolean
    value?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanFeatureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    included?: BoolFieldUpdateOperationsInput | boolean
    value?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageLimitCreateInput = {
    id?: string
    featureKey: string
    limit: number
    interval?: string
    overage?: boolean
    overagePrice?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan: PlanCreateNestedOneWithoutUsageLimitsInput
  }

  export type UsageLimitUncheckedCreateInput = {
    id?: string
    planId: string
    featureKey: string
    limit: number
    interval?: string
    overage?: boolean
    overagePrice?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsageLimitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureKey?: StringFieldUpdateOperationsInput | string
    limit?: FloatFieldUpdateOperationsInput | number
    interval?: StringFieldUpdateOperationsInput | string
    overage?: BoolFieldUpdateOperationsInput | boolean
    overagePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneRequiredWithoutUsageLimitsNestedInput
  }

  export type UsageLimitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    featureKey?: StringFieldUpdateOperationsInput | string
    limit?: FloatFieldUpdateOperationsInput | number
    interval?: StringFieldUpdateOperationsInput | string
    overage?: BoolFieldUpdateOperationsInput | boolean
    overagePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageLimitCreateManyInput = {
    id?: string
    planId: string
    featureKey: string
    limit: number
    interval?: string
    overage?: boolean
    overagePrice?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsageLimitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureKey?: StringFieldUpdateOperationsInput | string
    limit?: FloatFieldUpdateOperationsInput | number
    interval?: StringFieldUpdateOperationsInput | string
    overage?: BoolFieldUpdateOperationsInput | boolean
    overagePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageLimitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    featureKey?: StringFieldUpdateOperationsInput | string
    limit?: FloatFieldUpdateOperationsInput | number
    interval?: StringFieldUpdateOperationsInput | string
    overage?: BoolFieldUpdateOperationsInput | boolean
    overagePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateInput = {
    id?: string
    organizationId: string
    amount: number
    currency?: string
    status: string
    stripeInvoiceId?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    organizationId: string
    amount: number
    currency?: string
    status: string
    stripeInvoiceId?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateManyInput = {
    id?: string
    organizationId: string
    amount: number
    currency?: string
    status: string
    stripeInvoiceId?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageRecordCreateInput = {
    id?: string
    featureKey: string
    quantity: number
    timestamp?: Date | string
    billingPeriodStart: Date | string
    billingPeriodEnd: Date | string
    processed?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    subscription: SubscriptionCreateNestedOneWithoutUsageRecordsInput
  }

  export type UsageRecordUncheckedCreateInput = {
    id?: string
    subscriptionId: string
    featureKey: string
    quantity: number
    timestamp?: Date | string
    billingPeriodStart: Date | string
    billingPeriodEnd: Date | string
    processed?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UsageRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureKey?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    billingPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    billingPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    processed?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    subscription?: SubscriptionUpdateOneRequiredWithoutUsageRecordsNestedInput
  }

  export type UsageRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    featureKey?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    billingPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    billingPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    processed?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UsageRecordCreateManyInput = {
    id?: string
    subscriptionId: string
    featureKey: string
    quantity: number
    timestamp?: Date | string
    billingPeriodStart: Date | string
    billingPeriodEnd: Date | string
    processed?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UsageRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureKey?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    billingPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    billingPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    processed?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UsageRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    featureKey?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    billingPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    billingPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    processed?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ReportCreateInput = {
    id?: string
    type: string
    format: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    downloadUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ReportUncheckedCreateInput = {
    id?: string
    type: string
    format: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    downloadUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ReportCreateManyInput = {
    id?: string
    type: string
    format: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    downloadUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MetricCreateInput = {
    id?: string
    name: string
    value: number
    tags?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MetricUncheckedCreateInput = {
    id?: string
    name: string
    value: number
    tags?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MetricUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    tags?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MetricUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    tags?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MetricCreateManyInput = {
    id?: string
    name: string
    value: number
    tags?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MetricUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    tags?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MetricUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    tags?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailNotificationCreateInput = {
    id?: string
    type: string
    status: string
    to: string
    subject: string
    body: string
    sentAt?: Date | string | null
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EmailNotificationUncheckedCreateInput = {
    id?: string
    type: string
    status: string
    to: string
    subject: string
    body: string
    sentAt?: Date | string | null
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EmailNotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EmailNotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EmailNotificationCreateManyInput = {
    id?: string
    type: string
    status: string
    to: string
    subject: string
    body: string
    sentAt?: Date | string | null
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EmailNotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EmailNotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type WebhookCreateInput = {
    id?: string
    url: string
    secret: string
    events?: WebhookCreateeventsInput | string[]
    status?: string
    retryConfig: JsonNullValueInput | InputJsonValue
    lastSuccess?: Date | string | null
    lastFailure?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutWebhooksInput
    deliveries?: WebhookDeliveryCreateNestedManyWithoutWebhookInput
  }

  export type WebhookUncheckedCreateInput = {
    id?: string
    organizationId: string
    url: string
    secret: string
    events?: WebhookCreateeventsInput | string[]
    status?: string
    retryConfig: JsonNullValueInput | InputJsonValue
    lastSuccess?: Date | string | null
    lastFailure?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveries?: WebhookDeliveryUncheckedCreateNestedManyWithoutWebhookInput
  }

  export type WebhookUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    events?: WebhookUpdateeventsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    retryConfig?: JsonNullValueInput | InputJsonValue
    lastSuccess?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFailure?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutWebhooksNestedInput
    deliveries?: WebhookDeliveryUpdateManyWithoutWebhookNestedInput
  }

  export type WebhookUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    events?: WebhookUpdateeventsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    retryConfig?: JsonNullValueInput | InputJsonValue
    lastSuccess?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFailure?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveries?: WebhookDeliveryUncheckedUpdateManyWithoutWebhookNestedInput
  }

  export type WebhookCreateManyInput = {
    id?: string
    organizationId: string
    url: string
    secret: string
    events?: WebhookCreateeventsInput | string[]
    status?: string
    retryConfig: JsonNullValueInput | InputJsonValue
    lastSuccess?: Date | string | null
    lastFailure?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebhookUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    events?: WebhookUpdateeventsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    retryConfig?: JsonNullValueInput | InputJsonValue
    lastSuccess?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFailure?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    events?: WebhookUpdateeventsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    retryConfig?: JsonNullValueInput | InputJsonValue
    lastSuccess?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFailure?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookDeliveryCreateInput = {
    id?: string
    payload: JsonNullValueInput | InputJsonValue
    status: string
    statusCode?: number | null
    response?: string | null
    error?: string | null
    retries?: number
    createdAt?: Date | string
    webhook: WebhookCreateNestedOneWithoutDeliveriesInput
  }

  export type WebhookDeliveryUncheckedCreateInput = {
    id?: string
    webhookId: string
    payload: JsonNullValueInput | InputJsonValue
    status: string
    statusCode?: number | null
    response?: string | null
    error?: string | null
    retries?: number
    createdAt?: Date | string
  }

  export type WebhookDeliveryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    retries?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    webhook?: WebhookUpdateOneRequiredWithoutDeliveriesNestedInput
  }

  export type WebhookDeliveryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    webhookId?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    retries?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookDeliveryCreateManyInput = {
    id?: string
    webhookId: string
    payload: JsonNullValueInput | InputJsonValue
    status: string
    statusCode?: number | null
    response?: string | null
    error?: string | null
    retries?: number
    createdAt?: Date | string
  }

  export type WebhookDeliveryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    retries?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookDeliveryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    webhookId?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    retries?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutRefreshTokensInput
  }

  export type RefreshTokenUncheckedCreateInput = {
    id?: string
    token: string
    userId: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefreshTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRefreshTokensNestedInput
  }

  export type RefreshTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateManyInput = {
    id?: string
    token: string
    userId: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefreshTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    amount: number
    currency?: string
    status: string
    stripePaymentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPaymentsInput
    customer?: CustomerCreateNestedOneWithoutPaymentsInput
    subscription?: SubscriptionCreateNestedOneWithoutPaymentsInput
    order?: OrderCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    amount: number
    currency?: string
    status: string
    stripePaymentId: string
    userId: string
    customerId?: string | null
    subscriptionId?: string | null
    orderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPaymentsNestedInput
    customer?: CustomerUpdateOneWithoutPaymentsNestedInput
    subscription?: SubscriptionUpdateOneWithoutPaymentsNestedInput
    order?: OrderUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    amount: number
    currency?: string
    status: string
    stripePaymentId: string
    userId: string
    customerId?: string | null
    subscriptionId?: string | null
    orderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancingOfferCreateInput = {
    id?: string
    amount: number
    currency: string
    provider: string
    customerId: string
    status: string
    offerId: string
    terms: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FinancingOfferUncheckedCreateInput = {
    id?: string
    amount: number
    currency: string
    provider: string
    customerId: string
    status: string
    offerId: string
    terms: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FinancingOfferUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    offerId?: StringFieldUpdateOperationsInput | string
    terms?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancingOfferUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    offerId?: StringFieldUpdateOperationsInput | string
    terms?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancingOfferCreateManyInput = {
    id?: string
    amount: number
    currency: string
    provider: string
    customerId: string
    status: string
    offerId: string
    terms: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FinancingOfferUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    offerId?: StringFieldUpdateOperationsInput | string
    terms?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancingOfferUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    offerId?: StringFieldUpdateOperationsInput | string
    terms?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CarbonEstimateCreateInput = {
    id?: string
    amount: number
    unit: string
    source: string
    category: string
    timestamp?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutCarbonEstimatesInput
  }

  export type CarbonEstimateUncheckedCreateInput = {
    id?: string
    organizationId: string
    amount: number
    unit: string
    source: string
    category: string
    timestamp?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CarbonEstimateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutCarbonEstimatesNestedInput
  }

  export type CarbonEstimateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CarbonEstimateCreateManyInput = {
    id?: string
    organizationId: string
    amount: number
    unit: string
    source: string
    category: string
    timestamp?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CarbonEstimateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CarbonEstimateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingRuleCreateInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    conditions?: BillingRuleCreateconditionsInput | InputJsonValue[]
    actions?: BillingRuleCreateactionsInput | InputJsonValue[]
    priority?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutBillingRulesInput
  }

  export type BillingRuleUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    conditions?: BillingRuleCreateconditionsInput | InputJsonValue[]
    actions?: BillingRuleCreateactionsInput | InputJsonValue[]
    priority?: number
    isActive?: boolean
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillingRuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    conditions?: BillingRuleUpdateconditionsInput | InputJsonValue[]
    actions?: BillingRuleUpdateactionsInput | InputJsonValue[]
    priority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutBillingRulesNestedInput
  }

  export type BillingRuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    conditions?: BillingRuleUpdateconditionsInput | InputJsonValue[]
    actions?: BillingRuleUpdateactionsInput | InputJsonValue[]
    priority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingRuleCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    conditions?: BillingRuleCreateconditionsInput | InputJsonValue[]
    actions?: BillingRuleCreateactionsInput | InputJsonValue[]
    priority?: number
    isActive?: boolean
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillingRuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    conditions?: BillingRuleUpdateconditionsInput | InputJsonValue[]
    actions?: BillingRuleUpdateactionsInput | InputJsonValue[]
    priority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingRuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    conditions?: BillingRuleUpdateconditionsInput | InputJsonValue[]
    actions?: BillingRuleUpdateactionsInput | InputJsonValue[]
    priority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingRuleTemplateCreateInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    conditions?: BillingRuleTemplateCreateconditionsInput | InputJsonValue[]
    actions?: BillingRuleTemplateCreateactionsInput | InputJsonValue[]
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutBillingTemplatesInput
  }

  export type BillingRuleTemplateUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    conditions?: BillingRuleTemplateCreateconditionsInput | InputJsonValue[]
    actions?: BillingRuleTemplateCreateactionsInput | InputJsonValue[]
    isDefault?: boolean
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillingRuleTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    conditions?: BillingRuleTemplateUpdateconditionsInput | InputJsonValue[]
    actions?: BillingRuleTemplateUpdateactionsInput | InputJsonValue[]
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutBillingTemplatesNestedInput
  }

  export type BillingRuleTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    conditions?: BillingRuleTemplateUpdateconditionsInput | InputJsonValue[]
    actions?: BillingRuleTemplateUpdateactionsInput | InputJsonValue[]
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingRuleTemplateCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    conditions?: BillingRuleTemplateCreateconditionsInput | InputJsonValue[]
    actions?: BillingRuleTemplateCreateactionsInput | InputJsonValue[]
    isDefault?: boolean
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillingRuleTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    conditions?: BillingRuleTemplateUpdateconditionsInput | InputJsonValue[]
    actions?: BillingRuleTemplateUpdateactionsInput | InputJsonValue[]
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingRuleTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    conditions?: BillingRuleTemplateUpdateconditionsInput | InputJsonValue[]
    actions?: BillingRuleTemplateUpdateactionsInput | InputJsonValue[]
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateInput = {
    id?: string
    amount: number
    currency: string
    status: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutOrdersInput
    customer: CustomerCreateNestedOneWithoutOrdersInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    organizationId: string
    customerId: string
    amount: number
    currency: string
    status: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutOrdersNestedInput
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: string
    organizationId: string
    customerId: string
    amount: number
    currency: string
    status: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceHistoryCreateInput = {
    id?: string
    price: number
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    reason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    plan: PlanCreateNestedOneWithoutPriceHistoryInput
  }

  export type PriceHistoryUncheckedCreateInput = {
    id?: string
    planId: string
    price: number
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    reason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PriceHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneRequiredWithoutPriceHistoryNestedInput
  }

  export type PriceHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceHistoryCreateManyInput = {
    id?: string
    planId: string
    price: number
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    reason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PriceHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceTestCreateInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    status: string
    targetMetric: string
    minConfidence: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    plan: PlanCreateNestedOneWithoutPriceTestsInput
    variants?: PriceTestVariantCreateNestedManyWithoutTestInput
  }

  export type PriceTestUncheckedCreateInput = {
    id?: string
    planId: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    status: string
    targetMetric: string
    minConfidence: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    variants?: PriceTestVariantUncheckedCreateNestedManyWithoutTestInput
  }

  export type PriceTestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    targetMetric?: StringFieldUpdateOperationsInput | string
    minConfidence?: FloatFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneRequiredWithoutPriceTestsNestedInput
    variants?: PriceTestVariantUpdateManyWithoutTestNestedInput
  }

  export type PriceTestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    targetMetric?: StringFieldUpdateOperationsInput | string
    minConfidence?: FloatFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variants?: PriceTestVariantUncheckedUpdateManyWithoutTestNestedInput
  }

  export type PriceTestCreateManyInput = {
    id?: string
    planId: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    status: string
    targetMetric: string
    minConfidence: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PriceTestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    targetMetric?: StringFieldUpdateOperationsInput | string
    minConfidence?: FloatFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceTestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    targetMetric?: StringFieldUpdateOperationsInput | string
    minConfidence?: FloatFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceTestVariantCreateInput = {
    id?: string
    price: number
    name: string
    description?: string | null
    conversionRate?: number | null
    revenue?: number | null
    subscribers?: number
    isControl?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    test: PriceTestCreateNestedOneWithoutVariantsInput
  }

  export type PriceTestVariantUncheckedCreateInput = {
    id?: string
    testId: string
    price: number
    name: string
    description?: string | null
    conversionRate?: number | null
    revenue?: number | null
    subscribers?: number
    isControl?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PriceTestVariantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    conversionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    subscribers?: IntFieldUpdateOperationsInput | number
    isControl?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    test?: PriceTestUpdateOneRequiredWithoutVariantsNestedInput
  }

  export type PriceTestVariantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    conversionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    subscribers?: IntFieldUpdateOperationsInput | number
    isControl?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceTestVariantCreateManyInput = {
    id?: string
    testId: string
    price: number
    name: string
    description?: string | null
    conversionRate?: number | null
    revenue?: number | null
    subscribers?: number
    isControl?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PriceTestVariantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    conversionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    subscribers?: IntFieldUpdateOperationsInput | number
    isControl?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceTestVariantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    conversionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    subscribers?: IntFieldUpdateOperationsInput | number
    isControl?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketBenchmarkCreateInput = {
    id?: string
    segment: string
    productType: string
    avgPrice: number
    medianPrice: number
    minPrice: number
    maxPrice: number
    sampleSize: number
    source: string
    collectedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MarketBenchmarkUncheckedCreateInput = {
    id?: string
    segment: string
    productType: string
    avgPrice: number
    medianPrice: number
    minPrice: number
    maxPrice: number
    sampleSize: number
    source: string
    collectedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MarketBenchmarkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    segment?: StringFieldUpdateOperationsInput | string
    productType?: StringFieldUpdateOperationsInput | string
    avgPrice?: FloatFieldUpdateOperationsInput | number
    medianPrice?: FloatFieldUpdateOperationsInput | number
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    sampleSize?: IntFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MarketBenchmarkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    segment?: StringFieldUpdateOperationsInput | string
    productType?: StringFieldUpdateOperationsInput | string
    avgPrice?: FloatFieldUpdateOperationsInput | number
    medianPrice?: FloatFieldUpdateOperationsInput | number
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    sampleSize?: IntFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MarketBenchmarkCreateManyInput = {
    id?: string
    segment: string
    productType: string
    avgPrice: number
    medianPrice: number
    minPrice: number
    maxPrice: number
    sampleSize: number
    source: string
    collectedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MarketBenchmarkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    segment?: StringFieldUpdateOperationsInput | string
    productType?: StringFieldUpdateOperationsInput | string
    avgPrice?: FloatFieldUpdateOperationsInput | number
    medianPrice?: FloatFieldUpdateOperationsInput | number
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    sampleSize?: IntFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MarketBenchmarkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    segment?: StringFieldUpdateOperationsInput | string
    productType?: StringFieldUpdateOperationsInput | string
    avgPrice?: FloatFieldUpdateOperationsInput | number
    medianPrice?: FloatFieldUpdateOperationsInput | number
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    sampleSize?: IntFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RevenueRecognitionRuleCreateInput = {
    id?: string
    type: string
    deferralPeriod?: number | null
    conditions?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    plan: PlanCreateNestedOneWithoutRevenueRulesInput
  }

  export type RevenueRecognitionRuleUncheckedCreateInput = {
    id?: string
    planId: string
    type: string
    deferralPeriod?: number | null
    conditions?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RevenueRecognitionRuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    deferralPeriod?: NullableIntFieldUpdateOperationsInput | number | null
    conditions?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneRequiredWithoutRevenueRulesNestedInput
  }

  export type RevenueRecognitionRuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    deferralPeriod?: NullableIntFieldUpdateOperationsInput | number | null
    conditions?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RevenueRecognitionRuleCreateManyInput = {
    id?: string
    planId: string
    type: string
    deferralPeriod?: number | null
    conditions?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RevenueRecognitionRuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    deferralPeriod?: NullableIntFieldUpdateOperationsInput | number | null
    conditions?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RevenueRecognitionRuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    deferralPeriod?: NullableIntFieldUpdateOperationsInput | number | null
    conditions?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RevenueLedgerCreateInput = {
    id?: string
    subscriptionId: string
    amount: number
    currency: string
    recognizedDate: Date | string
    deferredAmount?: number | null
    deferredUntil?: Date | string | null
    type: string
    status: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RevenueLedgerUncheckedCreateInput = {
    id?: string
    subscriptionId: string
    amount: number
    currency: string
    recognizedDate: Date | string
    deferredAmount?: number | null
    deferredUntil?: Date | string | null
    type: string
    status: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RevenueLedgerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    recognizedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deferredAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    deferredUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RevenueLedgerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    recognizedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deferredAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    deferredUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RevenueLedgerCreateManyInput = {
    id?: string
    subscriptionId: string
    amount: number
    currency: string
    recognizedDate: Date | string
    deferredAmount?: number | null
    deferredUntil?: Date | string | null
    type: string
    status: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RevenueLedgerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    recognizedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deferredAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    deferredUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RevenueLedgerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    recognizedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deferredAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    deferredUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChurnPredictionCreateInput = {
    id?: string
    subscriptionId: string
    probability: number
    factors: JsonNullValueInput | InputJsonValue
    nextBillDate: Date | string
    predictedDate?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChurnPredictionUncheckedCreateInput = {
    id?: string
    subscriptionId: string
    probability: number
    factors: JsonNullValueInput | InputJsonValue
    nextBillDate: Date | string
    predictedDate?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChurnPredictionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    probability?: FloatFieldUpdateOperationsInput | number
    factors?: JsonNullValueInput | InputJsonValue
    nextBillDate?: DateTimeFieldUpdateOperationsInput | Date | string
    predictedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChurnPredictionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    probability?: FloatFieldUpdateOperationsInput | number
    factors?: JsonNullValueInput | InputJsonValue
    nextBillDate?: DateTimeFieldUpdateOperationsInput | Date | string
    predictedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChurnPredictionCreateManyInput = {
    id?: string
    subscriptionId: string
    probability: number
    factors: JsonNullValueInput | InputJsonValue
    nextBillDate: Date | string
    predictedDate?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChurnPredictionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    probability?: FloatFieldUpdateOperationsInput | number
    factors?: JsonNullValueInput | InputJsonValue
    nextBillDate?: DateTimeFieldUpdateOperationsInput | Date | string
    predictedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChurnPredictionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    probability?: FloatFieldUpdateOperationsInput | number
    factors?: JsonNullValueInput | InputJsonValue
    nextBillDate?: DateTimeFieldUpdateOperationsInput | Date | string
    predictedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CohortAnalysisCreateInput = {
    id?: string
    cohortDate: Date | string
    cohortSize: number
    metric: string
    values: JsonNullValueInput | InputJsonValue
    segment?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CohortAnalysisUncheckedCreateInput = {
    id?: string
    cohortDate: Date | string
    cohortSize: number
    metric: string
    values: JsonNullValueInput | InputJsonValue
    segment?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CohortAnalysisUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cohortDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cohortSize?: IntFieldUpdateOperationsInput | number
    metric?: StringFieldUpdateOperationsInput | string
    values?: JsonNullValueInput | InputJsonValue
    segment?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CohortAnalysisUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cohortDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cohortSize?: IntFieldUpdateOperationsInput | number
    metric?: StringFieldUpdateOperationsInput | string
    values?: JsonNullValueInput | InputJsonValue
    segment?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CohortAnalysisCreateManyInput = {
    id?: string
    cohortDate: Date | string
    cohortSize: number
    metric: string
    values: JsonNullValueInput | InputJsonValue
    segment?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CohortAnalysisUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cohortDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cohortSize?: IntFieldUpdateOperationsInput | number
    metric?: StringFieldUpdateOperationsInput | string
    values?: JsonNullValueInput | InputJsonValue
    segment?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CohortAnalysisUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cohortDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cohortSize?: IntFieldUpdateOperationsInput | number
    metric?: StringFieldUpdateOperationsInput | string
    values?: JsonNullValueInput | InputJsonValue
    segment?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForecastModelCreateInput = {
    id?: string
    name: string
    config: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    lastTraining?: Date | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    forecasts?: ForecastResultCreateNestedManyWithoutModelInput
    timeSeriesData?: TimeSeriesDataCreateNestedManyWithoutModelInput
  }

  export type ForecastModelUncheckedCreateInput = {
    id?: string
    name: string
    config: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    lastTraining?: Date | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    forecasts?: ForecastResultUncheckedCreateNestedManyWithoutModelInput
    timeSeriesData?: TimeSeriesDataUncheckedCreateNestedManyWithoutModelInput
  }

  export type ForecastModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastTraining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    forecasts?: ForecastResultUpdateManyWithoutModelNestedInput
    timeSeriesData?: TimeSeriesDataUpdateManyWithoutModelNestedInput
  }

  export type ForecastModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastTraining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    forecasts?: ForecastResultUncheckedUpdateManyWithoutModelNestedInput
    timeSeriesData?: TimeSeriesDataUncheckedUpdateManyWithoutModelNestedInput
  }

  export type ForecastModelCreateManyInput = {
    id?: string
    name: string
    config: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    lastTraining?: Date | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ForecastModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastTraining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ForecastModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastTraining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TimeSeriesDataCreateInput = {
    id?: string
    timestamp: Date | string
    value: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    model: ForecastModelCreateNestedOneWithoutTimeSeriesDataInput
  }

  export type TimeSeriesDataUncheckedCreateInput = {
    id?: string
    timestamp: Date | string
    value: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    modelId: string
  }

  export type TimeSeriesDataUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    model?: ForecastModelUpdateOneRequiredWithoutTimeSeriesDataNestedInput
  }

  export type TimeSeriesDataUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    modelId?: StringFieldUpdateOperationsInput | string
  }

  export type TimeSeriesDataCreateManyInput = {
    id?: string
    timestamp: Date | string
    value: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    modelId: string
  }

  export type TimeSeriesDataUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TimeSeriesDataUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    modelId?: StringFieldUpdateOperationsInput | string
  }

  export type ForecastResultCreateInput = {
    id?: string
    timestamp: Date | string
    value: number
    lowerBound?: number | null
    upperBound?: number | null
    confidence?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    model: ForecastModelCreateNestedOneWithoutForecastsInput
  }

  export type ForecastResultUncheckedCreateInput = {
    id?: string
    timestamp: Date | string
    value: number
    lowerBound?: number | null
    upperBound?: number | null
    confidence?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    modelId: string
  }

  export type ForecastResultUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    lowerBound?: NullableFloatFieldUpdateOperationsInput | number | null
    upperBound?: NullableFloatFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    model?: ForecastModelUpdateOneRequiredWithoutForecastsNestedInput
  }

  export type ForecastResultUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    lowerBound?: NullableFloatFieldUpdateOperationsInput | number | null
    upperBound?: NullableFloatFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    modelId?: StringFieldUpdateOperationsInput | string
  }

  export type ForecastResultCreateManyInput = {
    id?: string
    timestamp: Date | string
    value: number
    lowerBound?: number | null
    upperBound?: number | null
    confidence?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    modelId: string
  }

  export type ForecastResultUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    lowerBound?: NullableFloatFieldUpdateOperationsInput | number | null
    upperBound?: NullableFloatFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ForecastResultUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    lowerBound?: NullableFloatFieldUpdateOperationsInput | number | null
    upperBound?: NullableFloatFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    modelId?: StringFieldUpdateOperationsInput | string
  }

  export type MarketTrendCreateInput = {
    id?: string
    timestamp: Date | string
    trend: number
    seasonality?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MarketTrendUncheckedCreateInput = {
    id?: string
    timestamp: Date | string
    trend: number
    seasonality?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MarketTrendUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    trend?: FloatFieldUpdateOperationsInput | number
    seasonality?: NullableFloatFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MarketTrendUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    trend?: FloatFieldUpdateOperationsInput | number
    seasonality?: NullableFloatFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MarketTrendCreateManyInput = {
    id?: string
    timestamp: Date | string
    trend: number
    seasonality?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MarketTrendUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    trend?: FloatFieldUpdateOperationsInput | number
    seasonality?: NullableFloatFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MarketTrendUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    trend?: FloatFieldUpdateOperationsInput | number
    seasonality?: NullableFloatFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PredictionIntervalCreateInput = {
    id?: string
    timestamp: Date | string
    lowerBound: number
    upperBound: number
    confidence: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PredictionIntervalUncheckedCreateInput = {
    id?: string
    timestamp: Date | string
    lowerBound: number
    upperBound: number
    confidence: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PredictionIntervalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    lowerBound?: FloatFieldUpdateOperationsInput | number
    upperBound?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PredictionIntervalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    lowerBound?: FloatFieldUpdateOperationsInput | number
    upperBound?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PredictionIntervalCreateManyInput = {
    id?: string
    timestamp: Date | string
    lowerBound: number
    upperBound: number
    confidence: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PredictionIntervalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    lowerBound?: FloatFieldUpdateOperationsInput | number
    upperBound?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PredictionIntervalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    lowerBound?: FloatFieldUpdateOperationsInput | number
    upperBound?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationCreateInput = {
    id?: string
    type: string
    message: string
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
    organization: OrganizationCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    organizationId: string
    type: string
    message: string
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    organizationId: string
    type: string
    message: string
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyCreateInput = {
    id?: string
    name: string
    key: string
    lastUsed?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutApiKeysInput
  }

  export type ApiKeyUncheckedCreateInput = {
    id?: string
    organizationId: string
    name: string
    key: string
    lastUsed?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiKeyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutApiKeysNestedInput
  }

  export type ApiKeyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyCreateManyInput = {
    id?: string
    organizationId: string
    name: string
    key: string
    lastUsed?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiKeyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxCalculationCreateInput = {
    id?: string
    amount: number
    taxRate: number
    taxAmount: number
    country: string
    state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutTaxCalculationsInput
  }

  export type TaxCalculationUncheckedCreateInput = {
    id?: string
    customerId: string
    amount: number
    taxRate: number
    taxAmount: number
    country: string
    state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxCalculationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutTaxCalculationsNestedInput
  }

  export type TaxCalculationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxCalculationCreateManyInput = {
    id?: string
    customerId: string
    amount: number
    taxRate: number
    taxAmount: number
    country: string
    state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxCalculationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxCalculationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertCreateInput = {
    id?: string
    type: string
    message: string
    severity: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    resolved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlertUncheckedCreateInput = {
    id?: string
    type: string
    message: string
    severity: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    resolved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlertUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    resolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    resolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertCreateManyInput = {
    id?: string
    type: string
    message: string
    severity: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    resolved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlertUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    resolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    resolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxRateCreateInput = {
    id?: string
    countryCode: string
    stateCode?: string | null
    name: string
    rate: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    isEU?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxRateUncheckedCreateInput = {
    id?: string
    countryCode: string
    stateCode?: string | null
    name: string
    rate: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    isEU?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxRateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    stateCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEU?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxRateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    stateCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEU?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxRateCreateManyInput = {
    id?: string
    countryCode: string
    stateCode?: string | null
    name: string
    rate: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    isEU?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxRateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    stateCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEU?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxRateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    stateCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEU?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillCreateInput = {
    id?: string
    amount: number
    description: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillUncheckedCreateInput = {
    id?: string
    amount: number
    description: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillCreateManyInput = {
    id?: string
    amount: number
    description: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateInput = {
    id?: string
    amount: number
    type: string
    status: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUncheckedCreateInput = {
    id?: string
    amount: number
    type: string
    status: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyInput = {
    id?: string
    amount: number
    type: string
    status: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RetryAttemptCreateInput = {
    id?: string
    invoiceId: string
    attempts?: number
    lastAttemptAt?: Date | string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutRetryAttemptsInput
  }

  export type RetryAttemptUncheckedCreateInput = {
    id?: string
    invoiceId: string
    userId: string
    attempts?: number
    lastAttemptAt?: Date | string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RetryAttemptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    lastAttemptAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRetryAttemptsNestedInput
  }

  export type RetryAttemptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    lastAttemptAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RetryAttemptCreateManyInput = {
    id?: string
    invoiceId: string
    userId: string
    attempts?: number
    lastAttemptAt?: Date | string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RetryAttemptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    lastAttemptAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RetryAttemptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    lastAttemptAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RetryLogCreateInput = {
    id?: string
    invoiceId: string
    userId: string
    status: string
    attempts: number
    createdAt?: Date | string
  }

  export type RetryLogUncheckedCreateInput = {
    id?: string
    invoiceId: string
    userId: string
    status: string
    attempts: number
    createdAt?: Date | string
  }

  export type RetryLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RetryLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RetryLogCreateManyInput = {
    id?: string
    invoiceId: string
    userId: string
    status: string
    attempts: number
    createdAt?: Date | string
  }

  export type RetryLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RetryLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type RefreshTokenListRelationFilter = {
    every?: RefreshTokenWhereInput
    some?: RefreshTokenWhereInput
    none?: RefreshTokenWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type RetryAttemptListRelationFilter = {
    every?: RetryAttemptWhereInput
    some?: RetryAttemptWhereInput
    none?: RetryAttemptWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RefreshTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RetryAttemptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type WebhookListRelationFilter = {
    every?: WebhookWhereInput
    some?: WebhookWhereInput
    none?: WebhookWhereInput
  }

  export type ApiKeyListRelationFilter = {
    every?: ApiKeyWhereInput
    some?: ApiKeyWhereInput
    none?: ApiKeyWhereInput
  }

  export type CarbonEstimateListRelationFilter = {
    every?: CarbonEstimateWhereInput
    some?: CarbonEstimateWhereInput
    none?: CarbonEstimateWhereInput
  }

  export type BillingRuleListRelationFilter = {
    every?: BillingRuleWhereInput
    some?: BillingRuleWhereInput
    none?: BillingRuleWhereInput
  }

  export type BillingRuleTemplateListRelationFilter = {
    every?: BillingRuleTemplateWhereInput
    some?: BillingRuleTemplateWhereInput
    none?: BillingRuleTemplateWhereInput
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type WebhookOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApiKeyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CarbonEstimateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BillingRuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BillingRuleTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    stripeCustomerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    stripeCustomerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    stripeCustomerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionNullableRelationFilter = {
    is?: SubscriptionWhereInput | null
    isNot?: SubscriptionWhereInput | null
  }

  export type TaxCalculationListRelationFilter = {
    every?: TaxCalculationWhereInput
    some?: TaxCalculationWhereInput
    none?: TaxCalculationWhereInput
  }

  export type TaxCalculationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    stripeCustomerId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    stripeCustomerId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    stripeCustomerId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type CustomerRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type PlanRelationFilter = {
    is?: PlanWhereInput
    isNot?: PlanWhereInput
  }

  export type UsageRecordListRelationFilter = {
    every?: UsageRecordWhereInput
    some?: UsageRecordWhereInput
    none?: UsageRecordWhereInput
  }

  export type UsageRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    status?: SortOrder
    planId?: SortOrder
    stripeSubscriptionId?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    cancelledAt?: SortOrder
    pausedAt?: SortOrder
    resumesAt?: SortOrder
    trialEndsAt?: SortOrder
    billingCycleAnchor?: SortOrder
    proration?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    status?: SortOrder
    planId?: SortOrder
    stripeSubscriptionId?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    cancelledAt?: SortOrder
    pausedAt?: SortOrder
    resumesAt?: SortOrder
    trialEndsAt?: SortOrder
    billingCycleAnchor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    status?: SortOrder
    planId?: SortOrder
    stripeSubscriptionId?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    cancelledAt?: SortOrder
    pausedAt?: SortOrder
    resumesAt?: SortOrder
    trialEndsAt?: SortOrder
    billingCycleAnchor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type PlanFeatureListRelationFilter = {
    every?: PlanFeatureWhereInput
    some?: PlanFeatureWhereInput
    none?: PlanFeatureWhereInput
  }

  export type UsageLimitListRelationFilter = {
    every?: UsageLimitWhereInput
    some?: UsageLimitWhereInput
    none?: UsageLimitWhereInput
  }

  export type PriceHistoryListRelationFilter = {
    every?: PriceHistoryWhereInput
    some?: PriceHistoryWhereInput
    none?: PriceHistoryWhereInput
  }

  export type PriceTestListRelationFilter = {
    every?: PriceTestWhereInput
    some?: PriceTestWhereInput
    none?: PriceTestWhereInput
  }

  export type RevenueRecognitionRuleListRelationFilter = {
    every?: RevenueRecognitionRuleWhereInput
    some?: RevenueRecognitionRuleWhereInput
    none?: RevenueRecognitionRuleWhereInput
  }

  export type SubscriptionListRelationFilter = {
    every?: SubscriptionWhereInput
    some?: SubscriptionWhereInput
    none?: SubscriptionWhereInput
  }

  export type PlanFeatureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsageLimitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PriceHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PriceTestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RevenueRecognitionRuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlanCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    basePrice?: SortOrder
    currentPrice?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    stripePriceId?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    marketSegment?: SortOrder
    costBasis?: SortOrder
    churnRisk?: SortOrder
  }

  export type PlanAvgOrderByAggregateInput = {
    basePrice?: SortOrder
    currentPrice?: SortOrder
    sortOrder?: SortOrder
    costBasis?: SortOrder
    churnRisk?: SortOrder
  }

  export type PlanMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    basePrice?: SortOrder
    currentPrice?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    stripePriceId?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    marketSegment?: SortOrder
    costBasis?: SortOrder
    churnRisk?: SortOrder
  }

  export type PlanMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    basePrice?: SortOrder
    currentPrice?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    stripePriceId?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    marketSegment?: SortOrder
    costBasis?: SortOrder
    churnRisk?: SortOrder
  }

  export type PlanSumOrderByAggregateInput = {
    basePrice?: SortOrder
    currentPrice?: SortOrder
    sortOrder?: SortOrder
    costBasis?: SortOrder
    churnRisk?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type PlanFeatureCountOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    included?: SortOrder
    value?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanFeatureAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type PlanFeatureMaxOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    included?: SortOrder
    value?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanFeatureMinOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    included?: SortOrder
    value?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanFeatureSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type UsageLimitCountOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    featureKey?: SortOrder
    limit?: SortOrder
    interval?: SortOrder
    overage?: SortOrder
    overagePrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsageLimitAvgOrderByAggregateInput = {
    limit?: SortOrder
    overagePrice?: SortOrder
  }

  export type UsageLimitMaxOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    featureKey?: SortOrder
    limit?: SortOrder
    interval?: SortOrder
    overage?: SortOrder
    overagePrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsageLimitMinOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    featureKey?: SortOrder
    limit?: SortOrder
    interval?: SortOrder
    overage?: SortOrder
    overagePrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsageLimitSumOrderByAggregateInput = {
    limit?: SortOrder
    overagePrice?: SortOrder
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    stripeInvoiceId?: SortOrder
    pdfUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    stripeInvoiceId?: SortOrder
    pdfUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    stripeInvoiceId?: SortOrder
    pdfUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type SubscriptionRelationFilter = {
    is?: SubscriptionWhereInput
    isNot?: SubscriptionWhereInput
  }

  export type UsageRecordCountOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    featureKey?: SortOrder
    quantity?: SortOrder
    timestamp?: SortOrder
    billingPeriodStart?: SortOrder
    billingPeriodEnd?: SortOrder
    processed?: SortOrder
    metadata?: SortOrder
  }

  export type UsageRecordAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type UsageRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    featureKey?: SortOrder
    quantity?: SortOrder
    timestamp?: SortOrder
    billingPeriodStart?: SortOrder
    billingPeriodEnd?: SortOrder
    processed?: SortOrder
  }

  export type UsageRecordMinOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    featureKey?: SortOrder
    quantity?: SortOrder
    timestamp?: SortOrder
    billingPeriodStart?: SortOrder
    billingPeriodEnd?: SortOrder
    processed?: SortOrder
  }

  export type UsageRecordSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type ReportCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    format?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    downloadUrl?: SortOrder
    metadata?: SortOrder
  }

  export type ReportMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    format?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    downloadUrl?: SortOrder
  }

  export type ReportMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    format?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    downloadUrl?: SortOrder
  }

  export type MetricCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    tags?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MetricAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type MetricMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MetricMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MetricSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type EmailNotificationCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    to?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
    metadata?: SortOrder
  }

  export type EmailNotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    to?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailNotificationMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    to?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type OrganizationRelationFilter = {
    is?: OrganizationWhereInput
    isNot?: OrganizationWhereInput
  }

  export type WebhookDeliveryListRelationFilter = {
    every?: WebhookDeliveryWhereInput
    some?: WebhookDeliveryWhereInput
    none?: WebhookDeliveryWhereInput
  }

  export type WebhookDeliveryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WebhookCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    events?: SortOrder
    status?: SortOrder
    retryConfig?: SortOrder
    lastSuccess?: SortOrder
    lastFailure?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebhookMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    status?: SortOrder
    lastSuccess?: SortOrder
    lastFailure?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebhookMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    status?: SortOrder
    lastSuccess?: SortOrder
    lastFailure?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type WebhookRelationFilter = {
    is?: WebhookWhereInput
    isNot?: WebhookWhereInput
  }

  export type WebhookDeliveryCountOrderByAggregateInput = {
    id?: SortOrder
    webhookId?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    statusCode?: SortOrder
    response?: SortOrder
    error?: SortOrder
    retries?: SortOrder
    createdAt?: SortOrder
  }

  export type WebhookDeliveryAvgOrderByAggregateInput = {
    statusCode?: SortOrder
    retries?: SortOrder
  }

  export type WebhookDeliveryMaxOrderByAggregateInput = {
    id?: SortOrder
    webhookId?: SortOrder
    status?: SortOrder
    statusCode?: SortOrder
    response?: SortOrder
    error?: SortOrder
    retries?: SortOrder
    createdAt?: SortOrder
  }

  export type WebhookDeliveryMinOrderByAggregateInput = {
    id?: SortOrder
    webhookId?: SortOrder
    status?: SortOrder
    statusCode?: SortOrder
    response?: SortOrder
    error?: SortOrder
    retries?: SortOrder
    createdAt?: SortOrder
  }

  export type WebhookDeliverySumOrderByAggregateInput = {
    statusCode?: SortOrder
    retries?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type RefreshTokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RefreshTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RefreshTokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerNullableRelationFilter = {
    is?: CustomerWhereInput | null
    isNot?: CustomerWhereInput | null
  }

  export type OrderNullableRelationFilter = {
    is?: OrderWhereInput | null
    isNot?: OrderWhereInput | null
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    stripePaymentId?: SortOrder
    userId?: SortOrder
    customerId?: SortOrder
    subscriptionId?: SortOrder
    orderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    stripePaymentId?: SortOrder
    userId?: SortOrder
    customerId?: SortOrder
    subscriptionId?: SortOrder
    orderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    stripePaymentId?: SortOrder
    userId?: SortOrder
    customerId?: SortOrder
    subscriptionId?: SortOrder
    orderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type FinancingOfferCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    provider?: SortOrder
    customerId?: SortOrder
    status?: SortOrder
    offerId?: SortOrder
    terms?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FinancingOfferAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type FinancingOfferMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    provider?: SortOrder
    customerId?: SortOrder
    status?: SortOrder
    offerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FinancingOfferMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    provider?: SortOrder
    customerId?: SortOrder
    status?: SortOrder
    offerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FinancingOfferSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type CarbonEstimateCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    source?: SortOrder
    category?: SortOrder
    timestamp?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CarbonEstimateAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type CarbonEstimateMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    source?: SortOrder
    category?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CarbonEstimateMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    source?: SortOrder
    category?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CarbonEstimateSumOrderByAggregateInput = {
    amount?: SortOrder
  }
  export type JsonNullableListFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableListFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableListFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableListFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableListFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableListFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel> | null
    has?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    hasEvery?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel>
    hasSome?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type BillingRuleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    conditions?: SortOrder
    actions?: SortOrder
    priority?: SortOrder
    isActive?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillingRuleAvgOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type BillingRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    isActive?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillingRuleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    isActive?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillingRuleSumOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type BillingRuleTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    conditions?: SortOrder
    actions?: SortOrder
    isDefault?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillingRuleTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    isDefault?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillingRuleTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    isDefault?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    customerId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    customerId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    customerId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PriceHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    price?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    reason?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type PriceHistoryAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type PriceHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    price?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type PriceHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    price?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type PriceHistorySumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type PriceTestVariantListRelationFilter = {
    every?: PriceTestVariantWhereInput
    some?: PriceTestVariantWhereInput
    none?: PriceTestVariantWhereInput
  }

  export type PriceTestVariantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PriceTestCountOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    targetMetric?: SortOrder
    minConfidence?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PriceTestAvgOrderByAggregateInput = {
    minConfidence?: SortOrder
  }

  export type PriceTestMaxOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    targetMetric?: SortOrder
    minConfidence?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PriceTestMinOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    targetMetric?: SortOrder
    minConfidence?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PriceTestSumOrderByAggregateInput = {
    minConfidence?: SortOrder
  }

  export type PriceTestRelationFilter = {
    is?: PriceTestWhereInput
    isNot?: PriceTestWhereInput
  }

  export type PriceTestVariantCountOrderByAggregateInput = {
    id?: SortOrder
    testId?: SortOrder
    price?: SortOrder
    name?: SortOrder
    description?: SortOrder
    conversionRate?: SortOrder
    revenue?: SortOrder
    subscribers?: SortOrder
    isControl?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PriceTestVariantAvgOrderByAggregateInput = {
    price?: SortOrder
    conversionRate?: SortOrder
    revenue?: SortOrder
    subscribers?: SortOrder
  }

  export type PriceTestVariantMaxOrderByAggregateInput = {
    id?: SortOrder
    testId?: SortOrder
    price?: SortOrder
    name?: SortOrder
    description?: SortOrder
    conversionRate?: SortOrder
    revenue?: SortOrder
    subscribers?: SortOrder
    isControl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PriceTestVariantMinOrderByAggregateInput = {
    id?: SortOrder
    testId?: SortOrder
    price?: SortOrder
    name?: SortOrder
    description?: SortOrder
    conversionRate?: SortOrder
    revenue?: SortOrder
    subscribers?: SortOrder
    isControl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PriceTestVariantSumOrderByAggregateInput = {
    price?: SortOrder
    conversionRate?: SortOrder
    revenue?: SortOrder
    subscribers?: SortOrder
  }

  export type MarketBenchmarkCountOrderByAggregateInput = {
    id?: SortOrder
    segment?: SortOrder
    productType?: SortOrder
    avgPrice?: SortOrder
    medianPrice?: SortOrder
    minPrice?: SortOrder
    maxPrice?: SortOrder
    sampleSize?: SortOrder
    source?: SortOrder
    collectedAt?: SortOrder
    metadata?: SortOrder
  }

  export type MarketBenchmarkAvgOrderByAggregateInput = {
    avgPrice?: SortOrder
    medianPrice?: SortOrder
    minPrice?: SortOrder
    maxPrice?: SortOrder
    sampleSize?: SortOrder
  }

  export type MarketBenchmarkMaxOrderByAggregateInput = {
    id?: SortOrder
    segment?: SortOrder
    productType?: SortOrder
    avgPrice?: SortOrder
    medianPrice?: SortOrder
    minPrice?: SortOrder
    maxPrice?: SortOrder
    sampleSize?: SortOrder
    source?: SortOrder
    collectedAt?: SortOrder
  }

  export type MarketBenchmarkMinOrderByAggregateInput = {
    id?: SortOrder
    segment?: SortOrder
    productType?: SortOrder
    avgPrice?: SortOrder
    medianPrice?: SortOrder
    minPrice?: SortOrder
    maxPrice?: SortOrder
    sampleSize?: SortOrder
    source?: SortOrder
    collectedAt?: SortOrder
  }

  export type MarketBenchmarkSumOrderByAggregateInput = {
    avgPrice?: SortOrder
    medianPrice?: SortOrder
    minPrice?: SortOrder
    maxPrice?: SortOrder
    sampleSize?: SortOrder
  }

  export type RevenueRecognitionRuleCountOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    type?: SortOrder
    deferralPeriod?: SortOrder
    conditions?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RevenueRecognitionRuleAvgOrderByAggregateInput = {
    deferralPeriod?: SortOrder
  }

  export type RevenueRecognitionRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    type?: SortOrder
    deferralPeriod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RevenueRecognitionRuleMinOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    type?: SortOrder
    deferralPeriod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RevenueRecognitionRuleSumOrderByAggregateInput = {
    deferralPeriod?: SortOrder
  }

  export type RevenueLedgerCountOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    recognizedDate?: SortOrder
    deferredAmount?: SortOrder
    deferredUntil?: SortOrder
    type?: SortOrder
    status?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RevenueLedgerAvgOrderByAggregateInput = {
    amount?: SortOrder
    deferredAmount?: SortOrder
  }

  export type RevenueLedgerMaxOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    recognizedDate?: SortOrder
    deferredAmount?: SortOrder
    deferredUntil?: SortOrder
    type?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RevenueLedgerMinOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    recognizedDate?: SortOrder
    deferredAmount?: SortOrder
    deferredUntil?: SortOrder
    type?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RevenueLedgerSumOrderByAggregateInput = {
    amount?: SortOrder
    deferredAmount?: SortOrder
  }

  export type ChurnPredictionCountOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    probability?: SortOrder
    factors?: SortOrder
    nextBillDate?: SortOrder
    predictedDate?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChurnPredictionAvgOrderByAggregateInput = {
    probability?: SortOrder
  }

  export type ChurnPredictionMaxOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    probability?: SortOrder
    nextBillDate?: SortOrder
    predictedDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChurnPredictionMinOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    probability?: SortOrder
    nextBillDate?: SortOrder
    predictedDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChurnPredictionSumOrderByAggregateInput = {
    probability?: SortOrder
  }

  export type CohortAnalysisCountOrderByAggregateInput = {
    id?: SortOrder
    cohortDate?: SortOrder
    cohortSize?: SortOrder
    metric?: SortOrder
    values?: SortOrder
    segment?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CohortAnalysisAvgOrderByAggregateInput = {
    cohortSize?: SortOrder
  }

  export type CohortAnalysisMaxOrderByAggregateInput = {
    id?: SortOrder
    cohortDate?: SortOrder
    cohortSize?: SortOrder
    metric?: SortOrder
    segment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CohortAnalysisMinOrderByAggregateInput = {
    id?: SortOrder
    cohortDate?: SortOrder
    cohortSize?: SortOrder
    metric?: SortOrder
    segment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CohortAnalysisSumOrderByAggregateInput = {
    cohortSize?: SortOrder
  }

  export type ForecastResultListRelationFilter = {
    every?: ForecastResultWhereInput
    some?: ForecastResultWhereInput
    none?: ForecastResultWhereInput
  }

  export type TimeSeriesDataListRelationFilter = {
    every?: TimeSeriesDataWhereInput
    some?: TimeSeriesDataWhereInput
    none?: TimeSeriesDataWhereInput
  }

  export type ForecastResultOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TimeSeriesDataOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ForecastModelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    config?: SortOrder
    metadata?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    lastTraining?: SortOrder
    metrics?: SortOrder
  }

  export type ForecastModelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    lastTraining?: SortOrder
  }

  export type ForecastModelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    lastTraining?: SortOrder
  }

  export type ForecastModelRelationFilter = {
    is?: ForecastModelWhereInput
    isNot?: ForecastModelWhereInput
  }

  export type TimeSeriesDataCountOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    value?: SortOrder
    metadata?: SortOrder
    modelId?: SortOrder
  }

  export type TimeSeriesDataAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type TimeSeriesDataMaxOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    value?: SortOrder
    modelId?: SortOrder
  }

  export type TimeSeriesDataMinOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    value?: SortOrder
    modelId?: SortOrder
  }

  export type TimeSeriesDataSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type ForecastResultCountOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    value?: SortOrder
    lowerBound?: SortOrder
    upperBound?: SortOrder
    confidence?: SortOrder
    metadata?: SortOrder
    modelId?: SortOrder
  }

  export type ForecastResultAvgOrderByAggregateInput = {
    value?: SortOrder
    lowerBound?: SortOrder
    upperBound?: SortOrder
    confidence?: SortOrder
  }

  export type ForecastResultMaxOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    value?: SortOrder
    lowerBound?: SortOrder
    upperBound?: SortOrder
    confidence?: SortOrder
    modelId?: SortOrder
  }

  export type ForecastResultMinOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    value?: SortOrder
    lowerBound?: SortOrder
    upperBound?: SortOrder
    confidence?: SortOrder
    modelId?: SortOrder
  }

  export type ForecastResultSumOrderByAggregateInput = {
    value?: SortOrder
    lowerBound?: SortOrder
    upperBound?: SortOrder
    confidence?: SortOrder
  }

  export type MarketTrendCountOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    trend?: SortOrder
    seasonality?: SortOrder
    metadata?: SortOrder
  }

  export type MarketTrendAvgOrderByAggregateInput = {
    trend?: SortOrder
    seasonality?: SortOrder
  }

  export type MarketTrendMaxOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    trend?: SortOrder
    seasonality?: SortOrder
  }

  export type MarketTrendMinOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    trend?: SortOrder
    seasonality?: SortOrder
  }

  export type MarketTrendSumOrderByAggregateInput = {
    trend?: SortOrder
    seasonality?: SortOrder
  }

  export type PredictionIntervalCountOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    lowerBound?: SortOrder
    upperBound?: SortOrder
    confidence?: SortOrder
    metadata?: SortOrder
  }

  export type PredictionIntervalAvgOrderByAggregateInput = {
    lowerBound?: SortOrder
    upperBound?: SortOrder
    confidence?: SortOrder
  }

  export type PredictionIntervalMaxOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    lowerBound?: SortOrder
    upperBound?: SortOrder
    confidence?: SortOrder
  }

  export type PredictionIntervalMinOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    lowerBound?: SortOrder
    upperBound?: SortOrder
    confidence?: SortOrder
  }

  export type PredictionIntervalSumOrderByAggregateInput = {
    lowerBound?: SortOrder
    upperBound?: SortOrder
    confidence?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    organizationId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    organizationId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    organizationId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApiKeyCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    key?: SortOrder
    lastUsed?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApiKeyMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    key?: SortOrder
    lastUsed?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApiKeyMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    key?: SortOrder
    lastUsed?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaxCalculationCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    amount?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    country?: SortOrder
    state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaxCalculationAvgOrderByAggregateInput = {
    amount?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
  }

  export type TaxCalculationMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    amount?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    country?: SortOrder
    state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaxCalculationMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    amount?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    country?: SortOrder
    state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaxCalculationSumOrderByAggregateInput = {
    amount?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
  }

  export type AlertCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    message?: SortOrder
    severity?: SortOrder
    metadata?: SortOrder
    resolved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AlertMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    message?: SortOrder
    severity?: SortOrder
    resolved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AlertMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    message?: SortOrder
    severity?: SortOrder
    resolved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type TaxRateCountOrderByAggregateInput = {
    id?: SortOrder
    countryCode?: SortOrder
    stateCode?: SortOrder
    name?: SortOrder
    rate?: SortOrder
    isActive?: SortOrder
    isEU?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaxRateAvgOrderByAggregateInput = {
    rate?: SortOrder
  }

  export type TaxRateMaxOrderByAggregateInput = {
    id?: SortOrder
    countryCode?: SortOrder
    stateCode?: SortOrder
    name?: SortOrder
    rate?: SortOrder
    isActive?: SortOrder
    isEU?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaxRateMinOrderByAggregateInput = {
    id?: SortOrder
    countryCode?: SortOrder
    stateCode?: SortOrder
    name?: SortOrder
    rate?: SortOrder
    isActive?: SortOrder
    isEU?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaxRateSumOrderByAggregateInput = {
    rate?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type BillCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type BillMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    status?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type RetryAttemptCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    userId?: SortOrder
    attempts?: SortOrder
    lastAttemptAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RetryAttemptAvgOrderByAggregateInput = {
    attempts?: SortOrder
  }

  export type RetryAttemptMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    userId?: SortOrder
    attempts?: SortOrder
    lastAttemptAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RetryAttemptMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    userId?: SortOrder
    attempts?: SortOrder
    lastAttemptAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RetryAttemptSumOrderByAggregateInput = {
    attempts?: SortOrder
  }

  export type RetryLogCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    createdAt?: SortOrder
  }

  export type RetryLogAvgOrderByAggregateInput = {
    attempts?: SortOrder
  }

  export type RetryLogMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    createdAt?: SortOrder
  }

  export type RetryLogMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    createdAt?: SortOrder
  }

  export type RetryLogSumOrderByAggregateInput = {
    attempts?: SortOrder
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type RefreshTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type RetryAttemptCreateNestedManyWithoutUserInput = {
    create?: XOR<RetryAttemptCreateWithoutUserInput, RetryAttemptUncheckedCreateWithoutUserInput> | RetryAttemptCreateWithoutUserInput[] | RetryAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RetryAttemptCreateOrConnectWithoutUserInput | RetryAttemptCreateOrConnectWithoutUserInput[]
    createMany?: RetryAttemptCreateManyUserInputEnvelope
    connect?: RetryAttemptWhereUniqueInput | RetryAttemptWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type RefreshTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type RetryAttemptUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RetryAttemptCreateWithoutUserInput, RetryAttemptUncheckedCreateWithoutUserInput> | RetryAttemptCreateWithoutUserInput[] | RetryAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RetryAttemptCreateOrConnectWithoutUserInput | RetryAttemptCreateOrConnectWithoutUserInput[]
    createMany?: RetryAttemptCreateManyUserInputEnvelope
    connect?: RetryAttemptWhereUniqueInput | RetryAttemptWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type RefreshTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserInput | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserInput | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserInput | PaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type RetryAttemptUpdateManyWithoutUserNestedInput = {
    create?: XOR<RetryAttemptCreateWithoutUserInput, RetryAttemptUncheckedCreateWithoutUserInput> | RetryAttemptCreateWithoutUserInput[] | RetryAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RetryAttemptCreateOrConnectWithoutUserInput | RetryAttemptCreateOrConnectWithoutUserInput[]
    upsert?: RetryAttemptUpsertWithWhereUniqueWithoutUserInput | RetryAttemptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RetryAttemptCreateManyUserInputEnvelope
    set?: RetryAttemptWhereUniqueInput | RetryAttemptWhereUniqueInput[]
    disconnect?: RetryAttemptWhereUniqueInput | RetryAttemptWhereUniqueInput[]
    delete?: RetryAttemptWhereUniqueInput | RetryAttemptWhereUniqueInput[]
    connect?: RetryAttemptWhereUniqueInput | RetryAttemptWhereUniqueInput[]
    update?: RetryAttemptUpdateWithWhereUniqueWithoutUserInput | RetryAttemptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RetryAttemptUpdateManyWithWhereWithoutUserInput | RetryAttemptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RetryAttemptScalarWhereInput | RetryAttemptScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserInput | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserInput | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserInput | PaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type RetryAttemptUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RetryAttemptCreateWithoutUserInput, RetryAttemptUncheckedCreateWithoutUserInput> | RetryAttemptCreateWithoutUserInput[] | RetryAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RetryAttemptCreateOrConnectWithoutUserInput | RetryAttemptCreateOrConnectWithoutUserInput[]
    upsert?: RetryAttemptUpsertWithWhereUniqueWithoutUserInput | RetryAttemptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RetryAttemptCreateManyUserInputEnvelope
    set?: RetryAttemptWhereUniqueInput | RetryAttemptWhereUniqueInput[]
    disconnect?: RetryAttemptWhereUniqueInput | RetryAttemptWhereUniqueInput[]
    delete?: RetryAttemptWhereUniqueInput | RetryAttemptWhereUniqueInput[]
    connect?: RetryAttemptWhereUniqueInput | RetryAttemptWhereUniqueInput[]
    update?: RetryAttemptUpdateWithWhereUniqueWithoutUserInput | RetryAttemptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RetryAttemptUpdateManyWithWhereWithoutUserInput | RetryAttemptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RetryAttemptScalarWhereInput | RetryAttemptScalarWhereInput[]
  }

  export type NotificationCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<NotificationCreateWithoutOrganizationInput, NotificationUncheckedCreateWithoutOrganizationInput> | NotificationCreateWithoutOrganizationInput[] | NotificationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutOrganizationInput | NotificationCreateOrConnectWithoutOrganizationInput[]
    createMany?: NotificationCreateManyOrganizationInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type WebhookCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<WebhookCreateWithoutOrganizationInput, WebhookUncheckedCreateWithoutOrganizationInput> | WebhookCreateWithoutOrganizationInput[] | WebhookUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: WebhookCreateOrConnectWithoutOrganizationInput | WebhookCreateOrConnectWithoutOrganizationInput[]
    createMany?: WebhookCreateManyOrganizationInputEnvelope
    connect?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
  }

  export type ApiKeyCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ApiKeyCreateWithoutOrganizationInput, ApiKeyUncheckedCreateWithoutOrganizationInput> | ApiKeyCreateWithoutOrganizationInput[] | ApiKeyUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutOrganizationInput | ApiKeyCreateOrConnectWithoutOrganizationInput[]
    createMany?: ApiKeyCreateManyOrganizationInputEnvelope
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
  }

  export type CarbonEstimateCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<CarbonEstimateCreateWithoutOrganizationInput, CarbonEstimateUncheckedCreateWithoutOrganizationInput> | CarbonEstimateCreateWithoutOrganizationInput[] | CarbonEstimateUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: CarbonEstimateCreateOrConnectWithoutOrganizationInput | CarbonEstimateCreateOrConnectWithoutOrganizationInput[]
    createMany?: CarbonEstimateCreateManyOrganizationInputEnvelope
    connect?: CarbonEstimateWhereUniqueInput | CarbonEstimateWhereUniqueInput[]
  }

  export type BillingRuleCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<BillingRuleCreateWithoutOrganizationInput, BillingRuleUncheckedCreateWithoutOrganizationInput> | BillingRuleCreateWithoutOrganizationInput[] | BillingRuleUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: BillingRuleCreateOrConnectWithoutOrganizationInput | BillingRuleCreateOrConnectWithoutOrganizationInput[]
    createMany?: BillingRuleCreateManyOrganizationInputEnvelope
    connect?: BillingRuleWhereUniqueInput | BillingRuleWhereUniqueInput[]
  }

  export type BillingRuleTemplateCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<BillingRuleTemplateCreateWithoutOrganizationInput, BillingRuleTemplateUncheckedCreateWithoutOrganizationInput> | BillingRuleTemplateCreateWithoutOrganizationInput[] | BillingRuleTemplateUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: BillingRuleTemplateCreateOrConnectWithoutOrganizationInput | BillingRuleTemplateCreateOrConnectWithoutOrganizationInput[]
    createMany?: BillingRuleTemplateCreateManyOrganizationInputEnvelope
    connect?: BillingRuleTemplateWhereUniqueInput | BillingRuleTemplateWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<OrderCreateWithoutOrganizationInput, OrderUncheckedCreateWithoutOrganizationInput> | OrderCreateWithoutOrganizationInput[] | OrderUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutOrganizationInput | OrderCreateOrConnectWithoutOrganizationInput[]
    createMany?: OrderCreateManyOrganizationInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<NotificationCreateWithoutOrganizationInput, NotificationUncheckedCreateWithoutOrganizationInput> | NotificationCreateWithoutOrganizationInput[] | NotificationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutOrganizationInput | NotificationCreateOrConnectWithoutOrganizationInput[]
    createMany?: NotificationCreateManyOrganizationInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type WebhookUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<WebhookCreateWithoutOrganizationInput, WebhookUncheckedCreateWithoutOrganizationInput> | WebhookCreateWithoutOrganizationInput[] | WebhookUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: WebhookCreateOrConnectWithoutOrganizationInput | WebhookCreateOrConnectWithoutOrganizationInput[]
    createMany?: WebhookCreateManyOrganizationInputEnvelope
    connect?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
  }

  export type ApiKeyUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ApiKeyCreateWithoutOrganizationInput, ApiKeyUncheckedCreateWithoutOrganizationInput> | ApiKeyCreateWithoutOrganizationInput[] | ApiKeyUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutOrganizationInput | ApiKeyCreateOrConnectWithoutOrganizationInput[]
    createMany?: ApiKeyCreateManyOrganizationInputEnvelope
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
  }

  export type CarbonEstimateUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<CarbonEstimateCreateWithoutOrganizationInput, CarbonEstimateUncheckedCreateWithoutOrganizationInput> | CarbonEstimateCreateWithoutOrganizationInput[] | CarbonEstimateUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: CarbonEstimateCreateOrConnectWithoutOrganizationInput | CarbonEstimateCreateOrConnectWithoutOrganizationInput[]
    createMany?: CarbonEstimateCreateManyOrganizationInputEnvelope
    connect?: CarbonEstimateWhereUniqueInput | CarbonEstimateWhereUniqueInput[]
  }

  export type BillingRuleUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<BillingRuleCreateWithoutOrganizationInput, BillingRuleUncheckedCreateWithoutOrganizationInput> | BillingRuleCreateWithoutOrganizationInput[] | BillingRuleUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: BillingRuleCreateOrConnectWithoutOrganizationInput | BillingRuleCreateOrConnectWithoutOrganizationInput[]
    createMany?: BillingRuleCreateManyOrganizationInputEnvelope
    connect?: BillingRuleWhereUniqueInput | BillingRuleWhereUniqueInput[]
  }

  export type BillingRuleTemplateUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<BillingRuleTemplateCreateWithoutOrganizationInput, BillingRuleTemplateUncheckedCreateWithoutOrganizationInput> | BillingRuleTemplateCreateWithoutOrganizationInput[] | BillingRuleTemplateUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: BillingRuleTemplateCreateOrConnectWithoutOrganizationInput | BillingRuleTemplateCreateOrConnectWithoutOrganizationInput[]
    createMany?: BillingRuleTemplateCreateManyOrganizationInputEnvelope
    connect?: BillingRuleTemplateWhereUniqueInput | BillingRuleTemplateWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<OrderCreateWithoutOrganizationInput, OrderUncheckedCreateWithoutOrganizationInput> | OrderCreateWithoutOrganizationInput[] | OrderUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutOrganizationInput | OrderCreateOrConnectWithoutOrganizationInput[]
    createMany?: OrderCreateManyOrganizationInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type NotificationUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<NotificationCreateWithoutOrganizationInput, NotificationUncheckedCreateWithoutOrganizationInput> | NotificationCreateWithoutOrganizationInput[] | NotificationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutOrganizationInput | NotificationCreateOrConnectWithoutOrganizationInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutOrganizationInput | NotificationUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: NotificationCreateManyOrganizationInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutOrganizationInput | NotificationUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutOrganizationInput | NotificationUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type WebhookUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<WebhookCreateWithoutOrganizationInput, WebhookUncheckedCreateWithoutOrganizationInput> | WebhookCreateWithoutOrganizationInput[] | WebhookUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: WebhookCreateOrConnectWithoutOrganizationInput | WebhookCreateOrConnectWithoutOrganizationInput[]
    upsert?: WebhookUpsertWithWhereUniqueWithoutOrganizationInput | WebhookUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: WebhookCreateManyOrganizationInputEnvelope
    set?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    disconnect?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    delete?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    connect?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    update?: WebhookUpdateWithWhereUniqueWithoutOrganizationInput | WebhookUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: WebhookUpdateManyWithWhereWithoutOrganizationInput | WebhookUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: WebhookScalarWhereInput | WebhookScalarWhereInput[]
  }

  export type ApiKeyUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ApiKeyCreateWithoutOrganizationInput, ApiKeyUncheckedCreateWithoutOrganizationInput> | ApiKeyCreateWithoutOrganizationInput[] | ApiKeyUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutOrganizationInput | ApiKeyCreateOrConnectWithoutOrganizationInput[]
    upsert?: ApiKeyUpsertWithWhereUniqueWithoutOrganizationInput | ApiKeyUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ApiKeyCreateManyOrganizationInputEnvelope
    set?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    disconnect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    delete?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    update?: ApiKeyUpdateWithWhereUniqueWithoutOrganizationInput | ApiKeyUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ApiKeyUpdateManyWithWhereWithoutOrganizationInput | ApiKeyUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
  }

  export type CarbonEstimateUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<CarbonEstimateCreateWithoutOrganizationInput, CarbonEstimateUncheckedCreateWithoutOrganizationInput> | CarbonEstimateCreateWithoutOrganizationInput[] | CarbonEstimateUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: CarbonEstimateCreateOrConnectWithoutOrganizationInput | CarbonEstimateCreateOrConnectWithoutOrganizationInput[]
    upsert?: CarbonEstimateUpsertWithWhereUniqueWithoutOrganizationInput | CarbonEstimateUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: CarbonEstimateCreateManyOrganizationInputEnvelope
    set?: CarbonEstimateWhereUniqueInput | CarbonEstimateWhereUniqueInput[]
    disconnect?: CarbonEstimateWhereUniqueInput | CarbonEstimateWhereUniqueInput[]
    delete?: CarbonEstimateWhereUniqueInput | CarbonEstimateWhereUniqueInput[]
    connect?: CarbonEstimateWhereUniqueInput | CarbonEstimateWhereUniqueInput[]
    update?: CarbonEstimateUpdateWithWhereUniqueWithoutOrganizationInput | CarbonEstimateUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: CarbonEstimateUpdateManyWithWhereWithoutOrganizationInput | CarbonEstimateUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: CarbonEstimateScalarWhereInput | CarbonEstimateScalarWhereInput[]
  }

  export type BillingRuleUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<BillingRuleCreateWithoutOrganizationInput, BillingRuleUncheckedCreateWithoutOrganizationInput> | BillingRuleCreateWithoutOrganizationInput[] | BillingRuleUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: BillingRuleCreateOrConnectWithoutOrganizationInput | BillingRuleCreateOrConnectWithoutOrganizationInput[]
    upsert?: BillingRuleUpsertWithWhereUniqueWithoutOrganizationInput | BillingRuleUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: BillingRuleCreateManyOrganizationInputEnvelope
    set?: BillingRuleWhereUniqueInput | BillingRuleWhereUniqueInput[]
    disconnect?: BillingRuleWhereUniqueInput | BillingRuleWhereUniqueInput[]
    delete?: BillingRuleWhereUniqueInput | BillingRuleWhereUniqueInput[]
    connect?: BillingRuleWhereUniqueInput | BillingRuleWhereUniqueInput[]
    update?: BillingRuleUpdateWithWhereUniqueWithoutOrganizationInput | BillingRuleUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: BillingRuleUpdateManyWithWhereWithoutOrganizationInput | BillingRuleUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: BillingRuleScalarWhereInput | BillingRuleScalarWhereInput[]
  }

  export type BillingRuleTemplateUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<BillingRuleTemplateCreateWithoutOrganizationInput, BillingRuleTemplateUncheckedCreateWithoutOrganizationInput> | BillingRuleTemplateCreateWithoutOrganizationInput[] | BillingRuleTemplateUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: BillingRuleTemplateCreateOrConnectWithoutOrganizationInput | BillingRuleTemplateCreateOrConnectWithoutOrganizationInput[]
    upsert?: BillingRuleTemplateUpsertWithWhereUniqueWithoutOrganizationInput | BillingRuleTemplateUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: BillingRuleTemplateCreateManyOrganizationInputEnvelope
    set?: BillingRuleTemplateWhereUniqueInput | BillingRuleTemplateWhereUniqueInput[]
    disconnect?: BillingRuleTemplateWhereUniqueInput | BillingRuleTemplateWhereUniqueInput[]
    delete?: BillingRuleTemplateWhereUniqueInput | BillingRuleTemplateWhereUniqueInput[]
    connect?: BillingRuleTemplateWhereUniqueInput | BillingRuleTemplateWhereUniqueInput[]
    update?: BillingRuleTemplateUpdateWithWhereUniqueWithoutOrganizationInput | BillingRuleTemplateUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: BillingRuleTemplateUpdateManyWithWhereWithoutOrganizationInput | BillingRuleTemplateUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: BillingRuleTemplateScalarWhereInput | BillingRuleTemplateScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<OrderCreateWithoutOrganizationInput, OrderUncheckedCreateWithoutOrganizationInput> | OrderCreateWithoutOrganizationInput[] | OrderUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutOrganizationInput | OrderCreateOrConnectWithoutOrganizationInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutOrganizationInput | OrderUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: OrderCreateManyOrganizationInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutOrganizationInput | OrderUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutOrganizationInput | OrderUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<NotificationCreateWithoutOrganizationInput, NotificationUncheckedCreateWithoutOrganizationInput> | NotificationCreateWithoutOrganizationInput[] | NotificationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutOrganizationInput | NotificationCreateOrConnectWithoutOrganizationInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutOrganizationInput | NotificationUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: NotificationCreateManyOrganizationInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutOrganizationInput | NotificationUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutOrganizationInput | NotificationUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type WebhookUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<WebhookCreateWithoutOrganizationInput, WebhookUncheckedCreateWithoutOrganizationInput> | WebhookCreateWithoutOrganizationInput[] | WebhookUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: WebhookCreateOrConnectWithoutOrganizationInput | WebhookCreateOrConnectWithoutOrganizationInput[]
    upsert?: WebhookUpsertWithWhereUniqueWithoutOrganizationInput | WebhookUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: WebhookCreateManyOrganizationInputEnvelope
    set?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    disconnect?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    delete?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    connect?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    update?: WebhookUpdateWithWhereUniqueWithoutOrganizationInput | WebhookUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: WebhookUpdateManyWithWhereWithoutOrganizationInput | WebhookUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: WebhookScalarWhereInput | WebhookScalarWhereInput[]
  }

  export type ApiKeyUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ApiKeyCreateWithoutOrganizationInput, ApiKeyUncheckedCreateWithoutOrganizationInput> | ApiKeyCreateWithoutOrganizationInput[] | ApiKeyUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutOrganizationInput | ApiKeyCreateOrConnectWithoutOrganizationInput[]
    upsert?: ApiKeyUpsertWithWhereUniqueWithoutOrganizationInput | ApiKeyUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ApiKeyCreateManyOrganizationInputEnvelope
    set?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    disconnect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    delete?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    update?: ApiKeyUpdateWithWhereUniqueWithoutOrganizationInput | ApiKeyUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ApiKeyUpdateManyWithWhereWithoutOrganizationInput | ApiKeyUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
  }

  export type CarbonEstimateUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<CarbonEstimateCreateWithoutOrganizationInput, CarbonEstimateUncheckedCreateWithoutOrganizationInput> | CarbonEstimateCreateWithoutOrganizationInput[] | CarbonEstimateUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: CarbonEstimateCreateOrConnectWithoutOrganizationInput | CarbonEstimateCreateOrConnectWithoutOrganizationInput[]
    upsert?: CarbonEstimateUpsertWithWhereUniqueWithoutOrganizationInput | CarbonEstimateUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: CarbonEstimateCreateManyOrganizationInputEnvelope
    set?: CarbonEstimateWhereUniqueInput | CarbonEstimateWhereUniqueInput[]
    disconnect?: CarbonEstimateWhereUniqueInput | CarbonEstimateWhereUniqueInput[]
    delete?: CarbonEstimateWhereUniqueInput | CarbonEstimateWhereUniqueInput[]
    connect?: CarbonEstimateWhereUniqueInput | CarbonEstimateWhereUniqueInput[]
    update?: CarbonEstimateUpdateWithWhereUniqueWithoutOrganizationInput | CarbonEstimateUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: CarbonEstimateUpdateManyWithWhereWithoutOrganizationInput | CarbonEstimateUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: CarbonEstimateScalarWhereInput | CarbonEstimateScalarWhereInput[]
  }

  export type BillingRuleUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<BillingRuleCreateWithoutOrganizationInput, BillingRuleUncheckedCreateWithoutOrganizationInput> | BillingRuleCreateWithoutOrganizationInput[] | BillingRuleUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: BillingRuleCreateOrConnectWithoutOrganizationInput | BillingRuleCreateOrConnectWithoutOrganizationInput[]
    upsert?: BillingRuleUpsertWithWhereUniqueWithoutOrganizationInput | BillingRuleUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: BillingRuleCreateManyOrganizationInputEnvelope
    set?: BillingRuleWhereUniqueInput | BillingRuleWhereUniqueInput[]
    disconnect?: BillingRuleWhereUniqueInput | BillingRuleWhereUniqueInput[]
    delete?: BillingRuleWhereUniqueInput | BillingRuleWhereUniqueInput[]
    connect?: BillingRuleWhereUniqueInput | BillingRuleWhereUniqueInput[]
    update?: BillingRuleUpdateWithWhereUniqueWithoutOrganizationInput | BillingRuleUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: BillingRuleUpdateManyWithWhereWithoutOrganizationInput | BillingRuleUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: BillingRuleScalarWhereInput | BillingRuleScalarWhereInput[]
  }

  export type BillingRuleTemplateUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<BillingRuleTemplateCreateWithoutOrganizationInput, BillingRuleTemplateUncheckedCreateWithoutOrganizationInput> | BillingRuleTemplateCreateWithoutOrganizationInput[] | BillingRuleTemplateUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: BillingRuleTemplateCreateOrConnectWithoutOrganizationInput | BillingRuleTemplateCreateOrConnectWithoutOrganizationInput[]
    upsert?: BillingRuleTemplateUpsertWithWhereUniqueWithoutOrganizationInput | BillingRuleTemplateUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: BillingRuleTemplateCreateManyOrganizationInputEnvelope
    set?: BillingRuleTemplateWhereUniqueInput | BillingRuleTemplateWhereUniqueInput[]
    disconnect?: BillingRuleTemplateWhereUniqueInput | BillingRuleTemplateWhereUniqueInput[]
    delete?: BillingRuleTemplateWhereUniqueInput | BillingRuleTemplateWhereUniqueInput[]
    connect?: BillingRuleTemplateWhereUniqueInput | BillingRuleTemplateWhereUniqueInput[]
    update?: BillingRuleTemplateUpdateWithWhereUniqueWithoutOrganizationInput | BillingRuleTemplateUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: BillingRuleTemplateUpdateManyWithWhereWithoutOrganizationInput | BillingRuleTemplateUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: BillingRuleTemplateScalarWhereInput | BillingRuleTemplateScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<OrderCreateWithoutOrganizationInput, OrderUncheckedCreateWithoutOrganizationInput> | OrderCreateWithoutOrganizationInput[] | OrderUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutOrganizationInput | OrderCreateOrConnectWithoutOrganizationInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutOrganizationInput | OrderUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: OrderCreateManyOrganizationInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutOrganizationInput | OrderUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutOrganizationInput | OrderUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type PaymentCreateNestedManyWithoutCustomerInput = {
    create?: XOR<PaymentCreateWithoutCustomerInput, PaymentUncheckedCreateWithoutCustomerInput> | PaymentCreateWithoutCustomerInput[] | PaymentUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCustomerInput | PaymentCreateOrConnectWithoutCustomerInput[]
    createMany?: PaymentCreateManyCustomerInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type SubscriptionCreateNestedOneWithoutCustomerInput = {
    create?: XOR<SubscriptionCreateWithoutCustomerInput, SubscriptionUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutCustomerInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type TaxCalculationCreateNestedManyWithoutCustomerInput = {
    create?: XOR<TaxCalculationCreateWithoutCustomerInput, TaxCalculationUncheckedCreateWithoutCustomerInput> | TaxCalculationCreateWithoutCustomerInput[] | TaxCalculationUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TaxCalculationCreateOrConnectWithoutCustomerInput | TaxCalculationCreateOrConnectWithoutCustomerInput[]
    createMany?: TaxCalculationCreateManyCustomerInputEnvelope
    connect?: TaxCalculationWhereUniqueInput | TaxCalculationWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutCustomerInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<PaymentCreateWithoutCustomerInput, PaymentUncheckedCreateWithoutCustomerInput> | PaymentCreateWithoutCustomerInput[] | PaymentUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCustomerInput | PaymentCreateOrConnectWithoutCustomerInput[]
    createMany?: PaymentCreateManyCustomerInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedOneWithoutCustomerInput = {
    create?: XOR<SubscriptionCreateWithoutCustomerInput, SubscriptionUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutCustomerInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type TaxCalculationUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<TaxCalculationCreateWithoutCustomerInput, TaxCalculationUncheckedCreateWithoutCustomerInput> | TaxCalculationCreateWithoutCustomerInput[] | TaxCalculationUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TaxCalculationCreateOrConnectWithoutCustomerInput | TaxCalculationCreateOrConnectWithoutCustomerInput[]
    createMany?: TaxCalculationCreateManyCustomerInputEnvelope
    connect?: TaxCalculationWhereUniqueInput | TaxCalculationWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type PaymentUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<PaymentCreateWithoutCustomerInput, PaymentUncheckedCreateWithoutCustomerInput> | PaymentCreateWithoutCustomerInput[] | PaymentUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCustomerInput | PaymentCreateOrConnectWithoutCustomerInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutCustomerInput | PaymentUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: PaymentCreateManyCustomerInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutCustomerInput | PaymentUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutCustomerInput | PaymentUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type SubscriptionUpdateOneWithoutCustomerNestedInput = {
    create?: XOR<SubscriptionCreateWithoutCustomerInput, SubscriptionUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutCustomerInput
    upsert?: SubscriptionUpsertWithoutCustomerInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutCustomerInput, SubscriptionUpdateWithoutCustomerInput>, SubscriptionUncheckedUpdateWithoutCustomerInput>
  }

  export type TaxCalculationUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<TaxCalculationCreateWithoutCustomerInput, TaxCalculationUncheckedCreateWithoutCustomerInput> | TaxCalculationCreateWithoutCustomerInput[] | TaxCalculationUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TaxCalculationCreateOrConnectWithoutCustomerInput | TaxCalculationCreateOrConnectWithoutCustomerInput[]
    upsert?: TaxCalculationUpsertWithWhereUniqueWithoutCustomerInput | TaxCalculationUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: TaxCalculationCreateManyCustomerInputEnvelope
    set?: TaxCalculationWhereUniqueInput | TaxCalculationWhereUniqueInput[]
    disconnect?: TaxCalculationWhereUniqueInput | TaxCalculationWhereUniqueInput[]
    delete?: TaxCalculationWhereUniqueInput | TaxCalculationWhereUniqueInput[]
    connect?: TaxCalculationWhereUniqueInput | TaxCalculationWhereUniqueInput[]
    update?: TaxCalculationUpdateWithWhereUniqueWithoutCustomerInput | TaxCalculationUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: TaxCalculationUpdateManyWithWhereWithoutCustomerInput | TaxCalculationUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: TaxCalculationScalarWhereInput | TaxCalculationScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCustomerInput | OrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCustomerInput | OrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCustomerInput | OrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<PaymentCreateWithoutCustomerInput, PaymentUncheckedCreateWithoutCustomerInput> | PaymentCreateWithoutCustomerInput[] | PaymentUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCustomerInput | PaymentCreateOrConnectWithoutCustomerInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutCustomerInput | PaymentUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: PaymentCreateManyCustomerInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutCustomerInput | PaymentUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutCustomerInput | PaymentUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateOneWithoutCustomerNestedInput = {
    create?: XOR<SubscriptionCreateWithoutCustomerInput, SubscriptionUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutCustomerInput
    upsert?: SubscriptionUpsertWithoutCustomerInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutCustomerInput, SubscriptionUpdateWithoutCustomerInput>, SubscriptionUncheckedUpdateWithoutCustomerInput>
  }

  export type TaxCalculationUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<TaxCalculationCreateWithoutCustomerInput, TaxCalculationUncheckedCreateWithoutCustomerInput> | TaxCalculationCreateWithoutCustomerInput[] | TaxCalculationUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TaxCalculationCreateOrConnectWithoutCustomerInput | TaxCalculationCreateOrConnectWithoutCustomerInput[]
    upsert?: TaxCalculationUpsertWithWhereUniqueWithoutCustomerInput | TaxCalculationUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: TaxCalculationCreateManyCustomerInputEnvelope
    set?: TaxCalculationWhereUniqueInput | TaxCalculationWhereUniqueInput[]
    disconnect?: TaxCalculationWhereUniqueInput | TaxCalculationWhereUniqueInput[]
    delete?: TaxCalculationWhereUniqueInput | TaxCalculationWhereUniqueInput[]
    connect?: TaxCalculationWhereUniqueInput | TaxCalculationWhereUniqueInput[]
    update?: TaxCalculationUpdateWithWhereUniqueWithoutCustomerInput | TaxCalculationUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: TaxCalculationUpdateManyWithWhereWithoutCustomerInput | TaxCalculationUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: TaxCalculationScalarWhereInput | TaxCalculationScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCustomerInput | OrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCustomerInput | OrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCustomerInput | OrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<CustomerCreateWithoutSubscriptionInput, CustomerUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSubscriptionInput
    connect?: CustomerWhereUniqueInput
  }

  export type PlanCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<PlanCreateWithoutSubscriptionsInput, PlanUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: PlanCreateOrConnectWithoutSubscriptionsInput
    connect?: PlanWhereUniqueInput
  }

  export type PaymentCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<PaymentCreateWithoutSubscriptionInput, PaymentUncheckedCreateWithoutSubscriptionInput> | PaymentCreateWithoutSubscriptionInput[] | PaymentUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutSubscriptionInput | PaymentCreateOrConnectWithoutSubscriptionInput[]
    createMany?: PaymentCreateManySubscriptionInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type UsageRecordCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<UsageRecordCreateWithoutSubscriptionInput, UsageRecordUncheckedCreateWithoutSubscriptionInput> | UsageRecordCreateWithoutSubscriptionInput[] | UsageRecordUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: UsageRecordCreateOrConnectWithoutSubscriptionInput | UsageRecordCreateOrConnectWithoutSubscriptionInput[]
    createMany?: UsageRecordCreateManySubscriptionInputEnvelope
    connect?: UsageRecordWhereUniqueInput | UsageRecordWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<PaymentCreateWithoutSubscriptionInput, PaymentUncheckedCreateWithoutSubscriptionInput> | PaymentCreateWithoutSubscriptionInput[] | PaymentUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutSubscriptionInput | PaymentCreateOrConnectWithoutSubscriptionInput[]
    createMany?: PaymentCreateManySubscriptionInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type UsageRecordUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<UsageRecordCreateWithoutSubscriptionInput, UsageRecordUncheckedCreateWithoutSubscriptionInput> | UsageRecordCreateWithoutSubscriptionInput[] | UsageRecordUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: UsageRecordCreateOrConnectWithoutSubscriptionInput | UsageRecordCreateOrConnectWithoutSubscriptionInput[]
    createMany?: UsageRecordCreateManySubscriptionInputEnvelope
    connect?: UsageRecordWhereUniqueInput | UsageRecordWhereUniqueInput[]
  }

  export type EnumSubscriptionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionStatus
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type CustomerUpdateOneRequiredWithoutSubscriptionNestedInput = {
    create?: XOR<CustomerCreateWithoutSubscriptionInput, CustomerUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSubscriptionInput
    upsert?: CustomerUpsertWithoutSubscriptionInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutSubscriptionInput, CustomerUpdateWithoutSubscriptionInput>, CustomerUncheckedUpdateWithoutSubscriptionInput>
  }

  export type PlanUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<PlanCreateWithoutSubscriptionsInput, PlanUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: PlanCreateOrConnectWithoutSubscriptionsInput
    upsert?: PlanUpsertWithoutSubscriptionsInput
    connect?: PlanWhereUniqueInput
    update?: XOR<XOR<PlanUpdateToOneWithWhereWithoutSubscriptionsInput, PlanUpdateWithoutSubscriptionsInput>, PlanUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type PaymentUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<PaymentCreateWithoutSubscriptionInput, PaymentUncheckedCreateWithoutSubscriptionInput> | PaymentCreateWithoutSubscriptionInput[] | PaymentUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutSubscriptionInput | PaymentCreateOrConnectWithoutSubscriptionInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutSubscriptionInput | PaymentUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: PaymentCreateManySubscriptionInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutSubscriptionInput | PaymentUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutSubscriptionInput | PaymentUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type UsageRecordUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<UsageRecordCreateWithoutSubscriptionInput, UsageRecordUncheckedCreateWithoutSubscriptionInput> | UsageRecordCreateWithoutSubscriptionInput[] | UsageRecordUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: UsageRecordCreateOrConnectWithoutSubscriptionInput | UsageRecordCreateOrConnectWithoutSubscriptionInput[]
    upsert?: UsageRecordUpsertWithWhereUniqueWithoutSubscriptionInput | UsageRecordUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: UsageRecordCreateManySubscriptionInputEnvelope
    set?: UsageRecordWhereUniqueInput | UsageRecordWhereUniqueInput[]
    disconnect?: UsageRecordWhereUniqueInput | UsageRecordWhereUniqueInput[]
    delete?: UsageRecordWhereUniqueInput | UsageRecordWhereUniqueInput[]
    connect?: UsageRecordWhereUniqueInput | UsageRecordWhereUniqueInput[]
    update?: UsageRecordUpdateWithWhereUniqueWithoutSubscriptionInput | UsageRecordUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: UsageRecordUpdateManyWithWhereWithoutSubscriptionInput | UsageRecordUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: UsageRecordScalarWhereInput | UsageRecordScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<PaymentCreateWithoutSubscriptionInput, PaymentUncheckedCreateWithoutSubscriptionInput> | PaymentCreateWithoutSubscriptionInput[] | PaymentUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutSubscriptionInput | PaymentCreateOrConnectWithoutSubscriptionInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutSubscriptionInput | PaymentUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: PaymentCreateManySubscriptionInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutSubscriptionInput | PaymentUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutSubscriptionInput | PaymentUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type UsageRecordUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<UsageRecordCreateWithoutSubscriptionInput, UsageRecordUncheckedCreateWithoutSubscriptionInput> | UsageRecordCreateWithoutSubscriptionInput[] | UsageRecordUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: UsageRecordCreateOrConnectWithoutSubscriptionInput | UsageRecordCreateOrConnectWithoutSubscriptionInput[]
    upsert?: UsageRecordUpsertWithWhereUniqueWithoutSubscriptionInput | UsageRecordUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: UsageRecordCreateManySubscriptionInputEnvelope
    set?: UsageRecordWhereUniqueInput | UsageRecordWhereUniqueInput[]
    disconnect?: UsageRecordWhereUniqueInput | UsageRecordWhereUniqueInput[]
    delete?: UsageRecordWhereUniqueInput | UsageRecordWhereUniqueInput[]
    connect?: UsageRecordWhereUniqueInput | UsageRecordWhereUniqueInput[]
    update?: UsageRecordUpdateWithWhereUniqueWithoutSubscriptionInput | UsageRecordUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: UsageRecordUpdateManyWithWhereWithoutSubscriptionInput | UsageRecordUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: UsageRecordScalarWhereInput | UsageRecordScalarWhereInput[]
  }

  export type PlanFeatureCreateNestedManyWithoutPlanInput = {
    create?: XOR<PlanFeatureCreateWithoutPlanInput, PlanFeatureUncheckedCreateWithoutPlanInput> | PlanFeatureCreateWithoutPlanInput[] | PlanFeatureUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanFeatureCreateOrConnectWithoutPlanInput | PlanFeatureCreateOrConnectWithoutPlanInput[]
    createMany?: PlanFeatureCreateManyPlanInputEnvelope
    connect?: PlanFeatureWhereUniqueInput | PlanFeatureWhereUniqueInput[]
  }

  export type UsageLimitCreateNestedManyWithoutPlanInput = {
    create?: XOR<UsageLimitCreateWithoutPlanInput, UsageLimitUncheckedCreateWithoutPlanInput> | UsageLimitCreateWithoutPlanInput[] | UsageLimitUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: UsageLimitCreateOrConnectWithoutPlanInput | UsageLimitCreateOrConnectWithoutPlanInput[]
    createMany?: UsageLimitCreateManyPlanInputEnvelope
    connect?: UsageLimitWhereUniqueInput | UsageLimitWhereUniqueInput[]
  }

  export type PriceHistoryCreateNestedManyWithoutPlanInput = {
    create?: XOR<PriceHistoryCreateWithoutPlanInput, PriceHistoryUncheckedCreateWithoutPlanInput> | PriceHistoryCreateWithoutPlanInput[] | PriceHistoryUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PriceHistoryCreateOrConnectWithoutPlanInput | PriceHistoryCreateOrConnectWithoutPlanInput[]
    createMany?: PriceHistoryCreateManyPlanInputEnvelope
    connect?: PriceHistoryWhereUniqueInput | PriceHistoryWhereUniqueInput[]
  }

  export type PriceTestCreateNestedManyWithoutPlanInput = {
    create?: XOR<PriceTestCreateWithoutPlanInput, PriceTestUncheckedCreateWithoutPlanInput> | PriceTestCreateWithoutPlanInput[] | PriceTestUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PriceTestCreateOrConnectWithoutPlanInput | PriceTestCreateOrConnectWithoutPlanInput[]
    createMany?: PriceTestCreateManyPlanInputEnvelope
    connect?: PriceTestWhereUniqueInput | PriceTestWhereUniqueInput[]
  }

  export type RevenueRecognitionRuleCreateNestedManyWithoutPlanInput = {
    create?: XOR<RevenueRecognitionRuleCreateWithoutPlanInput, RevenueRecognitionRuleUncheckedCreateWithoutPlanInput> | RevenueRecognitionRuleCreateWithoutPlanInput[] | RevenueRecognitionRuleUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: RevenueRecognitionRuleCreateOrConnectWithoutPlanInput | RevenueRecognitionRuleCreateOrConnectWithoutPlanInput[]
    createMany?: RevenueRecognitionRuleCreateManyPlanInputEnvelope
    connect?: RevenueRecognitionRuleWhereUniqueInput | RevenueRecognitionRuleWhereUniqueInput[]
  }

  export type SubscriptionCreateNestedManyWithoutPlanInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type PlanFeatureUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<PlanFeatureCreateWithoutPlanInput, PlanFeatureUncheckedCreateWithoutPlanInput> | PlanFeatureCreateWithoutPlanInput[] | PlanFeatureUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanFeatureCreateOrConnectWithoutPlanInput | PlanFeatureCreateOrConnectWithoutPlanInput[]
    createMany?: PlanFeatureCreateManyPlanInputEnvelope
    connect?: PlanFeatureWhereUniqueInput | PlanFeatureWhereUniqueInput[]
  }

  export type UsageLimitUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<UsageLimitCreateWithoutPlanInput, UsageLimitUncheckedCreateWithoutPlanInput> | UsageLimitCreateWithoutPlanInput[] | UsageLimitUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: UsageLimitCreateOrConnectWithoutPlanInput | UsageLimitCreateOrConnectWithoutPlanInput[]
    createMany?: UsageLimitCreateManyPlanInputEnvelope
    connect?: UsageLimitWhereUniqueInput | UsageLimitWhereUniqueInput[]
  }

  export type PriceHistoryUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<PriceHistoryCreateWithoutPlanInput, PriceHistoryUncheckedCreateWithoutPlanInput> | PriceHistoryCreateWithoutPlanInput[] | PriceHistoryUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PriceHistoryCreateOrConnectWithoutPlanInput | PriceHistoryCreateOrConnectWithoutPlanInput[]
    createMany?: PriceHistoryCreateManyPlanInputEnvelope
    connect?: PriceHistoryWhereUniqueInput | PriceHistoryWhereUniqueInput[]
  }

  export type PriceTestUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<PriceTestCreateWithoutPlanInput, PriceTestUncheckedCreateWithoutPlanInput> | PriceTestCreateWithoutPlanInput[] | PriceTestUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PriceTestCreateOrConnectWithoutPlanInput | PriceTestCreateOrConnectWithoutPlanInput[]
    createMany?: PriceTestCreateManyPlanInputEnvelope
    connect?: PriceTestWhereUniqueInput | PriceTestWhereUniqueInput[]
  }

  export type RevenueRecognitionRuleUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<RevenueRecognitionRuleCreateWithoutPlanInput, RevenueRecognitionRuleUncheckedCreateWithoutPlanInput> | RevenueRecognitionRuleCreateWithoutPlanInput[] | RevenueRecognitionRuleUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: RevenueRecognitionRuleCreateOrConnectWithoutPlanInput | RevenueRecognitionRuleCreateOrConnectWithoutPlanInput[]
    createMany?: RevenueRecognitionRuleCreateManyPlanInputEnvelope
    connect?: RevenueRecognitionRuleWhereUniqueInput | RevenueRecognitionRuleWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PlanFeatureUpdateManyWithoutPlanNestedInput = {
    create?: XOR<PlanFeatureCreateWithoutPlanInput, PlanFeatureUncheckedCreateWithoutPlanInput> | PlanFeatureCreateWithoutPlanInput[] | PlanFeatureUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanFeatureCreateOrConnectWithoutPlanInput | PlanFeatureCreateOrConnectWithoutPlanInput[]
    upsert?: PlanFeatureUpsertWithWhereUniqueWithoutPlanInput | PlanFeatureUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: PlanFeatureCreateManyPlanInputEnvelope
    set?: PlanFeatureWhereUniqueInput | PlanFeatureWhereUniqueInput[]
    disconnect?: PlanFeatureWhereUniqueInput | PlanFeatureWhereUniqueInput[]
    delete?: PlanFeatureWhereUniqueInput | PlanFeatureWhereUniqueInput[]
    connect?: PlanFeatureWhereUniqueInput | PlanFeatureWhereUniqueInput[]
    update?: PlanFeatureUpdateWithWhereUniqueWithoutPlanInput | PlanFeatureUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: PlanFeatureUpdateManyWithWhereWithoutPlanInput | PlanFeatureUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: PlanFeatureScalarWhereInput | PlanFeatureScalarWhereInput[]
  }

  export type UsageLimitUpdateManyWithoutPlanNestedInput = {
    create?: XOR<UsageLimitCreateWithoutPlanInput, UsageLimitUncheckedCreateWithoutPlanInput> | UsageLimitCreateWithoutPlanInput[] | UsageLimitUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: UsageLimitCreateOrConnectWithoutPlanInput | UsageLimitCreateOrConnectWithoutPlanInput[]
    upsert?: UsageLimitUpsertWithWhereUniqueWithoutPlanInput | UsageLimitUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: UsageLimitCreateManyPlanInputEnvelope
    set?: UsageLimitWhereUniqueInput | UsageLimitWhereUniqueInput[]
    disconnect?: UsageLimitWhereUniqueInput | UsageLimitWhereUniqueInput[]
    delete?: UsageLimitWhereUniqueInput | UsageLimitWhereUniqueInput[]
    connect?: UsageLimitWhereUniqueInput | UsageLimitWhereUniqueInput[]
    update?: UsageLimitUpdateWithWhereUniqueWithoutPlanInput | UsageLimitUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: UsageLimitUpdateManyWithWhereWithoutPlanInput | UsageLimitUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: UsageLimitScalarWhereInput | UsageLimitScalarWhereInput[]
  }

  export type PriceHistoryUpdateManyWithoutPlanNestedInput = {
    create?: XOR<PriceHistoryCreateWithoutPlanInput, PriceHistoryUncheckedCreateWithoutPlanInput> | PriceHistoryCreateWithoutPlanInput[] | PriceHistoryUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PriceHistoryCreateOrConnectWithoutPlanInput | PriceHistoryCreateOrConnectWithoutPlanInput[]
    upsert?: PriceHistoryUpsertWithWhereUniqueWithoutPlanInput | PriceHistoryUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: PriceHistoryCreateManyPlanInputEnvelope
    set?: PriceHistoryWhereUniqueInput | PriceHistoryWhereUniqueInput[]
    disconnect?: PriceHistoryWhereUniqueInput | PriceHistoryWhereUniqueInput[]
    delete?: PriceHistoryWhereUniqueInput | PriceHistoryWhereUniqueInput[]
    connect?: PriceHistoryWhereUniqueInput | PriceHistoryWhereUniqueInput[]
    update?: PriceHistoryUpdateWithWhereUniqueWithoutPlanInput | PriceHistoryUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: PriceHistoryUpdateManyWithWhereWithoutPlanInput | PriceHistoryUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: PriceHistoryScalarWhereInput | PriceHistoryScalarWhereInput[]
  }

  export type PriceTestUpdateManyWithoutPlanNestedInput = {
    create?: XOR<PriceTestCreateWithoutPlanInput, PriceTestUncheckedCreateWithoutPlanInput> | PriceTestCreateWithoutPlanInput[] | PriceTestUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PriceTestCreateOrConnectWithoutPlanInput | PriceTestCreateOrConnectWithoutPlanInput[]
    upsert?: PriceTestUpsertWithWhereUniqueWithoutPlanInput | PriceTestUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: PriceTestCreateManyPlanInputEnvelope
    set?: PriceTestWhereUniqueInput | PriceTestWhereUniqueInput[]
    disconnect?: PriceTestWhereUniqueInput | PriceTestWhereUniqueInput[]
    delete?: PriceTestWhereUniqueInput | PriceTestWhereUniqueInput[]
    connect?: PriceTestWhereUniqueInput | PriceTestWhereUniqueInput[]
    update?: PriceTestUpdateWithWhereUniqueWithoutPlanInput | PriceTestUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: PriceTestUpdateManyWithWhereWithoutPlanInput | PriceTestUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: PriceTestScalarWhereInput | PriceTestScalarWhereInput[]
  }

  export type RevenueRecognitionRuleUpdateManyWithoutPlanNestedInput = {
    create?: XOR<RevenueRecognitionRuleCreateWithoutPlanInput, RevenueRecognitionRuleUncheckedCreateWithoutPlanInput> | RevenueRecognitionRuleCreateWithoutPlanInput[] | RevenueRecognitionRuleUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: RevenueRecognitionRuleCreateOrConnectWithoutPlanInput | RevenueRecognitionRuleCreateOrConnectWithoutPlanInput[]
    upsert?: RevenueRecognitionRuleUpsertWithWhereUniqueWithoutPlanInput | RevenueRecognitionRuleUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: RevenueRecognitionRuleCreateManyPlanInputEnvelope
    set?: RevenueRecognitionRuleWhereUniqueInput | RevenueRecognitionRuleWhereUniqueInput[]
    disconnect?: RevenueRecognitionRuleWhereUniqueInput | RevenueRecognitionRuleWhereUniqueInput[]
    delete?: RevenueRecognitionRuleWhereUniqueInput | RevenueRecognitionRuleWhereUniqueInput[]
    connect?: RevenueRecognitionRuleWhereUniqueInput | RevenueRecognitionRuleWhereUniqueInput[]
    update?: RevenueRecognitionRuleUpdateWithWhereUniqueWithoutPlanInput | RevenueRecognitionRuleUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: RevenueRecognitionRuleUpdateManyWithWhereWithoutPlanInput | RevenueRecognitionRuleUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: RevenueRecognitionRuleScalarWhereInput | RevenueRecognitionRuleScalarWhereInput[]
  }

  export type SubscriptionUpdateManyWithoutPlanNestedInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutPlanInput | SubscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutPlanInput | SubscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutPlanInput | SubscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type PlanFeatureUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<PlanFeatureCreateWithoutPlanInput, PlanFeatureUncheckedCreateWithoutPlanInput> | PlanFeatureCreateWithoutPlanInput[] | PlanFeatureUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanFeatureCreateOrConnectWithoutPlanInput | PlanFeatureCreateOrConnectWithoutPlanInput[]
    upsert?: PlanFeatureUpsertWithWhereUniqueWithoutPlanInput | PlanFeatureUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: PlanFeatureCreateManyPlanInputEnvelope
    set?: PlanFeatureWhereUniqueInput | PlanFeatureWhereUniqueInput[]
    disconnect?: PlanFeatureWhereUniqueInput | PlanFeatureWhereUniqueInput[]
    delete?: PlanFeatureWhereUniqueInput | PlanFeatureWhereUniqueInput[]
    connect?: PlanFeatureWhereUniqueInput | PlanFeatureWhereUniqueInput[]
    update?: PlanFeatureUpdateWithWhereUniqueWithoutPlanInput | PlanFeatureUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: PlanFeatureUpdateManyWithWhereWithoutPlanInput | PlanFeatureUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: PlanFeatureScalarWhereInput | PlanFeatureScalarWhereInput[]
  }

  export type UsageLimitUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<UsageLimitCreateWithoutPlanInput, UsageLimitUncheckedCreateWithoutPlanInput> | UsageLimitCreateWithoutPlanInput[] | UsageLimitUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: UsageLimitCreateOrConnectWithoutPlanInput | UsageLimitCreateOrConnectWithoutPlanInput[]
    upsert?: UsageLimitUpsertWithWhereUniqueWithoutPlanInput | UsageLimitUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: UsageLimitCreateManyPlanInputEnvelope
    set?: UsageLimitWhereUniqueInput | UsageLimitWhereUniqueInput[]
    disconnect?: UsageLimitWhereUniqueInput | UsageLimitWhereUniqueInput[]
    delete?: UsageLimitWhereUniqueInput | UsageLimitWhereUniqueInput[]
    connect?: UsageLimitWhereUniqueInput | UsageLimitWhereUniqueInput[]
    update?: UsageLimitUpdateWithWhereUniqueWithoutPlanInput | UsageLimitUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: UsageLimitUpdateManyWithWhereWithoutPlanInput | UsageLimitUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: UsageLimitScalarWhereInput | UsageLimitScalarWhereInput[]
  }

  export type PriceHistoryUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<PriceHistoryCreateWithoutPlanInput, PriceHistoryUncheckedCreateWithoutPlanInput> | PriceHistoryCreateWithoutPlanInput[] | PriceHistoryUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PriceHistoryCreateOrConnectWithoutPlanInput | PriceHistoryCreateOrConnectWithoutPlanInput[]
    upsert?: PriceHistoryUpsertWithWhereUniqueWithoutPlanInput | PriceHistoryUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: PriceHistoryCreateManyPlanInputEnvelope
    set?: PriceHistoryWhereUniqueInput | PriceHistoryWhereUniqueInput[]
    disconnect?: PriceHistoryWhereUniqueInput | PriceHistoryWhereUniqueInput[]
    delete?: PriceHistoryWhereUniqueInput | PriceHistoryWhereUniqueInput[]
    connect?: PriceHistoryWhereUniqueInput | PriceHistoryWhereUniqueInput[]
    update?: PriceHistoryUpdateWithWhereUniqueWithoutPlanInput | PriceHistoryUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: PriceHistoryUpdateManyWithWhereWithoutPlanInput | PriceHistoryUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: PriceHistoryScalarWhereInput | PriceHistoryScalarWhereInput[]
  }

  export type PriceTestUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<PriceTestCreateWithoutPlanInput, PriceTestUncheckedCreateWithoutPlanInput> | PriceTestCreateWithoutPlanInput[] | PriceTestUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PriceTestCreateOrConnectWithoutPlanInput | PriceTestCreateOrConnectWithoutPlanInput[]
    upsert?: PriceTestUpsertWithWhereUniqueWithoutPlanInput | PriceTestUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: PriceTestCreateManyPlanInputEnvelope
    set?: PriceTestWhereUniqueInput | PriceTestWhereUniqueInput[]
    disconnect?: PriceTestWhereUniqueInput | PriceTestWhereUniqueInput[]
    delete?: PriceTestWhereUniqueInput | PriceTestWhereUniqueInput[]
    connect?: PriceTestWhereUniqueInput | PriceTestWhereUniqueInput[]
    update?: PriceTestUpdateWithWhereUniqueWithoutPlanInput | PriceTestUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: PriceTestUpdateManyWithWhereWithoutPlanInput | PriceTestUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: PriceTestScalarWhereInput | PriceTestScalarWhereInput[]
  }

  export type RevenueRecognitionRuleUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<RevenueRecognitionRuleCreateWithoutPlanInput, RevenueRecognitionRuleUncheckedCreateWithoutPlanInput> | RevenueRecognitionRuleCreateWithoutPlanInput[] | RevenueRecognitionRuleUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: RevenueRecognitionRuleCreateOrConnectWithoutPlanInput | RevenueRecognitionRuleCreateOrConnectWithoutPlanInput[]
    upsert?: RevenueRecognitionRuleUpsertWithWhereUniqueWithoutPlanInput | RevenueRecognitionRuleUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: RevenueRecognitionRuleCreateManyPlanInputEnvelope
    set?: RevenueRecognitionRuleWhereUniqueInput | RevenueRecognitionRuleWhereUniqueInput[]
    disconnect?: RevenueRecognitionRuleWhereUniqueInput | RevenueRecognitionRuleWhereUniqueInput[]
    delete?: RevenueRecognitionRuleWhereUniqueInput | RevenueRecognitionRuleWhereUniqueInput[]
    connect?: RevenueRecognitionRuleWhereUniqueInput | RevenueRecognitionRuleWhereUniqueInput[]
    update?: RevenueRecognitionRuleUpdateWithWhereUniqueWithoutPlanInput | RevenueRecognitionRuleUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: RevenueRecognitionRuleUpdateManyWithWhereWithoutPlanInput | RevenueRecognitionRuleUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: RevenueRecognitionRuleScalarWhereInput | RevenueRecognitionRuleScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutPlanInput | SubscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutPlanInput | SubscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutPlanInput | SubscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type PlanCreateNestedOneWithoutFeaturesInput = {
    create?: XOR<PlanCreateWithoutFeaturesInput, PlanUncheckedCreateWithoutFeaturesInput>
    connectOrCreate?: PlanCreateOrConnectWithoutFeaturesInput
    connect?: PlanWhereUniqueInput
  }

  export type PlanUpdateOneRequiredWithoutFeaturesNestedInput = {
    create?: XOR<PlanCreateWithoutFeaturesInput, PlanUncheckedCreateWithoutFeaturesInput>
    connectOrCreate?: PlanCreateOrConnectWithoutFeaturesInput
    upsert?: PlanUpsertWithoutFeaturesInput
    connect?: PlanWhereUniqueInput
    update?: XOR<XOR<PlanUpdateToOneWithWhereWithoutFeaturesInput, PlanUpdateWithoutFeaturesInput>, PlanUncheckedUpdateWithoutFeaturesInput>
  }

  export type PlanCreateNestedOneWithoutUsageLimitsInput = {
    create?: XOR<PlanCreateWithoutUsageLimitsInput, PlanUncheckedCreateWithoutUsageLimitsInput>
    connectOrCreate?: PlanCreateOrConnectWithoutUsageLimitsInput
    connect?: PlanWhereUniqueInput
  }

  export type PlanUpdateOneRequiredWithoutUsageLimitsNestedInput = {
    create?: XOR<PlanCreateWithoutUsageLimitsInput, PlanUncheckedCreateWithoutUsageLimitsInput>
    connectOrCreate?: PlanCreateOrConnectWithoutUsageLimitsInput
    upsert?: PlanUpsertWithoutUsageLimitsInput
    connect?: PlanWhereUniqueInput
    update?: XOR<XOR<PlanUpdateToOneWithWhereWithoutUsageLimitsInput, PlanUpdateWithoutUsageLimitsInput>, PlanUncheckedUpdateWithoutUsageLimitsInput>
  }

  export type SubscriptionCreateNestedOneWithoutUsageRecordsInput = {
    create?: XOR<SubscriptionCreateWithoutUsageRecordsInput, SubscriptionUncheckedCreateWithoutUsageRecordsInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUsageRecordsInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type SubscriptionUpdateOneRequiredWithoutUsageRecordsNestedInput = {
    create?: XOR<SubscriptionCreateWithoutUsageRecordsInput, SubscriptionUncheckedCreateWithoutUsageRecordsInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUsageRecordsInput
    upsert?: SubscriptionUpsertWithoutUsageRecordsInput
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutUsageRecordsInput, SubscriptionUpdateWithoutUsageRecordsInput>, SubscriptionUncheckedUpdateWithoutUsageRecordsInput>
  }

  export type WebhookCreateeventsInput = {
    set: string[]
  }

  export type OrganizationCreateNestedOneWithoutWebhooksInput = {
    create?: XOR<OrganizationCreateWithoutWebhooksInput, OrganizationUncheckedCreateWithoutWebhooksInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutWebhooksInput
    connect?: OrganizationWhereUniqueInput
  }

  export type WebhookDeliveryCreateNestedManyWithoutWebhookInput = {
    create?: XOR<WebhookDeliveryCreateWithoutWebhookInput, WebhookDeliveryUncheckedCreateWithoutWebhookInput> | WebhookDeliveryCreateWithoutWebhookInput[] | WebhookDeliveryUncheckedCreateWithoutWebhookInput[]
    connectOrCreate?: WebhookDeliveryCreateOrConnectWithoutWebhookInput | WebhookDeliveryCreateOrConnectWithoutWebhookInput[]
    createMany?: WebhookDeliveryCreateManyWebhookInputEnvelope
    connect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
  }

  export type WebhookDeliveryUncheckedCreateNestedManyWithoutWebhookInput = {
    create?: XOR<WebhookDeliveryCreateWithoutWebhookInput, WebhookDeliveryUncheckedCreateWithoutWebhookInput> | WebhookDeliveryCreateWithoutWebhookInput[] | WebhookDeliveryUncheckedCreateWithoutWebhookInput[]
    connectOrCreate?: WebhookDeliveryCreateOrConnectWithoutWebhookInput | WebhookDeliveryCreateOrConnectWithoutWebhookInput[]
    createMany?: WebhookDeliveryCreateManyWebhookInputEnvelope
    connect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
  }

  export type WebhookUpdateeventsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type OrganizationUpdateOneRequiredWithoutWebhooksNestedInput = {
    create?: XOR<OrganizationCreateWithoutWebhooksInput, OrganizationUncheckedCreateWithoutWebhooksInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutWebhooksInput
    upsert?: OrganizationUpsertWithoutWebhooksInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutWebhooksInput, OrganizationUpdateWithoutWebhooksInput>, OrganizationUncheckedUpdateWithoutWebhooksInput>
  }

  export type WebhookDeliveryUpdateManyWithoutWebhookNestedInput = {
    create?: XOR<WebhookDeliveryCreateWithoutWebhookInput, WebhookDeliveryUncheckedCreateWithoutWebhookInput> | WebhookDeliveryCreateWithoutWebhookInput[] | WebhookDeliveryUncheckedCreateWithoutWebhookInput[]
    connectOrCreate?: WebhookDeliveryCreateOrConnectWithoutWebhookInput | WebhookDeliveryCreateOrConnectWithoutWebhookInput[]
    upsert?: WebhookDeliveryUpsertWithWhereUniqueWithoutWebhookInput | WebhookDeliveryUpsertWithWhereUniqueWithoutWebhookInput[]
    createMany?: WebhookDeliveryCreateManyWebhookInputEnvelope
    set?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    disconnect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    delete?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    connect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    update?: WebhookDeliveryUpdateWithWhereUniqueWithoutWebhookInput | WebhookDeliveryUpdateWithWhereUniqueWithoutWebhookInput[]
    updateMany?: WebhookDeliveryUpdateManyWithWhereWithoutWebhookInput | WebhookDeliveryUpdateManyWithWhereWithoutWebhookInput[]
    deleteMany?: WebhookDeliveryScalarWhereInput | WebhookDeliveryScalarWhereInput[]
  }

  export type WebhookDeliveryUncheckedUpdateManyWithoutWebhookNestedInput = {
    create?: XOR<WebhookDeliveryCreateWithoutWebhookInput, WebhookDeliveryUncheckedCreateWithoutWebhookInput> | WebhookDeliveryCreateWithoutWebhookInput[] | WebhookDeliveryUncheckedCreateWithoutWebhookInput[]
    connectOrCreate?: WebhookDeliveryCreateOrConnectWithoutWebhookInput | WebhookDeliveryCreateOrConnectWithoutWebhookInput[]
    upsert?: WebhookDeliveryUpsertWithWhereUniqueWithoutWebhookInput | WebhookDeliveryUpsertWithWhereUniqueWithoutWebhookInput[]
    createMany?: WebhookDeliveryCreateManyWebhookInputEnvelope
    set?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    disconnect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    delete?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    connect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    update?: WebhookDeliveryUpdateWithWhereUniqueWithoutWebhookInput | WebhookDeliveryUpdateWithWhereUniqueWithoutWebhookInput[]
    updateMany?: WebhookDeliveryUpdateManyWithWhereWithoutWebhookInput | WebhookDeliveryUpdateManyWithWhereWithoutWebhookInput[]
    deleteMany?: WebhookDeliveryScalarWhereInput | WebhookDeliveryScalarWhereInput[]
  }

  export type WebhookCreateNestedOneWithoutDeliveriesInput = {
    create?: XOR<WebhookCreateWithoutDeliveriesInput, WebhookUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: WebhookCreateOrConnectWithoutDeliveriesInput
    connect?: WebhookWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type WebhookUpdateOneRequiredWithoutDeliveriesNestedInput = {
    create?: XOR<WebhookCreateWithoutDeliveriesInput, WebhookUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: WebhookCreateOrConnectWithoutDeliveriesInput
    upsert?: WebhookUpsertWithoutDeliveriesInput
    connect?: WebhookWhereUniqueInput
    update?: XOR<XOR<WebhookUpdateToOneWithWhereWithoutDeliveriesInput, WebhookUpdateWithoutDeliveriesInput>, WebhookUncheckedUpdateWithoutDeliveriesInput>
  }

  export type UserCreateNestedOneWithoutRefreshTokensInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRefreshTokensNestedInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    upsert?: UserUpsertWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRefreshTokensInput, UserUpdateWithoutRefreshTokensInput>, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    connect?: UserWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<CustomerCreateWithoutPaymentsInput, CustomerUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutPaymentsInput
    connect?: CustomerWhereUniqueInput
  }

  export type SubscriptionCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<SubscriptionCreateWithoutPaymentsInput, SubscriptionUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPaymentsInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<OrderCreateWithoutPaymentsInput, OrderUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPaymentsInput
    connect?: OrderWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    upsert?: UserUpsertWithoutPaymentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPaymentsInput, UserUpdateWithoutPaymentsInput>, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type CustomerUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<CustomerCreateWithoutPaymentsInput, CustomerUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutPaymentsInput
    upsert?: CustomerUpsertWithoutPaymentsInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutPaymentsInput, CustomerUpdateWithoutPaymentsInput>, CustomerUncheckedUpdateWithoutPaymentsInput>
  }

  export type SubscriptionUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<SubscriptionCreateWithoutPaymentsInput, SubscriptionUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPaymentsInput
    upsert?: SubscriptionUpsertWithoutPaymentsInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutPaymentsInput, SubscriptionUpdateWithoutPaymentsInput>, SubscriptionUncheckedUpdateWithoutPaymentsInput>
  }

  export type OrderUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<OrderCreateWithoutPaymentsInput, OrderUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPaymentsInput
    upsert?: OrderUpsertWithoutPaymentsInput
    disconnect?: OrderWhereInput | boolean
    delete?: OrderWhereInput | boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutPaymentsInput, OrderUpdateWithoutPaymentsInput>, OrderUncheckedUpdateWithoutPaymentsInput>
  }

  export type OrganizationCreateNestedOneWithoutCarbonEstimatesInput = {
    create?: XOR<OrganizationCreateWithoutCarbonEstimatesInput, OrganizationUncheckedCreateWithoutCarbonEstimatesInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutCarbonEstimatesInput
    connect?: OrganizationWhereUniqueInput
  }

  export type OrganizationUpdateOneRequiredWithoutCarbonEstimatesNestedInput = {
    create?: XOR<OrganizationCreateWithoutCarbonEstimatesInput, OrganizationUncheckedCreateWithoutCarbonEstimatesInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutCarbonEstimatesInput
    upsert?: OrganizationUpsertWithoutCarbonEstimatesInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutCarbonEstimatesInput, OrganizationUpdateWithoutCarbonEstimatesInput>, OrganizationUncheckedUpdateWithoutCarbonEstimatesInput>
  }

  export type BillingRuleCreateconditionsInput = {
    set: InputJsonValue[]
  }

  export type BillingRuleCreateactionsInput = {
    set: InputJsonValue[]
  }

  export type OrganizationCreateNestedOneWithoutBillingRulesInput = {
    create?: XOR<OrganizationCreateWithoutBillingRulesInput, OrganizationUncheckedCreateWithoutBillingRulesInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutBillingRulesInput
    connect?: OrganizationWhereUniqueInput
  }

  export type BillingRuleUpdateconditionsInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type BillingRuleUpdateactionsInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type OrganizationUpdateOneRequiredWithoutBillingRulesNestedInput = {
    create?: XOR<OrganizationCreateWithoutBillingRulesInput, OrganizationUncheckedCreateWithoutBillingRulesInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutBillingRulesInput
    upsert?: OrganizationUpsertWithoutBillingRulesInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutBillingRulesInput, OrganizationUpdateWithoutBillingRulesInput>, OrganizationUncheckedUpdateWithoutBillingRulesInput>
  }

  export type BillingRuleTemplateCreateconditionsInput = {
    set: InputJsonValue[]
  }

  export type BillingRuleTemplateCreateactionsInput = {
    set: InputJsonValue[]
  }

  export type OrganizationCreateNestedOneWithoutBillingTemplatesInput = {
    create?: XOR<OrganizationCreateWithoutBillingTemplatesInput, OrganizationUncheckedCreateWithoutBillingTemplatesInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutBillingTemplatesInput
    connect?: OrganizationWhereUniqueInput
  }

  export type BillingRuleTemplateUpdateconditionsInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type BillingRuleTemplateUpdateactionsInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type OrganizationUpdateOneRequiredWithoutBillingTemplatesNestedInput = {
    create?: XOR<OrganizationCreateWithoutBillingTemplatesInput, OrganizationUncheckedCreateWithoutBillingTemplatesInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutBillingTemplatesInput
    upsert?: OrganizationUpsertWithoutBillingTemplatesInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutBillingTemplatesInput, OrganizationUpdateWithoutBillingTemplatesInput>, OrganizationUncheckedUpdateWithoutBillingTemplatesInput>
  }

  export type OrganizationCreateNestedOneWithoutOrdersInput = {
    create?: XOR<OrganizationCreateWithoutOrdersInput, OrganizationUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutOrdersInput
    connect?: OrganizationWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutOrdersInput = {
    create?: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutOrdersInput
    connect?: CustomerWhereUniqueInput
  }

  export type PaymentCreateNestedManyWithoutOrderInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput> | PaymentCreateWithoutOrderInput[] | PaymentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput | PaymentCreateOrConnectWithoutOrderInput[]
    createMany?: PaymentCreateManyOrderInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput> | PaymentCreateWithoutOrderInput[] | PaymentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput | PaymentCreateOrConnectWithoutOrderInput[]
    createMany?: PaymentCreateManyOrderInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type OrganizationUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<OrganizationCreateWithoutOrdersInput, OrganizationUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutOrdersInput
    upsert?: OrganizationUpsertWithoutOrdersInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutOrdersInput, OrganizationUpdateWithoutOrdersInput>, OrganizationUncheckedUpdateWithoutOrdersInput>
  }

  export type CustomerUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutOrdersInput
    upsert?: CustomerUpsertWithoutOrdersInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutOrdersInput, CustomerUpdateWithoutOrdersInput>, CustomerUncheckedUpdateWithoutOrdersInput>
  }

  export type PaymentUpdateManyWithoutOrderNestedInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput> | PaymentCreateWithoutOrderInput[] | PaymentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput | PaymentCreateOrConnectWithoutOrderInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutOrderInput | PaymentUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: PaymentCreateManyOrderInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutOrderInput | PaymentUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutOrderInput | PaymentUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput> | PaymentCreateWithoutOrderInput[] | PaymentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput | PaymentCreateOrConnectWithoutOrderInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutOrderInput | PaymentUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: PaymentCreateManyOrderInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutOrderInput | PaymentUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutOrderInput | PaymentUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PlanCreateNestedOneWithoutPriceHistoryInput = {
    create?: XOR<PlanCreateWithoutPriceHistoryInput, PlanUncheckedCreateWithoutPriceHistoryInput>
    connectOrCreate?: PlanCreateOrConnectWithoutPriceHistoryInput
    connect?: PlanWhereUniqueInput
  }

  export type PlanUpdateOneRequiredWithoutPriceHistoryNestedInput = {
    create?: XOR<PlanCreateWithoutPriceHistoryInput, PlanUncheckedCreateWithoutPriceHistoryInput>
    connectOrCreate?: PlanCreateOrConnectWithoutPriceHistoryInput
    upsert?: PlanUpsertWithoutPriceHistoryInput
    connect?: PlanWhereUniqueInput
    update?: XOR<XOR<PlanUpdateToOneWithWhereWithoutPriceHistoryInput, PlanUpdateWithoutPriceHistoryInput>, PlanUncheckedUpdateWithoutPriceHistoryInput>
  }

  export type PlanCreateNestedOneWithoutPriceTestsInput = {
    create?: XOR<PlanCreateWithoutPriceTestsInput, PlanUncheckedCreateWithoutPriceTestsInput>
    connectOrCreate?: PlanCreateOrConnectWithoutPriceTestsInput
    connect?: PlanWhereUniqueInput
  }

  export type PriceTestVariantCreateNestedManyWithoutTestInput = {
    create?: XOR<PriceTestVariantCreateWithoutTestInput, PriceTestVariantUncheckedCreateWithoutTestInput> | PriceTestVariantCreateWithoutTestInput[] | PriceTestVariantUncheckedCreateWithoutTestInput[]
    connectOrCreate?: PriceTestVariantCreateOrConnectWithoutTestInput | PriceTestVariantCreateOrConnectWithoutTestInput[]
    createMany?: PriceTestVariantCreateManyTestInputEnvelope
    connect?: PriceTestVariantWhereUniqueInput | PriceTestVariantWhereUniqueInput[]
  }

  export type PriceTestVariantUncheckedCreateNestedManyWithoutTestInput = {
    create?: XOR<PriceTestVariantCreateWithoutTestInput, PriceTestVariantUncheckedCreateWithoutTestInput> | PriceTestVariantCreateWithoutTestInput[] | PriceTestVariantUncheckedCreateWithoutTestInput[]
    connectOrCreate?: PriceTestVariantCreateOrConnectWithoutTestInput | PriceTestVariantCreateOrConnectWithoutTestInput[]
    createMany?: PriceTestVariantCreateManyTestInputEnvelope
    connect?: PriceTestVariantWhereUniqueInput | PriceTestVariantWhereUniqueInput[]
  }

  export type PlanUpdateOneRequiredWithoutPriceTestsNestedInput = {
    create?: XOR<PlanCreateWithoutPriceTestsInput, PlanUncheckedCreateWithoutPriceTestsInput>
    connectOrCreate?: PlanCreateOrConnectWithoutPriceTestsInput
    upsert?: PlanUpsertWithoutPriceTestsInput
    connect?: PlanWhereUniqueInput
    update?: XOR<XOR<PlanUpdateToOneWithWhereWithoutPriceTestsInput, PlanUpdateWithoutPriceTestsInput>, PlanUncheckedUpdateWithoutPriceTestsInput>
  }

  export type PriceTestVariantUpdateManyWithoutTestNestedInput = {
    create?: XOR<PriceTestVariantCreateWithoutTestInput, PriceTestVariantUncheckedCreateWithoutTestInput> | PriceTestVariantCreateWithoutTestInput[] | PriceTestVariantUncheckedCreateWithoutTestInput[]
    connectOrCreate?: PriceTestVariantCreateOrConnectWithoutTestInput | PriceTestVariantCreateOrConnectWithoutTestInput[]
    upsert?: PriceTestVariantUpsertWithWhereUniqueWithoutTestInput | PriceTestVariantUpsertWithWhereUniqueWithoutTestInput[]
    createMany?: PriceTestVariantCreateManyTestInputEnvelope
    set?: PriceTestVariantWhereUniqueInput | PriceTestVariantWhereUniqueInput[]
    disconnect?: PriceTestVariantWhereUniqueInput | PriceTestVariantWhereUniqueInput[]
    delete?: PriceTestVariantWhereUniqueInput | PriceTestVariantWhereUniqueInput[]
    connect?: PriceTestVariantWhereUniqueInput | PriceTestVariantWhereUniqueInput[]
    update?: PriceTestVariantUpdateWithWhereUniqueWithoutTestInput | PriceTestVariantUpdateWithWhereUniqueWithoutTestInput[]
    updateMany?: PriceTestVariantUpdateManyWithWhereWithoutTestInput | PriceTestVariantUpdateManyWithWhereWithoutTestInput[]
    deleteMany?: PriceTestVariantScalarWhereInput | PriceTestVariantScalarWhereInput[]
  }

  export type PriceTestVariantUncheckedUpdateManyWithoutTestNestedInput = {
    create?: XOR<PriceTestVariantCreateWithoutTestInput, PriceTestVariantUncheckedCreateWithoutTestInput> | PriceTestVariantCreateWithoutTestInput[] | PriceTestVariantUncheckedCreateWithoutTestInput[]
    connectOrCreate?: PriceTestVariantCreateOrConnectWithoutTestInput | PriceTestVariantCreateOrConnectWithoutTestInput[]
    upsert?: PriceTestVariantUpsertWithWhereUniqueWithoutTestInput | PriceTestVariantUpsertWithWhereUniqueWithoutTestInput[]
    createMany?: PriceTestVariantCreateManyTestInputEnvelope
    set?: PriceTestVariantWhereUniqueInput | PriceTestVariantWhereUniqueInput[]
    disconnect?: PriceTestVariantWhereUniqueInput | PriceTestVariantWhereUniqueInput[]
    delete?: PriceTestVariantWhereUniqueInput | PriceTestVariantWhereUniqueInput[]
    connect?: PriceTestVariantWhereUniqueInput | PriceTestVariantWhereUniqueInput[]
    update?: PriceTestVariantUpdateWithWhereUniqueWithoutTestInput | PriceTestVariantUpdateWithWhereUniqueWithoutTestInput[]
    updateMany?: PriceTestVariantUpdateManyWithWhereWithoutTestInput | PriceTestVariantUpdateManyWithWhereWithoutTestInput[]
    deleteMany?: PriceTestVariantScalarWhereInput | PriceTestVariantScalarWhereInput[]
  }

  export type PriceTestCreateNestedOneWithoutVariantsInput = {
    create?: XOR<PriceTestCreateWithoutVariantsInput, PriceTestUncheckedCreateWithoutVariantsInput>
    connectOrCreate?: PriceTestCreateOrConnectWithoutVariantsInput
    connect?: PriceTestWhereUniqueInput
  }

  export type PriceTestUpdateOneRequiredWithoutVariantsNestedInput = {
    create?: XOR<PriceTestCreateWithoutVariantsInput, PriceTestUncheckedCreateWithoutVariantsInput>
    connectOrCreate?: PriceTestCreateOrConnectWithoutVariantsInput
    upsert?: PriceTestUpsertWithoutVariantsInput
    connect?: PriceTestWhereUniqueInput
    update?: XOR<XOR<PriceTestUpdateToOneWithWhereWithoutVariantsInput, PriceTestUpdateWithoutVariantsInput>, PriceTestUncheckedUpdateWithoutVariantsInput>
  }

  export type PlanCreateNestedOneWithoutRevenueRulesInput = {
    create?: XOR<PlanCreateWithoutRevenueRulesInput, PlanUncheckedCreateWithoutRevenueRulesInput>
    connectOrCreate?: PlanCreateOrConnectWithoutRevenueRulesInput
    connect?: PlanWhereUniqueInput
  }

  export type PlanUpdateOneRequiredWithoutRevenueRulesNestedInput = {
    create?: XOR<PlanCreateWithoutRevenueRulesInput, PlanUncheckedCreateWithoutRevenueRulesInput>
    connectOrCreate?: PlanCreateOrConnectWithoutRevenueRulesInput
    upsert?: PlanUpsertWithoutRevenueRulesInput
    connect?: PlanWhereUniqueInput
    update?: XOR<XOR<PlanUpdateToOneWithWhereWithoutRevenueRulesInput, PlanUpdateWithoutRevenueRulesInput>, PlanUncheckedUpdateWithoutRevenueRulesInput>
  }

  export type ForecastResultCreateNestedManyWithoutModelInput = {
    create?: XOR<ForecastResultCreateWithoutModelInput, ForecastResultUncheckedCreateWithoutModelInput> | ForecastResultCreateWithoutModelInput[] | ForecastResultUncheckedCreateWithoutModelInput[]
    connectOrCreate?: ForecastResultCreateOrConnectWithoutModelInput | ForecastResultCreateOrConnectWithoutModelInput[]
    createMany?: ForecastResultCreateManyModelInputEnvelope
    connect?: ForecastResultWhereUniqueInput | ForecastResultWhereUniqueInput[]
  }

  export type TimeSeriesDataCreateNestedManyWithoutModelInput = {
    create?: XOR<TimeSeriesDataCreateWithoutModelInput, TimeSeriesDataUncheckedCreateWithoutModelInput> | TimeSeriesDataCreateWithoutModelInput[] | TimeSeriesDataUncheckedCreateWithoutModelInput[]
    connectOrCreate?: TimeSeriesDataCreateOrConnectWithoutModelInput | TimeSeriesDataCreateOrConnectWithoutModelInput[]
    createMany?: TimeSeriesDataCreateManyModelInputEnvelope
    connect?: TimeSeriesDataWhereUniqueInput | TimeSeriesDataWhereUniqueInput[]
  }

  export type ForecastResultUncheckedCreateNestedManyWithoutModelInput = {
    create?: XOR<ForecastResultCreateWithoutModelInput, ForecastResultUncheckedCreateWithoutModelInput> | ForecastResultCreateWithoutModelInput[] | ForecastResultUncheckedCreateWithoutModelInput[]
    connectOrCreate?: ForecastResultCreateOrConnectWithoutModelInput | ForecastResultCreateOrConnectWithoutModelInput[]
    createMany?: ForecastResultCreateManyModelInputEnvelope
    connect?: ForecastResultWhereUniqueInput | ForecastResultWhereUniqueInput[]
  }

  export type TimeSeriesDataUncheckedCreateNestedManyWithoutModelInput = {
    create?: XOR<TimeSeriesDataCreateWithoutModelInput, TimeSeriesDataUncheckedCreateWithoutModelInput> | TimeSeriesDataCreateWithoutModelInput[] | TimeSeriesDataUncheckedCreateWithoutModelInput[]
    connectOrCreate?: TimeSeriesDataCreateOrConnectWithoutModelInput | TimeSeriesDataCreateOrConnectWithoutModelInput[]
    createMany?: TimeSeriesDataCreateManyModelInputEnvelope
    connect?: TimeSeriesDataWhereUniqueInput | TimeSeriesDataWhereUniqueInput[]
  }

  export type ForecastResultUpdateManyWithoutModelNestedInput = {
    create?: XOR<ForecastResultCreateWithoutModelInput, ForecastResultUncheckedCreateWithoutModelInput> | ForecastResultCreateWithoutModelInput[] | ForecastResultUncheckedCreateWithoutModelInput[]
    connectOrCreate?: ForecastResultCreateOrConnectWithoutModelInput | ForecastResultCreateOrConnectWithoutModelInput[]
    upsert?: ForecastResultUpsertWithWhereUniqueWithoutModelInput | ForecastResultUpsertWithWhereUniqueWithoutModelInput[]
    createMany?: ForecastResultCreateManyModelInputEnvelope
    set?: ForecastResultWhereUniqueInput | ForecastResultWhereUniqueInput[]
    disconnect?: ForecastResultWhereUniqueInput | ForecastResultWhereUniqueInput[]
    delete?: ForecastResultWhereUniqueInput | ForecastResultWhereUniqueInput[]
    connect?: ForecastResultWhereUniqueInput | ForecastResultWhereUniqueInput[]
    update?: ForecastResultUpdateWithWhereUniqueWithoutModelInput | ForecastResultUpdateWithWhereUniqueWithoutModelInput[]
    updateMany?: ForecastResultUpdateManyWithWhereWithoutModelInput | ForecastResultUpdateManyWithWhereWithoutModelInput[]
    deleteMany?: ForecastResultScalarWhereInput | ForecastResultScalarWhereInput[]
  }

  export type TimeSeriesDataUpdateManyWithoutModelNestedInput = {
    create?: XOR<TimeSeriesDataCreateWithoutModelInput, TimeSeriesDataUncheckedCreateWithoutModelInput> | TimeSeriesDataCreateWithoutModelInput[] | TimeSeriesDataUncheckedCreateWithoutModelInput[]
    connectOrCreate?: TimeSeriesDataCreateOrConnectWithoutModelInput | TimeSeriesDataCreateOrConnectWithoutModelInput[]
    upsert?: TimeSeriesDataUpsertWithWhereUniqueWithoutModelInput | TimeSeriesDataUpsertWithWhereUniqueWithoutModelInput[]
    createMany?: TimeSeriesDataCreateManyModelInputEnvelope
    set?: TimeSeriesDataWhereUniqueInput | TimeSeriesDataWhereUniqueInput[]
    disconnect?: TimeSeriesDataWhereUniqueInput | TimeSeriesDataWhereUniqueInput[]
    delete?: TimeSeriesDataWhereUniqueInput | TimeSeriesDataWhereUniqueInput[]
    connect?: TimeSeriesDataWhereUniqueInput | TimeSeriesDataWhereUniqueInput[]
    update?: TimeSeriesDataUpdateWithWhereUniqueWithoutModelInput | TimeSeriesDataUpdateWithWhereUniqueWithoutModelInput[]
    updateMany?: TimeSeriesDataUpdateManyWithWhereWithoutModelInput | TimeSeriesDataUpdateManyWithWhereWithoutModelInput[]
    deleteMany?: TimeSeriesDataScalarWhereInput | TimeSeriesDataScalarWhereInput[]
  }

  export type ForecastResultUncheckedUpdateManyWithoutModelNestedInput = {
    create?: XOR<ForecastResultCreateWithoutModelInput, ForecastResultUncheckedCreateWithoutModelInput> | ForecastResultCreateWithoutModelInput[] | ForecastResultUncheckedCreateWithoutModelInput[]
    connectOrCreate?: ForecastResultCreateOrConnectWithoutModelInput | ForecastResultCreateOrConnectWithoutModelInput[]
    upsert?: ForecastResultUpsertWithWhereUniqueWithoutModelInput | ForecastResultUpsertWithWhereUniqueWithoutModelInput[]
    createMany?: ForecastResultCreateManyModelInputEnvelope
    set?: ForecastResultWhereUniqueInput | ForecastResultWhereUniqueInput[]
    disconnect?: ForecastResultWhereUniqueInput | ForecastResultWhereUniqueInput[]
    delete?: ForecastResultWhereUniqueInput | ForecastResultWhereUniqueInput[]
    connect?: ForecastResultWhereUniqueInput | ForecastResultWhereUniqueInput[]
    update?: ForecastResultUpdateWithWhereUniqueWithoutModelInput | ForecastResultUpdateWithWhereUniqueWithoutModelInput[]
    updateMany?: ForecastResultUpdateManyWithWhereWithoutModelInput | ForecastResultUpdateManyWithWhereWithoutModelInput[]
    deleteMany?: ForecastResultScalarWhereInput | ForecastResultScalarWhereInput[]
  }

  export type TimeSeriesDataUncheckedUpdateManyWithoutModelNestedInput = {
    create?: XOR<TimeSeriesDataCreateWithoutModelInput, TimeSeriesDataUncheckedCreateWithoutModelInput> | TimeSeriesDataCreateWithoutModelInput[] | TimeSeriesDataUncheckedCreateWithoutModelInput[]
    connectOrCreate?: TimeSeriesDataCreateOrConnectWithoutModelInput | TimeSeriesDataCreateOrConnectWithoutModelInput[]
    upsert?: TimeSeriesDataUpsertWithWhereUniqueWithoutModelInput | TimeSeriesDataUpsertWithWhereUniqueWithoutModelInput[]
    createMany?: TimeSeriesDataCreateManyModelInputEnvelope
    set?: TimeSeriesDataWhereUniqueInput | TimeSeriesDataWhereUniqueInput[]
    disconnect?: TimeSeriesDataWhereUniqueInput | TimeSeriesDataWhereUniqueInput[]
    delete?: TimeSeriesDataWhereUniqueInput | TimeSeriesDataWhereUniqueInput[]
    connect?: TimeSeriesDataWhereUniqueInput | TimeSeriesDataWhereUniqueInput[]
    update?: TimeSeriesDataUpdateWithWhereUniqueWithoutModelInput | TimeSeriesDataUpdateWithWhereUniqueWithoutModelInput[]
    updateMany?: TimeSeriesDataUpdateManyWithWhereWithoutModelInput | TimeSeriesDataUpdateManyWithWhereWithoutModelInput[]
    deleteMany?: TimeSeriesDataScalarWhereInput | TimeSeriesDataScalarWhereInput[]
  }

  export type ForecastModelCreateNestedOneWithoutTimeSeriesDataInput = {
    create?: XOR<ForecastModelCreateWithoutTimeSeriesDataInput, ForecastModelUncheckedCreateWithoutTimeSeriesDataInput>
    connectOrCreate?: ForecastModelCreateOrConnectWithoutTimeSeriesDataInput
    connect?: ForecastModelWhereUniqueInput
  }

  export type ForecastModelUpdateOneRequiredWithoutTimeSeriesDataNestedInput = {
    create?: XOR<ForecastModelCreateWithoutTimeSeriesDataInput, ForecastModelUncheckedCreateWithoutTimeSeriesDataInput>
    connectOrCreate?: ForecastModelCreateOrConnectWithoutTimeSeriesDataInput
    upsert?: ForecastModelUpsertWithoutTimeSeriesDataInput
    connect?: ForecastModelWhereUniqueInput
    update?: XOR<XOR<ForecastModelUpdateToOneWithWhereWithoutTimeSeriesDataInput, ForecastModelUpdateWithoutTimeSeriesDataInput>, ForecastModelUncheckedUpdateWithoutTimeSeriesDataInput>
  }

  export type ForecastModelCreateNestedOneWithoutForecastsInput = {
    create?: XOR<ForecastModelCreateWithoutForecastsInput, ForecastModelUncheckedCreateWithoutForecastsInput>
    connectOrCreate?: ForecastModelCreateOrConnectWithoutForecastsInput
    connect?: ForecastModelWhereUniqueInput
  }

  export type ForecastModelUpdateOneRequiredWithoutForecastsNestedInput = {
    create?: XOR<ForecastModelCreateWithoutForecastsInput, ForecastModelUncheckedCreateWithoutForecastsInput>
    connectOrCreate?: ForecastModelCreateOrConnectWithoutForecastsInput
    upsert?: ForecastModelUpsertWithoutForecastsInput
    connect?: ForecastModelWhereUniqueInput
    update?: XOR<XOR<ForecastModelUpdateToOneWithWhereWithoutForecastsInput, ForecastModelUpdateWithoutForecastsInput>, ForecastModelUncheckedUpdateWithoutForecastsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<OrganizationCreateWithoutNotificationsInput, OrganizationUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutNotificationsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type OrganizationUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<OrganizationCreateWithoutNotificationsInput, OrganizationUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutNotificationsInput
    upsert?: OrganizationUpsertWithoutNotificationsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutNotificationsInput, OrganizationUpdateWithoutNotificationsInput>, OrganizationUncheckedUpdateWithoutNotificationsInput>
  }

  export type OrganizationCreateNestedOneWithoutApiKeysInput = {
    create?: XOR<OrganizationCreateWithoutApiKeysInput, OrganizationUncheckedCreateWithoutApiKeysInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutApiKeysInput
    connect?: OrganizationWhereUniqueInput
  }

  export type OrganizationUpdateOneRequiredWithoutApiKeysNestedInput = {
    create?: XOR<OrganizationCreateWithoutApiKeysInput, OrganizationUncheckedCreateWithoutApiKeysInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutApiKeysInput
    upsert?: OrganizationUpsertWithoutApiKeysInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutApiKeysInput, OrganizationUpdateWithoutApiKeysInput>, OrganizationUncheckedUpdateWithoutApiKeysInput>
  }

  export type CustomerCreateNestedOneWithoutTaxCalculationsInput = {
    create?: XOR<CustomerCreateWithoutTaxCalculationsInput, CustomerUncheckedCreateWithoutTaxCalculationsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutTaxCalculationsInput
    connect?: CustomerWhereUniqueInput
  }

  export type CustomerUpdateOneRequiredWithoutTaxCalculationsNestedInput = {
    create?: XOR<CustomerCreateWithoutTaxCalculationsInput, CustomerUncheckedCreateWithoutTaxCalculationsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutTaxCalculationsInput
    upsert?: CustomerUpsertWithoutTaxCalculationsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutTaxCalculationsInput, CustomerUpdateWithoutTaxCalculationsInput>, CustomerUncheckedUpdateWithoutTaxCalculationsInput>
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UserCreateNestedOneWithoutRetryAttemptsInput = {
    create?: XOR<UserCreateWithoutRetryAttemptsInput, UserUncheckedCreateWithoutRetryAttemptsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRetryAttemptsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRetryAttemptsNestedInput = {
    create?: XOR<UserCreateWithoutRetryAttemptsInput, UserUncheckedCreateWithoutRetryAttemptsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRetryAttemptsInput
    upsert?: UserUpsertWithoutRetryAttemptsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRetryAttemptsInput, UserUpdateWithoutRetryAttemptsInput>, UserUncheckedUpdateWithoutRetryAttemptsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type: string
    message: string
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    organizationId: string
    type: string
    message: string
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RefreshTokenCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefreshTokenUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefreshTokenCreateOrConnectWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenCreateManyUserInputEnvelope = {
    data: RefreshTokenCreateManyUserInput | RefreshTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutUserInput = {
    id?: string
    amount: number
    currency?: string
    status: string
    stripePaymentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutPaymentsInput
    subscription?: SubscriptionCreateNestedOneWithoutPaymentsInput
    order?: OrderCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutUserInput = {
    id?: string
    amount: number
    currency?: string
    status: string
    stripePaymentId: string
    customerId?: string | null
    subscriptionId?: string | null
    orderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutUserInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>
  }

  export type PaymentCreateManyUserInputEnvelope = {
    data: PaymentCreateManyUserInput | PaymentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RetryAttemptCreateWithoutUserInput = {
    id?: string
    invoiceId: string
    attempts?: number
    lastAttemptAt?: Date | string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RetryAttemptUncheckedCreateWithoutUserInput = {
    id?: string
    invoiceId: string
    attempts?: number
    lastAttemptAt?: Date | string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RetryAttemptCreateOrConnectWithoutUserInput = {
    where: RetryAttemptWhereUniqueInput
    create: XOR<RetryAttemptCreateWithoutUserInput, RetryAttemptUncheckedCreateWithoutUserInput>
  }

  export type RetryAttemptCreateManyUserInputEnvelope = {
    data: RetryAttemptCreateManyUserInput | RetryAttemptCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    organizationId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type RefreshTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    update: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    data: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUpdateManyWithWhereWithoutUserInput = {
    where: RefreshTokenScalarWhereInput
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type RefreshTokenScalarWhereInput = {
    AND?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    OR?: RefreshTokenScalarWhereInput[]
    NOT?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    updatedAt?: DateTimeFilter<"RefreshToken"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>
  }

  export type PaymentUpdateManyWithWhereWithoutUserInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutUserInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: StringFilter<"Payment"> | string
    stripePaymentId?: StringFilter<"Payment"> | string
    userId?: StringFilter<"Payment"> | string
    customerId?: StringNullableFilter<"Payment"> | string | null
    subscriptionId?: StringNullableFilter<"Payment"> | string | null
    orderId?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type RetryAttemptUpsertWithWhereUniqueWithoutUserInput = {
    where: RetryAttemptWhereUniqueInput
    update: XOR<RetryAttemptUpdateWithoutUserInput, RetryAttemptUncheckedUpdateWithoutUserInput>
    create: XOR<RetryAttemptCreateWithoutUserInput, RetryAttemptUncheckedCreateWithoutUserInput>
  }

  export type RetryAttemptUpdateWithWhereUniqueWithoutUserInput = {
    where: RetryAttemptWhereUniqueInput
    data: XOR<RetryAttemptUpdateWithoutUserInput, RetryAttemptUncheckedUpdateWithoutUserInput>
  }

  export type RetryAttemptUpdateManyWithWhereWithoutUserInput = {
    where: RetryAttemptScalarWhereInput
    data: XOR<RetryAttemptUpdateManyMutationInput, RetryAttemptUncheckedUpdateManyWithoutUserInput>
  }

  export type RetryAttemptScalarWhereInput = {
    AND?: RetryAttemptScalarWhereInput | RetryAttemptScalarWhereInput[]
    OR?: RetryAttemptScalarWhereInput[]
    NOT?: RetryAttemptScalarWhereInput | RetryAttemptScalarWhereInput[]
    id?: StringFilter<"RetryAttempt"> | string
    invoiceId?: StringFilter<"RetryAttempt"> | string
    userId?: StringFilter<"RetryAttempt"> | string
    attempts?: IntFilter<"RetryAttempt"> | number
    lastAttemptAt?: DateTimeFilter<"RetryAttempt"> | Date | string
    status?: StringFilter<"RetryAttempt"> | string
    createdAt?: DateTimeFilter<"RetryAttempt"> | Date | string
    updatedAt?: DateTimeFilter<"RetryAttempt"> | Date | string
  }

  export type NotificationCreateWithoutOrganizationInput = {
    id?: string
    type: string
    message: string
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutOrganizationInput = {
    id?: string
    userId: string
    type: string
    message: string
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutOrganizationInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutOrganizationInput, NotificationUncheckedCreateWithoutOrganizationInput>
  }

  export type NotificationCreateManyOrganizationInputEnvelope = {
    data: NotificationCreateManyOrganizationInput | NotificationCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type WebhookCreateWithoutOrganizationInput = {
    id?: string
    url: string
    secret: string
    events?: WebhookCreateeventsInput | string[]
    status?: string
    retryConfig: JsonNullValueInput | InputJsonValue
    lastSuccess?: Date | string | null
    lastFailure?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveries?: WebhookDeliveryCreateNestedManyWithoutWebhookInput
  }

  export type WebhookUncheckedCreateWithoutOrganizationInput = {
    id?: string
    url: string
    secret: string
    events?: WebhookCreateeventsInput | string[]
    status?: string
    retryConfig: JsonNullValueInput | InputJsonValue
    lastSuccess?: Date | string | null
    lastFailure?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveries?: WebhookDeliveryUncheckedCreateNestedManyWithoutWebhookInput
  }

  export type WebhookCreateOrConnectWithoutOrganizationInput = {
    where: WebhookWhereUniqueInput
    create: XOR<WebhookCreateWithoutOrganizationInput, WebhookUncheckedCreateWithoutOrganizationInput>
  }

  export type WebhookCreateManyOrganizationInputEnvelope = {
    data: WebhookCreateManyOrganizationInput | WebhookCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type ApiKeyCreateWithoutOrganizationInput = {
    id?: string
    name: string
    key: string
    lastUsed?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiKeyUncheckedCreateWithoutOrganizationInput = {
    id?: string
    name: string
    key: string
    lastUsed?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiKeyCreateOrConnectWithoutOrganizationInput = {
    where: ApiKeyWhereUniqueInput
    create: XOR<ApiKeyCreateWithoutOrganizationInput, ApiKeyUncheckedCreateWithoutOrganizationInput>
  }

  export type ApiKeyCreateManyOrganizationInputEnvelope = {
    data: ApiKeyCreateManyOrganizationInput | ApiKeyCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type CarbonEstimateCreateWithoutOrganizationInput = {
    id?: string
    amount: number
    unit: string
    source: string
    category: string
    timestamp?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CarbonEstimateUncheckedCreateWithoutOrganizationInput = {
    id?: string
    amount: number
    unit: string
    source: string
    category: string
    timestamp?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CarbonEstimateCreateOrConnectWithoutOrganizationInput = {
    where: CarbonEstimateWhereUniqueInput
    create: XOR<CarbonEstimateCreateWithoutOrganizationInput, CarbonEstimateUncheckedCreateWithoutOrganizationInput>
  }

  export type CarbonEstimateCreateManyOrganizationInputEnvelope = {
    data: CarbonEstimateCreateManyOrganizationInput | CarbonEstimateCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type BillingRuleCreateWithoutOrganizationInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    conditions?: BillingRuleCreateconditionsInput | InputJsonValue[]
    actions?: BillingRuleCreateactionsInput | InputJsonValue[]
    priority?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillingRuleUncheckedCreateWithoutOrganizationInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    conditions?: BillingRuleCreateconditionsInput | InputJsonValue[]
    actions?: BillingRuleCreateactionsInput | InputJsonValue[]
    priority?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillingRuleCreateOrConnectWithoutOrganizationInput = {
    where: BillingRuleWhereUniqueInput
    create: XOR<BillingRuleCreateWithoutOrganizationInput, BillingRuleUncheckedCreateWithoutOrganizationInput>
  }

  export type BillingRuleCreateManyOrganizationInputEnvelope = {
    data: BillingRuleCreateManyOrganizationInput | BillingRuleCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type BillingRuleTemplateCreateWithoutOrganizationInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    conditions?: BillingRuleTemplateCreateconditionsInput | InputJsonValue[]
    actions?: BillingRuleTemplateCreateactionsInput | InputJsonValue[]
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillingRuleTemplateUncheckedCreateWithoutOrganizationInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    conditions?: BillingRuleTemplateCreateconditionsInput | InputJsonValue[]
    actions?: BillingRuleTemplateCreateactionsInput | InputJsonValue[]
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillingRuleTemplateCreateOrConnectWithoutOrganizationInput = {
    where: BillingRuleTemplateWhereUniqueInput
    create: XOR<BillingRuleTemplateCreateWithoutOrganizationInput, BillingRuleTemplateUncheckedCreateWithoutOrganizationInput>
  }

  export type BillingRuleTemplateCreateManyOrganizationInputEnvelope = {
    data: BillingRuleTemplateCreateManyOrganizationInput | BillingRuleTemplateCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutOrganizationInput = {
    id?: string
    amount: number
    currency: string
    status: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutOrdersInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutOrganizationInput = {
    id?: string
    customerId: string
    amount: number
    currency: string
    status: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutOrganizationInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutOrganizationInput, OrderUncheckedCreateWithoutOrganizationInput>
  }

  export type OrderCreateManyOrganizationInputEnvelope = {
    data: OrderCreateManyOrganizationInput | OrderCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type NotificationUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutOrganizationInput, NotificationUncheckedUpdateWithoutOrganizationInput>
    create: XOR<NotificationCreateWithoutOrganizationInput, NotificationUncheckedCreateWithoutOrganizationInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutOrganizationInput, NotificationUncheckedUpdateWithoutOrganizationInput>
  }

  export type NotificationUpdateManyWithWhereWithoutOrganizationInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type WebhookUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: WebhookWhereUniqueInput
    update: XOR<WebhookUpdateWithoutOrganizationInput, WebhookUncheckedUpdateWithoutOrganizationInput>
    create: XOR<WebhookCreateWithoutOrganizationInput, WebhookUncheckedCreateWithoutOrganizationInput>
  }

  export type WebhookUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: WebhookWhereUniqueInput
    data: XOR<WebhookUpdateWithoutOrganizationInput, WebhookUncheckedUpdateWithoutOrganizationInput>
  }

  export type WebhookUpdateManyWithWhereWithoutOrganizationInput = {
    where: WebhookScalarWhereInput
    data: XOR<WebhookUpdateManyMutationInput, WebhookUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type WebhookScalarWhereInput = {
    AND?: WebhookScalarWhereInput | WebhookScalarWhereInput[]
    OR?: WebhookScalarWhereInput[]
    NOT?: WebhookScalarWhereInput | WebhookScalarWhereInput[]
    id?: StringFilter<"Webhook"> | string
    organizationId?: StringFilter<"Webhook"> | string
    url?: StringFilter<"Webhook"> | string
    secret?: StringFilter<"Webhook"> | string
    events?: StringNullableListFilter<"Webhook">
    status?: StringFilter<"Webhook"> | string
    retryConfig?: JsonFilter<"Webhook">
    lastSuccess?: DateTimeNullableFilter<"Webhook"> | Date | string | null
    lastFailure?: DateTimeNullableFilter<"Webhook"> | Date | string | null
    createdAt?: DateTimeFilter<"Webhook"> | Date | string
    updatedAt?: DateTimeFilter<"Webhook"> | Date | string
  }

  export type ApiKeyUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: ApiKeyWhereUniqueInput
    update: XOR<ApiKeyUpdateWithoutOrganizationInput, ApiKeyUncheckedUpdateWithoutOrganizationInput>
    create: XOR<ApiKeyCreateWithoutOrganizationInput, ApiKeyUncheckedCreateWithoutOrganizationInput>
  }

  export type ApiKeyUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: ApiKeyWhereUniqueInput
    data: XOR<ApiKeyUpdateWithoutOrganizationInput, ApiKeyUncheckedUpdateWithoutOrganizationInput>
  }

  export type ApiKeyUpdateManyWithWhereWithoutOrganizationInput = {
    where: ApiKeyScalarWhereInput
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type ApiKeyScalarWhereInput = {
    AND?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
    OR?: ApiKeyScalarWhereInput[]
    NOT?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
    id?: StringFilter<"ApiKey"> | string
    organizationId?: StringFilter<"ApiKey"> | string
    name?: StringFilter<"ApiKey"> | string
    key?: StringFilter<"ApiKey"> | string
    lastUsed?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    updatedAt?: DateTimeFilter<"ApiKey"> | Date | string
  }

  export type CarbonEstimateUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: CarbonEstimateWhereUniqueInput
    update: XOR<CarbonEstimateUpdateWithoutOrganizationInput, CarbonEstimateUncheckedUpdateWithoutOrganizationInput>
    create: XOR<CarbonEstimateCreateWithoutOrganizationInput, CarbonEstimateUncheckedCreateWithoutOrganizationInput>
  }

  export type CarbonEstimateUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: CarbonEstimateWhereUniqueInput
    data: XOR<CarbonEstimateUpdateWithoutOrganizationInput, CarbonEstimateUncheckedUpdateWithoutOrganizationInput>
  }

  export type CarbonEstimateUpdateManyWithWhereWithoutOrganizationInput = {
    where: CarbonEstimateScalarWhereInput
    data: XOR<CarbonEstimateUpdateManyMutationInput, CarbonEstimateUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type CarbonEstimateScalarWhereInput = {
    AND?: CarbonEstimateScalarWhereInput | CarbonEstimateScalarWhereInput[]
    OR?: CarbonEstimateScalarWhereInput[]
    NOT?: CarbonEstimateScalarWhereInput | CarbonEstimateScalarWhereInput[]
    id?: StringFilter<"CarbonEstimate"> | string
    organizationId?: StringFilter<"CarbonEstimate"> | string
    amount?: FloatFilter<"CarbonEstimate"> | number
    unit?: StringFilter<"CarbonEstimate"> | string
    source?: StringFilter<"CarbonEstimate"> | string
    category?: StringFilter<"CarbonEstimate"> | string
    timestamp?: DateTimeFilter<"CarbonEstimate"> | Date | string
    metadata?: JsonNullableFilter<"CarbonEstimate">
    createdAt?: DateTimeFilter<"CarbonEstimate"> | Date | string
    updatedAt?: DateTimeFilter<"CarbonEstimate"> | Date | string
  }

  export type BillingRuleUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: BillingRuleWhereUniqueInput
    update: XOR<BillingRuleUpdateWithoutOrganizationInput, BillingRuleUncheckedUpdateWithoutOrganizationInput>
    create: XOR<BillingRuleCreateWithoutOrganizationInput, BillingRuleUncheckedCreateWithoutOrganizationInput>
  }

  export type BillingRuleUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: BillingRuleWhereUniqueInput
    data: XOR<BillingRuleUpdateWithoutOrganizationInput, BillingRuleUncheckedUpdateWithoutOrganizationInput>
  }

  export type BillingRuleUpdateManyWithWhereWithoutOrganizationInput = {
    where: BillingRuleScalarWhereInput
    data: XOR<BillingRuleUpdateManyMutationInput, BillingRuleUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type BillingRuleScalarWhereInput = {
    AND?: BillingRuleScalarWhereInput | BillingRuleScalarWhereInput[]
    OR?: BillingRuleScalarWhereInput[]
    NOT?: BillingRuleScalarWhereInput | BillingRuleScalarWhereInput[]
    id?: StringFilter<"BillingRule"> | string
    name?: StringFilter<"BillingRule"> | string
    description?: StringNullableFilter<"BillingRule"> | string | null
    type?: StringFilter<"BillingRule"> | string
    conditions?: JsonNullableListFilter<"BillingRule">
    actions?: JsonNullableListFilter<"BillingRule">
    priority?: IntFilter<"BillingRule"> | number
    isActive?: BoolFilter<"BillingRule"> | boolean
    organizationId?: StringFilter<"BillingRule"> | string
    createdAt?: DateTimeFilter<"BillingRule"> | Date | string
    updatedAt?: DateTimeFilter<"BillingRule"> | Date | string
  }

  export type BillingRuleTemplateUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: BillingRuleTemplateWhereUniqueInput
    update: XOR<BillingRuleTemplateUpdateWithoutOrganizationInput, BillingRuleTemplateUncheckedUpdateWithoutOrganizationInput>
    create: XOR<BillingRuleTemplateCreateWithoutOrganizationInput, BillingRuleTemplateUncheckedCreateWithoutOrganizationInput>
  }

  export type BillingRuleTemplateUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: BillingRuleTemplateWhereUniqueInput
    data: XOR<BillingRuleTemplateUpdateWithoutOrganizationInput, BillingRuleTemplateUncheckedUpdateWithoutOrganizationInput>
  }

  export type BillingRuleTemplateUpdateManyWithWhereWithoutOrganizationInput = {
    where: BillingRuleTemplateScalarWhereInput
    data: XOR<BillingRuleTemplateUpdateManyMutationInput, BillingRuleTemplateUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type BillingRuleTemplateScalarWhereInput = {
    AND?: BillingRuleTemplateScalarWhereInput | BillingRuleTemplateScalarWhereInput[]
    OR?: BillingRuleTemplateScalarWhereInput[]
    NOT?: BillingRuleTemplateScalarWhereInput | BillingRuleTemplateScalarWhereInput[]
    id?: StringFilter<"BillingRuleTemplate"> | string
    name?: StringFilter<"BillingRuleTemplate"> | string
    description?: StringNullableFilter<"BillingRuleTemplate"> | string | null
    type?: StringFilter<"BillingRuleTemplate"> | string
    conditions?: JsonNullableListFilter<"BillingRuleTemplate">
    actions?: JsonNullableListFilter<"BillingRuleTemplate">
    isDefault?: BoolFilter<"BillingRuleTemplate"> | boolean
    organizationId?: StringFilter<"BillingRuleTemplate"> | string
    createdAt?: DateTimeFilter<"BillingRuleTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"BillingRuleTemplate"> | Date | string
  }

  export type OrderUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutOrganizationInput, OrderUncheckedUpdateWithoutOrganizationInput>
    create: XOR<OrderCreateWithoutOrganizationInput, OrderUncheckedCreateWithoutOrganizationInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutOrganizationInput, OrderUncheckedUpdateWithoutOrganizationInput>
  }

  export type OrderUpdateManyWithWhereWithoutOrganizationInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: StringFilter<"Order"> | string
    organizationId?: StringFilter<"Order"> | string
    customerId?: StringFilter<"Order"> | string
    amount?: FloatFilter<"Order"> | number
    currency?: StringFilter<"Order"> | string
    status?: StringFilter<"Order"> | string
    metadata?: JsonNullableFilter<"Order">
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
  }

  export type PaymentCreateWithoutCustomerInput = {
    id?: string
    amount: number
    currency?: string
    status: string
    stripePaymentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPaymentsInput
    subscription?: SubscriptionCreateNestedOneWithoutPaymentsInput
    order?: OrderCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutCustomerInput = {
    id?: string
    amount: number
    currency?: string
    status: string
    stripePaymentId: string
    userId: string
    subscriptionId?: string | null
    orderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutCustomerInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutCustomerInput, PaymentUncheckedCreateWithoutCustomerInput>
  }

  export type PaymentCreateManyCustomerInputEnvelope = {
    data: PaymentCreateManyCustomerInput | PaymentCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionCreateWithoutCustomerInput = {
    id?: string
    status: $Enums.SubscriptionStatus
    stripeSubscriptionId?: string | null
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    cancelledAt?: Date | string | null
    pausedAt?: Date | string | null
    resumesAt?: Date | string | null
    trialEndsAt?: Date | string | null
    billingCycleAnchor: Date | string
    proration?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    plan: PlanCreateNestedOneWithoutSubscriptionsInput
    payments?: PaymentCreateNestedManyWithoutSubscriptionInput
    usageRecords?: UsageRecordCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutCustomerInput = {
    id?: string
    status: $Enums.SubscriptionStatus
    planId: string
    stripeSubscriptionId?: string | null
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    cancelledAt?: Date | string | null
    pausedAt?: Date | string | null
    resumesAt?: Date | string | null
    trialEndsAt?: Date | string | null
    billingCycleAnchor: Date | string
    proration?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutSubscriptionInput
    usageRecords?: UsageRecordUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutCustomerInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutCustomerInput, SubscriptionUncheckedCreateWithoutCustomerInput>
  }

  export type TaxCalculationCreateWithoutCustomerInput = {
    id?: string
    amount: number
    taxRate: number
    taxAmount: number
    country: string
    state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxCalculationUncheckedCreateWithoutCustomerInput = {
    id?: string
    amount: number
    taxRate: number
    taxAmount: number
    country: string
    state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxCalculationCreateOrConnectWithoutCustomerInput = {
    where: TaxCalculationWhereUniqueInput
    create: XOR<TaxCalculationCreateWithoutCustomerInput, TaxCalculationUncheckedCreateWithoutCustomerInput>
  }

  export type TaxCalculationCreateManyCustomerInputEnvelope = {
    data: TaxCalculationCreateManyCustomerInput | TaxCalculationCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutCustomerInput = {
    id?: string
    amount: number
    currency: string
    status: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutOrdersInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutCustomerInput = {
    id?: string
    organizationId: string
    amount: number
    currency: string
    status: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput>
  }

  export type OrderCreateManyCustomerInputEnvelope = {
    data: OrderCreateManyCustomerInput | OrderCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type PaymentUpsertWithWhereUniqueWithoutCustomerInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutCustomerInput, PaymentUncheckedUpdateWithoutCustomerInput>
    create: XOR<PaymentCreateWithoutCustomerInput, PaymentUncheckedCreateWithoutCustomerInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutCustomerInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutCustomerInput, PaymentUncheckedUpdateWithoutCustomerInput>
  }

  export type PaymentUpdateManyWithWhereWithoutCustomerInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutCustomerInput>
  }

  export type SubscriptionUpsertWithoutCustomerInput = {
    update: XOR<SubscriptionUpdateWithoutCustomerInput, SubscriptionUncheckedUpdateWithoutCustomerInput>
    create: XOR<SubscriptionCreateWithoutCustomerInput, SubscriptionUncheckedCreateWithoutCustomerInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutCustomerInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutCustomerInput, SubscriptionUncheckedUpdateWithoutCustomerInput>
  }

  export type SubscriptionUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resumesAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billingCycleAnchor?: DateTimeFieldUpdateOperationsInput | Date | string
    proration?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneRequiredWithoutSubscriptionsNestedInput
    payments?: PaymentUpdateManyWithoutSubscriptionNestedInput
    usageRecords?: UsageRecordUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    planId?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resumesAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billingCycleAnchor?: DateTimeFieldUpdateOperationsInput | Date | string
    proration?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutSubscriptionNestedInput
    usageRecords?: UsageRecordUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type TaxCalculationUpsertWithWhereUniqueWithoutCustomerInput = {
    where: TaxCalculationWhereUniqueInput
    update: XOR<TaxCalculationUpdateWithoutCustomerInput, TaxCalculationUncheckedUpdateWithoutCustomerInput>
    create: XOR<TaxCalculationCreateWithoutCustomerInput, TaxCalculationUncheckedCreateWithoutCustomerInput>
  }

  export type TaxCalculationUpdateWithWhereUniqueWithoutCustomerInput = {
    where: TaxCalculationWhereUniqueInput
    data: XOR<TaxCalculationUpdateWithoutCustomerInput, TaxCalculationUncheckedUpdateWithoutCustomerInput>
  }

  export type TaxCalculationUpdateManyWithWhereWithoutCustomerInput = {
    where: TaxCalculationScalarWhereInput
    data: XOR<TaxCalculationUpdateManyMutationInput, TaxCalculationUncheckedUpdateManyWithoutCustomerInput>
  }

  export type TaxCalculationScalarWhereInput = {
    AND?: TaxCalculationScalarWhereInput | TaxCalculationScalarWhereInput[]
    OR?: TaxCalculationScalarWhereInput[]
    NOT?: TaxCalculationScalarWhereInput | TaxCalculationScalarWhereInput[]
    id?: StringFilter<"TaxCalculation"> | string
    customerId?: StringFilter<"TaxCalculation"> | string
    amount?: FloatFilter<"TaxCalculation"> | number
    taxRate?: FloatFilter<"TaxCalculation"> | number
    taxAmount?: FloatFilter<"TaxCalculation"> | number
    country?: StringFilter<"TaxCalculation"> | string
    state?: StringNullableFilter<"TaxCalculation"> | string | null
    createdAt?: DateTimeFilter<"TaxCalculation"> | Date | string
    updatedAt?: DateTimeFilter<"TaxCalculation"> | Date | string
  }

  export type OrderUpsertWithWhereUniqueWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutCustomerInput, OrderUncheckedUpdateWithoutCustomerInput>
    create: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutCustomerInput, OrderUncheckedUpdateWithoutCustomerInput>
  }

  export type OrderUpdateManyWithWhereWithoutCustomerInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CustomerCreateWithoutSubscriptionInput = {
    id?: string
    userId: string
    stripeCustomerId?: string | null
    name?: string | null
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentCreateNestedManyWithoutCustomerInput
    taxCalculations?: TaxCalculationCreateNestedManyWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    userId: string
    stripeCustomerId?: string | null
    name?: string | null
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutCustomerInput
    taxCalculations?: TaxCalculationUncheckedCreateNestedManyWithoutCustomerInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutSubscriptionInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutSubscriptionInput, CustomerUncheckedCreateWithoutSubscriptionInput>
  }

  export type PlanCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    description?: string | null
    basePrice: number
    currentPrice: number
    currency?: string
    interval?: string
    stripePriceId?: string | null
    isActive?: boolean
    sortOrder?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    marketSegment?: string | null
    costBasis?: number | null
    churnRisk?: number | null
    features?: PlanFeatureCreateNestedManyWithoutPlanInput
    usageLimits?: UsageLimitCreateNestedManyWithoutPlanInput
    priceHistory?: PriceHistoryCreateNestedManyWithoutPlanInput
    priceTests?: PriceTestCreateNestedManyWithoutPlanInput
    revenueRules?: RevenueRecognitionRuleCreateNestedManyWithoutPlanInput
  }

  export type PlanUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    description?: string | null
    basePrice: number
    currentPrice: number
    currency?: string
    interval?: string
    stripePriceId?: string | null
    isActive?: boolean
    sortOrder?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    marketSegment?: string | null
    costBasis?: number | null
    churnRisk?: number | null
    features?: PlanFeatureUncheckedCreateNestedManyWithoutPlanInput
    usageLimits?: UsageLimitUncheckedCreateNestedManyWithoutPlanInput
    priceHistory?: PriceHistoryUncheckedCreateNestedManyWithoutPlanInput
    priceTests?: PriceTestUncheckedCreateNestedManyWithoutPlanInput
    revenueRules?: RevenueRecognitionRuleUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanCreateOrConnectWithoutSubscriptionsInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutSubscriptionsInput, PlanUncheckedCreateWithoutSubscriptionsInput>
  }

  export type PaymentCreateWithoutSubscriptionInput = {
    id?: string
    amount: number
    currency?: string
    status: string
    stripePaymentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPaymentsInput
    customer?: CustomerCreateNestedOneWithoutPaymentsInput
    order?: OrderCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    amount: number
    currency?: string
    status: string
    stripePaymentId: string
    userId: string
    customerId?: string | null
    orderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutSubscriptionInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutSubscriptionInput, PaymentUncheckedCreateWithoutSubscriptionInput>
  }

  export type PaymentCreateManySubscriptionInputEnvelope = {
    data: PaymentCreateManySubscriptionInput | PaymentCreateManySubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type UsageRecordCreateWithoutSubscriptionInput = {
    id?: string
    featureKey: string
    quantity: number
    timestamp?: Date | string
    billingPeriodStart: Date | string
    billingPeriodEnd: Date | string
    processed?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UsageRecordUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    featureKey: string
    quantity: number
    timestamp?: Date | string
    billingPeriodStart: Date | string
    billingPeriodEnd: Date | string
    processed?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UsageRecordCreateOrConnectWithoutSubscriptionInput = {
    where: UsageRecordWhereUniqueInput
    create: XOR<UsageRecordCreateWithoutSubscriptionInput, UsageRecordUncheckedCreateWithoutSubscriptionInput>
  }

  export type UsageRecordCreateManySubscriptionInputEnvelope = {
    data: UsageRecordCreateManySubscriptionInput | UsageRecordCreateManySubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutSubscriptionInput = {
    update: XOR<CustomerUpdateWithoutSubscriptionInput, CustomerUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<CustomerCreateWithoutSubscriptionInput, CustomerUncheckedCreateWithoutSubscriptionInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutSubscriptionInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutSubscriptionInput, CustomerUncheckedUpdateWithoutSubscriptionInput>
  }

  export type CustomerUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUpdateManyWithoutCustomerNestedInput
    taxCalculations?: TaxCalculationUpdateManyWithoutCustomerNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutCustomerNestedInput
    taxCalculations?: TaxCalculationUncheckedUpdateManyWithoutCustomerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type PlanUpsertWithoutSubscriptionsInput = {
    update: XOR<PlanUpdateWithoutSubscriptionsInput, PlanUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<PlanCreateWithoutSubscriptionsInput, PlanUncheckedCreateWithoutSubscriptionsInput>
    where?: PlanWhereInput
  }

  export type PlanUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: PlanWhereInput
    data: XOR<PlanUpdateWithoutSubscriptionsInput, PlanUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type PlanUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    interval?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    marketSegment?: NullableStringFieldUpdateOperationsInput | string | null
    costBasis?: NullableFloatFieldUpdateOperationsInput | number | null
    churnRisk?: NullableFloatFieldUpdateOperationsInput | number | null
    features?: PlanFeatureUpdateManyWithoutPlanNestedInput
    usageLimits?: UsageLimitUpdateManyWithoutPlanNestedInput
    priceHistory?: PriceHistoryUpdateManyWithoutPlanNestedInput
    priceTests?: PriceTestUpdateManyWithoutPlanNestedInput
    revenueRules?: RevenueRecognitionRuleUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    interval?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    marketSegment?: NullableStringFieldUpdateOperationsInput | string | null
    costBasis?: NullableFloatFieldUpdateOperationsInput | number | null
    churnRisk?: NullableFloatFieldUpdateOperationsInput | number | null
    features?: PlanFeatureUncheckedUpdateManyWithoutPlanNestedInput
    usageLimits?: UsageLimitUncheckedUpdateManyWithoutPlanNestedInput
    priceHistory?: PriceHistoryUncheckedUpdateManyWithoutPlanNestedInput
    priceTests?: PriceTestUncheckedUpdateManyWithoutPlanNestedInput
    revenueRules?: RevenueRecognitionRuleUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type PaymentUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutSubscriptionInput, PaymentUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<PaymentCreateWithoutSubscriptionInput, PaymentUncheckedCreateWithoutSubscriptionInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutSubscriptionInput, PaymentUncheckedUpdateWithoutSubscriptionInput>
  }

  export type PaymentUpdateManyWithWhereWithoutSubscriptionInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type UsageRecordUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: UsageRecordWhereUniqueInput
    update: XOR<UsageRecordUpdateWithoutSubscriptionInput, UsageRecordUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<UsageRecordCreateWithoutSubscriptionInput, UsageRecordUncheckedCreateWithoutSubscriptionInput>
  }

  export type UsageRecordUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: UsageRecordWhereUniqueInput
    data: XOR<UsageRecordUpdateWithoutSubscriptionInput, UsageRecordUncheckedUpdateWithoutSubscriptionInput>
  }

  export type UsageRecordUpdateManyWithWhereWithoutSubscriptionInput = {
    where: UsageRecordScalarWhereInput
    data: XOR<UsageRecordUpdateManyMutationInput, UsageRecordUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type UsageRecordScalarWhereInput = {
    AND?: UsageRecordScalarWhereInput | UsageRecordScalarWhereInput[]
    OR?: UsageRecordScalarWhereInput[]
    NOT?: UsageRecordScalarWhereInput | UsageRecordScalarWhereInput[]
    id?: StringFilter<"UsageRecord"> | string
    subscriptionId?: StringFilter<"UsageRecord"> | string
    featureKey?: StringFilter<"UsageRecord"> | string
    quantity?: FloatFilter<"UsageRecord"> | number
    timestamp?: DateTimeFilter<"UsageRecord"> | Date | string
    billingPeriodStart?: DateTimeFilter<"UsageRecord"> | Date | string
    billingPeriodEnd?: DateTimeFilter<"UsageRecord"> | Date | string
    processed?: BoolFilter<"UsageRecord"> | boolean
    metadata?: JsonNullableFilter<"UsageRecord">
  }

  export type PlanFeatureCreateWithoutPlanInput = {
    id?: string
    name: string
    description?: string | null
    included?: boolean
    value?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanFeatureUncheckedCreateWithoutPlanInput = {
    id?: string
    name: string
    description?: string | null
    included?: boolean
    value?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanFeatureCreateOrConnectWithoutPlanInput = {
    where: PlanFeatureWhereUniqueInput
    create: XOR<PlanFeatureCreateWithoutPlanInput, PlanFeatureUncheckedCreateWithoutPlanInput>
  }

  export type PlanFeatureCreateManyPlanInputEnvelope = {
    data: PlanFeatureCreateManyPlanInput | PlanFeatureCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type UsageLimitCreateWithoutPlanInput = {
    id?: string
    featureKey: string
    limit: number
    interval?: string
    overage?: boolean
    overagePrice?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsageLimitUncheckedCreateWithoutPlanInput = {
    id?: string
    featureKey: string
    limit: number
    interval?: string
    overage?: boolean
    overagePrice?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsageLimitCreateOrConnectWithoutPlanInput = {
    where: UsageLimitWhereUniqueInput
    create: XOR<UsageLimitCreateWithoutPlanInput, UsageLimitUncheckedCreateWithoutPlanInput>
  }

  export type UsageLimitCreateManyPlanInputEnvelope = {
    data: UsageLimitCreateManyPlanInput | UsageLimitCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type PriceHistoryCreateWithoutPlanInput = {
    id?: string
    price: number
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    reason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PriceHistoryUncheckedCreateWithoutPlanInput = {
    id?: string
    price: number
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    reason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PriceHistoryCreateOrConnectWithoutPlanInput = {
    where: PriceHistoryWhereUniqueInput
    create: XOR<PriceHistoryCreateWithoutPlanInput, PriceHistoryUncheckedCreateWithoutPlanInput>
  }

  export type PriceHistoryCreateManyPlanInputEnvelope = {
    data: PriceHistoryCreateManyPlanInput | PriceHistoryCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type PriceTestCreateWithoutPlanInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    status: string
    targetMetric: string
    minConfidence: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    variants?: PriceTestVariantCreateNestedManyWithoutTestInput
  }

  export type PriceTestUncheckedCreateWithoutPlanInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    status: string
    targetMetric: string
    minConfidence: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    variants?: PriceTestVariantUncheckedCreateNestedManyWithoutTestInput
  }

  export type PriceTestCreateOrConnectWithoutPlanInput = {
    where: PriceTestWhereUniqueInput
    create: XOR<PriceTestCreateWithoutPlanInput, PriceTestUncheckedCreateWithoutPlanInput>
  }

  export type PriceTestCreateManyPlanInputEnvelope = {
    data: PriceTestCreateManyPlanInput | PriceTestCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type RevenueRecognitionRuleCreateWithoutPlanInput = {
    id?: string
    type: string
    deferralPeriod?: number | null
    conditions?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RevenueRecognitionRuleUncheckedCreateWithoutPlanInput = {
    id?: string
    type: string
    deferralPeriod?: number | null
    conditions?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RevenueRecognitionRuleCreateOrConnectWithoutPlanInput = {
    where: RevenueRecognitionRuleWhereUniqueInput
    create: XOR<RevenueRecognitionRuleCreateWithoutPlanInput, RevenueRecognitionRuleUncheckedCreateWithoutPlanInput>
  }

  export type RevenueRecognitionRuleCreateManyPlanInputEnvelope = {
    data: RevenueRecognitionRuleCreateManyPlanInput | RevenueRecognitionRuleCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionCreateWithoutPlanInput = {
    id?: string
    status: $Enums.SubscriptionStatus
    stripeSubscriptionId?: string | null
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    cancelledAt?: Date | string | null
    pausedAt?: Date | string | null
    resumesAt?: Date | string | null
    trialEndsAt?: Date | string | null
    billingCycleAnchor: Date | string
    proration?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutSubscriptionInput
    payments?: PaymentCreateNestedManyWithoutSubscriptionInput
    usageRecords?: UsageRecordCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutPlanInput = {
    id?: string
    customerId: string
    status: $Enums.SubscriptionStatus
    stripeSubscriptionId?: string | null
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    cancelledAt?: Date | string | null
    pausedAt?: Date | string | null
    resumesAt?: Date | string | null
    trialEndsAt?: Date | string | null
    billingCycleAnchor: Date | string
    proration?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutSubscriptionInput
    usageRecords?: UsageRecordUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type SubscriptionCreateManyPlanInputEnvelope = {
    data: SubscriptionCreateManyPlanInput | SubscriptionCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type PlanFeatureUpsertWithWhereUniqueWithoutPlanInput = {
    where: PlanFeatureWhereUniqueInput
    update: XOR<PlanFeatureUpdateWithoutPlanInput, PlanFeatureUncheckedUpdateWithoutPlanInput>
    create: XOR<PlanFeatureCreateWithoutPlanInput, PlanFeatureUncheckedCreateWithoutPlanInput>
  }

  export type PlanFeatureUpdateWithWhereUniqueWithoutPlanInput = {
    where: PlanFeatureWhereUniqueInput
    data: XOR<PlanFeatureUpdateWithoutPlanInput, PlanFeatureUncheckedUpdateWithoutPlanInput>
  }

  export type PlanFeatureUpdateManyWithWhereWithoutPlanInput = {
    where: PlanFeatureScalarWhereInput
    data: XOR<PlanFeatureUpdateManyMutationInput, PlanFeatureUncheckedUpdateManyWithoutPlanInput>
  }

  export type PlanFeatureScalarWhereInput = {
    AND?: PlanFeatureScalarWhereInput | PlanFeatureScalarWhereInput[]
    OR?: PlanFeatureScalarWhereInput[]
    NOT?: PlanFeatureScalarWhereInput | PlanFeatureScalarWhereInput[]
    id?: StringFilter<"PlanFeature"> | string
    planId?: StringFilter<"PlanFeature"> | string
    name?: StringFilter<"PlanFeature"> | string
    description?: StringNullableFilter<"PlanFeature"> | string | null
    included?: BoolFilter<"PlanFeature"> | boolean
    value?: StringNullableFilter<"PlanFeature"> | string | null
    sortOrder?: IntFilter<"PlanFeature"> | number
    createdAt?: DateTimeFilter<"PlanFeature"> | Date | string
    updatedAt?: DateTimeFilter<"PlanFeature"> | Date | string
  }

  export type UsageLimitUpsertWithWhereUniqueWithoutPlanInput = {
    where: UsageLimitWhereUniqueInput
    update: XOR<UsageLimitUpdateWithoutPlanInput, UsageLimitUncheckedUpdateWithoutPlanInput>
    create: XOR<UsageLimitCreateWithoutPlanInput, UsageLimitUncheckedCreateWithoutPlanInput>
  }

  export type UsageLimitUpdateWithWhereUniqueWithoutPlanInput = {
    where: UsageLimitWhereUniqueInput
    data: XOR<UsageLimitUpdateWithoutPlanInput, UsageLimitUncheckedUpdateWithoutPlanInput>
  }

  export type UsageLimitUpdateManyWithWhereWithoutPlanInput = {
    where: UsageLimitScalarWhereInput
    data: XOR<UsageLimitUpdateManyMutationInput, UsageLimitUncheckedUpdateManyWithoutPlanInput>
  }

  export type UsageLimitScalarWhereInput = {
    AND?: UsageLimitScalarWhereInput | UsageLimitScalarWhereInput[]
    OR?: UsageLimitScalarWhereInput[]
    NOT?: UsageLimitScalarWhereInput | UsageLimitScalarWhereInput[]
    id?: StringFilter<"UsageLimit"> | string
    planId?: StringFilter<"UsageLimit"> | string
    featureKey?: StringFilter<"UsageLimit"> | string
    limit?: FloatFilter<"UsageLimit"> | number
    interval?: StringFilter<"UsageLimit"> | string
    overage?: BoolFilter<"UsageLimit"> | boolean
    overagePrice?: FloatNullableFilter<"UsageLimit"> | number | null
    createdAt?: DateTimeFilter<"UsageLimit"> | Date | string
    updatedAt?: DateTimeFilter<"UsageLimit"> | Date | string
  }

  export type PriceHistoryUpsertWithWhereUniqueWithoutPlanInput = {
    where: PriceHistoryWhereUniqueInput
    update: XOR<PriceHistoryUpdateWithoutPlanInput, PriceHistoryUncheckedUpdateWithoutPlanInput>
    create: XOR<PriceHistoryCreateWithoutPlanInput, PriceHistoryUncheckedCreateWithoutPlanInput>
  }

  export type PriceHistoryUpdateWithWhereUniqueWithoutPlanInput = {
    where: PriceHistoryWhereUniqueInput
    data: XOR<PriceHistoryUpdateWithoutPlanInput, PriceHistoryUncheckedUpdateWithoutPlanInput>
  }

  export type PriceHistoryUpdateManyWithWhereWithoutPlanInput = {
    where: PriceHistoryScalarWhereInput
    data: XOR<PriceHistoryUpdateManyMutationInput, PriceHistoryUncheckedUpdateManyWithoutPlanInput>
  }

  export type PriceHistoryScalarWhereInput = {
    AND?: PriceHistoryScalarWhereInput | PriceHistoryScalarWhereInput[]
    OR?: PriceHistoryScalarWhereInput[]
    NOT?: PriceHistoryScalarWhereInput | PriceHistoryScalarWhereInput[]
    id?: StringFilter<"PriceHistory"> | string
    planId?: StringFilter<"PriceHistory"> | string
    price?: FloatFilter<"PriceHistory"> | number
    effectiveFrom?: DateTimeFilter<"PriceHistory"> | Date | string
    effectiveTo?: DateTimeNullableFilter<"PriceHistory"> | Date | string | null
    reason?: StringNullableFilter<"PriceHistory"> | string | null
    metadata?: JsonNullableFilter<"PriceHistory">
    createdAt?: DateTimeFilter<"PriceHistory"> | Date | string
  }

  export type PriceTestUpsertWithWhereUniqueWithoutPlanInput = {
    where: PriceTestWhereUniqueInput
    update: XOR<PriceTestUpdateWithoutPlanInput, PriceTestUncheckedUpdateWithoutPlanInput>
    create: XOR<PriceTestCreateWithoutPlanInput, PriceTestUncheckedCreateWithoutPlanInput>
  }

  export type PriceTestUpdateWithWhereUniqueWithoutPlanInput = {
    where: PriceTestWhereUniqueInput
    data: XOR<PriceTestUpdateWithoutPlanInput, PriceTestUncheckedUpdateWithoutPlanInput>
  }

  export type PriceTestUpdateManyWithWhereWithoutPlanInput = {
    where: PriceTestScalarWhereInput
    data: XOR<PriceTestUpdateManyMutationInput, PriceTestUncheckedUpdateManyWithoutPlanInput>
  }

  export type PriceTestScalarWhereInput = {
    AND?: PriceTestScalarWhereInput | PriceTestScalarWhereInput[]
    OR?: PriceTestScalarWhereInput[]
    NOT?: PriceTestScalarWhereInput | PriceTestScalarWhereInput[]
    id?: StringFilter<"PriceTest"> | string
    planId?: StringFilter<"PriceTest"> | string
    name?: StringFilter<"PriceTest"> | string
    description?: StringNullableFilter<"PriceTest"> | string | null
    startDate?: DateTimeFilter<"PriceTest"> | Date | string
    endDate?: DateTimeNullableFilter<"PriceTest"> | Date | string | null
    status?: StringFilter<"PriceTest"> | string
    targetMetric?: StringFilter<"PriceTest"> | string
    minConfidence?: FloatFilter<"PriceTest"> | number
    metadata?: JsonNullableFilter<"PriceTest">
    createdAt?: DateTimeFilter<"PriceTest"> | Date | string
    updatedAt?: DateTimeFilter<"PriceTest"> | Date | string
  }

  export type RevenueRecognitionRuleUpsertWithWhereUniqueWithoutPlanInput = {
    where: RevenueRecognitionRuleWhereUniqueInput
    update: XOR<RevenueRecognitionRuleUpdateWithoutPlanInput, RevenueRecognitionRuleUncheckedUpdateWithoutPlanInput>
    create: XOR<RevenueRecognitionRuleCreateWithoutPlanInput, RevenueRecognitionRuleUncheckedCreateWithoutPlanInput>
  }

  export type RevenueRecognitionRuleUpdateWithWhereUniqueWithoutPlanInput = {
    where: RevenueRecognitionRuleWhereUniqueInput
    data: XOR<RevenueRecognitionRuleUpdateWithoutPlanInput, RevenueRecognitionRuleUncheckedUpdateWithoutPlanInput>
  }

  export type RevenueRecognitionRuleUpdateManyWithWhereWithoutPlanInput = {
    where: RevenueRecognitionRuleScalarWhereInput
    data: XOR<RevenueRecognitionRuleUpdateManyMutationInput, RevenueRecognitionRuleUncheckedUpdateManyWithoutPlanInput>
  }

  export type RevenueRecognitionRuleScalarWhereInput = {
    AND?: RevenueRecognitionRuleScalarWhereInput | RevenueRecognitionRuleScalarWhereInput[]
    OR?: RevenueRecognitionRuleScalarWhereInput[]
    NOT?: RevenueRecognitionRuleScalarWhereInput | RevenueRecognitionRuleScalarWhereInput[]
    id?: StringFilter<"RevenueRecognitionRule"> | string
    planId?: StringFilter<"RevenueRecognitionRule"> | string
    type?: StringFilter<"RevenueRecognitionRule"> | string
    deferralPeriod?: IntNullableFilter<"RevenueRecognitionRule"> | number | null
    conditions?: JsonNullableFilter<"RevenueRecognitionRule">
    metadata?: JsonNullableFilter<"RevenueRecognitionRule">
    createdAt?: DateTimeFilter<"RevenueRecognitionRule"> | Date | string
    updatedAt?: DateTimeFilter<"RevenueRecognitionRule"> | Date | string
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutPlanInput, SubscriptionUncheckedUpdateWithoutPlanInput>
    create: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutPlanInput, SubscriptionUncheckedUpdateWithoutPlanInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutPlanInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutPlanInput>
  }

  export type SubscriptionScalarWhereInput = {
    AND?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    OR?: SubscriptionScalarWhereInput[]
    NOT?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    id?: StringFilter<"Subscription"> | string
    customerId?: StringFilter<"Subscription"> | string
    status?: EnumSubscriptionStatusFilter<"Subscription"> | $Enums.SubscriptionStatus
    planId?: StringFilter<"Subscription"> | string
    stripeSubscriptionId?: StringNullableFilter<"Subscription"> | string | null
    currentPeriodStart?: DateTimeFilter<"Subscription"> | Date | string
    currentPeriodEnd?: DateTimeFilter<"Subscription"> | Date | string
    cancelAtPeriodEnd?: BoolFilter<"Subscription"> | boolean
    cancelledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    pausedAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    resumesAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    trialEndsAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    billingCycleAnchor?: DateTimeFilter<"Subscription"> | Date | string
    proration?: JsonNullableFilter<"Subscription">
    metadata?: JsonNullableFilter<"Subscription">
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
  }

  export type PlanCreateWithoutFeaturesInput = {
    id?: string
    name: string
    description?: string | null
    basePrice: number
    currentPrice: number
    currency?: string
    interval?: string
    stripePriceId?: string | null
    isActive?: boolean
    sortOrder?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    marketSegment?: string | null
    costBasis?: number | null
    churnRisk?: number | null
    usageLimits?: UsageLimitCreateNestedManyWithoutPlanInput
    priceHistory?: PriceHistoryCreateNestedManyWithoutPlanInput
    priceTests?: PriceTestCreateNestedManyWithoutPlanInput
    revenueRules?: RevenueRecognitionRuleCreateNestedManyWithoutPlanInput
    subscriptions?: SubscriptionCreateNestedManyWithoutPlanInput
  }

  export type PlanUncheckedCreateWithoutFeaturesInput = {
    id?: string
    name: string
    description?: string | null
    basePrice: number
    currentPrice: number
    currency?: string
    interval?: string
    stripePriceId?: string | null
    isActive?: boolean
    sortOrder?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    marketSegment?: string | null
    costBasis?: number | null
    churnRisk?: number | null
    usageLimits?: UsageLimitUncheckedCreateNestedManyWithoutPlanInput
    priceHistory?: PriceHistoryUncheckedCreateNestedManyWithoutPlanInput
    priceTests?: PriceTestUncheckedCreateNestedManyWithoutPlanInput
    revenueRules?: RevenueRecognitionRuleUncheckedCreateNestedManyWithoutPlanInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanCreateOrConnectWithoutFeaturesInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutFeaturesInput, PlanUncheckedCreateWithoutFeaturesInput>
  }

  export type PlanUpsertWithoutFeaturesInput = {
    update: XOR<PlanUpdateWithoutFeaturesInput, PlanUncheckedUpdateWithoutFeaturesInput>
    create: XOR<PlanCreateWithoutFeaturesInput, PlanUncheckedCreateWithoutFeaturesInput>
    where?: PlanWhereInput
  }

  export type PlanUpdateToOneWithWhereWithoutFeaturesInput = {
    where?: PlanWhereInput
    data: XOR<PlanUpdateWithoutFeaturesInput, PlanUncheckedUpdateWithoutFeaturesInput>
  }

  export type PlanUpdateWithoutFeaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    interval?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    marketSegment?: NullableStringFieldUpdateOperationsInput | string | null
    costBasis?: NullableFloatFieldUpdateOperationsInput | number | null
    churnRisk?: NullableFloatFieldUpdateOperationsInput | number | null
    usageLimits?: UsageLimitUpdateManyWithoutPlanNestedInput
    priceHistory?: PriceHistoryUpdateManyWithoutPlanNestedInput
    priceTests?: PriceTestUpdateManyWithoutPlanNestedInput
    revenueRules?: RevenueRecognitionRuleUpdateManyWithoutPlanNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateWithoutFeaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    interval?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    marketSegment?: NullableStringFieldUpdateOperationsInput | string | null
    costBasis?: NullableFloatFieldUpdateOperationsInput | number | null
    churnRisk?: NullableFloatFieldUpdateOperationsInput | number | null
    usageLimits?: UsageLimitUncheckedUpdateManyWithoutPlanNestedInput
    priceHistory?: PriceHistoryUncheckedUpdateManyWithoutPlanNestedInput
    priceTests?: PriceTestUncheckedUpdateManyWithoutPlanNestedInput
    revenueRules?: RevenueRecognitionRuleUncheckedUpdateManyWithoutPlanNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type PlanCreateWithoutUsageLimitsInput = {
    id?: string
    name: string
    description?: string | null
    basePrice: number
    currentPrice: number
    currency?: string
    interval?: string
    stripePriceId?: string | null
    isActive?: boolean
    sortOrder?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    marketSegment?: string | null
    costBasis?: number | null
    churnRisk?: number | null
    features?: PlanFeatureCreateNestedManyWithoutPlanInput
    priceHistory?: PriceHistoryCreateNestedManyWithoutPlanInput
    priceTests?: PriceTestCreateNestedManyWithoutPlanInput
    revenueRules?: RevenueRecognitionRuleCreateNestedManyWithoutPlanInput
    subscriptions?: SubscriptionCreateNestedManyWithoutPlanInput
  }

  export type PlanUncheckedCreateWithoutUsageLimitsInput = {
    id?: string
    name: string
    description?: string | null
    basePrice: number
    currentPrice: number
    currency?: string
    interval?: string
    stripePriceId?: string | null
    isActive?: boolean
    sortOrder?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    marketSegment?: string | null
    costBasis?: number | null
    churnRisk?: number | null
    features?: PlanFeatureUncheckedCreateNestedManyWithoutPlanInput
    priceHistory?: PriceHistoryUncheckedCreateNestedManyWithoutPlanInput
    priceTests?: PriceTestUncheckedCreateNestedManyWithoutPlanInput
    revenueRules?: RevenueRecognitionRuleUncheckedCreateNestedManyWithoutPlanInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanCreateOrConnectWithoutUsageLimitsInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutUsageLimitsInput, PlanUncheckedCreateWithoutUsageLimitsInput>
  }

  export type PlanUpsertWithoutUsageLimitsInput = {
    update: XOR<PlanUpdateWithoutUsageLimitsInput, PlanUncheckedUpdateWithoutUsageLimitsInput>
    create: XOR<PlanCreateWithoutUsageLimitsInput, PlanUncheckedCreateWithoutUsageLimitsInput>
    where?: PlanWhereInput
  }

  export type PlanUpdateToOneWithWhereWithoutUsageLimitsInput = {
    where?: PlanWhereInput
    data: XOR<PlanUpdateWithoutUsageLimitsInput, PlanUncheckedUpdateWithoutUsageLimitsInput>
  }

  export type PlanUpdateWithoutUsageLimitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    interval?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    marketSegment?: NullableStringFieldUpdateOperationsInput | string | null
    costBasis?: NullableFloatFieldUpdateOperationsInput | number | null
    churnRisk?: NullableFloatFieldUpdateOperationsInput | number | null
    features?: PlanFeatureUpdateManyWithoutPlanNestedInput
    priceHistory?: PriceHistoryUpdateManyWithoutPlanNestedInput
    priceTests?: PriceTestUpdateManyWithoutPlanNestedInput
    revenueRules?: RevenueRecognitionRuleUpdateManyWithoutPlanNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateWithoutUsageLimitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    interval?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    marketSegment?: NullableStringFieldUpdateOperationsInput | string | null
    costBasis?: NullableFloatFieldUpdateOperationsInput | number | null
    churnRisk?: NullableFloatFieldUpdateOperationsInput | number | null
    features?: PlanFeatureUncheckedUpdateManyWithoutPlanNestedInput
    priceHistory?: PriceHistoryUncheckedUpdateManyWithoutPlanNestedInput
    priceTests?: PriceTestUncheckedUpdateManyWithoutPlanNestedInput
    revenueRules?: RevenueRecognitionRuleUncheckedUpdateManyWithoutPlanNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type SubscriptionCreateWithoutUsageRecordsInput = {
    id?: string
    status: $Enums.SubscriptionStatus
    stripeSubscriptionId?: string | null
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    cancelledAt?: Date | string | null
    pausedAt?: Date | string | null
    resumesAt?: Date | string | null
    trialEndsAt?: Date | string | null
    billingCycleAnchor: Date | string
    proration?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutSubscriptionInput
    plan: PlanCreateNestedOneWithoutSubscriptionsInput
    payments?: PaymentCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutUsageRecordsInput = {
    id?: string
    customerId: string
    status: $Enums.SubscriptionStatus
    planId: string
    stripeSubscriptionId?: string | null
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    cancelledAt?: Date | string | null
    pausedAt?: Date | string | null
    resumesAt?: Date | string | null
    trialEndsAt?: Date | string | null
    billingCycleAnchor: Date | string
    proration?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutUsageRecordsInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutUsageRecordsInput, SubscriptionUncheckedCreateWithoutUsageRecordsInput>
  }

  export type SubscriptionUpsertWithoutUsageRecordsInput = {
    update: XOR<SubscriptionUpdateWithoutUsageRecordsInput, SubscriptionUncheckedUpdateWithoutUsageRecordsInput>
    create: XOR<SubscriptionCreateWithoutUsageRecordsInput, SubscriptionUncheckedCreateWithoutUsageRecordsInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutUsageRecordsInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutUsageRecordsInput, SubscriptionUncheckedUpdateWithoutUsageRecordsInput>
  }

  export type SubscriptionUpdateWithoutUsageRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resumesAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billingCycleAnchor?: DateTimeFieldUpdateOperationsInput | Date | string
    proration?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutSubscriptionNestedInput
    plan?: PlanUpdateOneRequiredWithoutSubscriptionsNestedInput
    payments?: PaymentUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutUsageRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    planId?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resumesAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billingCycleAnchor?: DateTimeFieldUpdateOperationsInput | Date | string
    proration?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type OrganizationCreateWithoutWebhooksInput = {
    id?: string
    name: string
    email?: string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationCreateNestedManyWithoutOrganizationInput
    apiKeys?: ApiKeyCreateNestedManyWithoutOrganizationInput
    carbonEstimates?: CarbonEstimateCreateNestedManyWithoutOrganizationInput
    billingRules?: BillingRuleCreateNestedManyWithoutOrganizationInput
    billingTemplates?: BillingRuleTemplateCreateNestedManyWithoutOrganizationInput
    orders?: OrderCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutWebhooksInput = {
    id?: string
    name: string
    email?: string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrganizationInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutOrganizationInput
    carbonEstimates?: CarbonEstimateUncheckedCreateNestedManyWithoutOrganizationInput
    billingRules?: BillingRuleUncheckedCreateNestedManyWithoutOrganizationInput
    billingTemplates?: BillingRuleTemplateUncheckedCreateNestedManyWithoutOrganizationInput
    orders?: OrderUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutWebhooksInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutWebhooksInput, OrganizationUncheckedCreateWithoutWebhooksInput>
  }

  export type WebhookDeliveryCreateWithoutWebhookInput = {
    id?: string
    payload: JsonNullValueInput | InputJsonValue
    status: string
    statusCode?: number | null
    response?: string | null
    error?: string | null
    retries?: number
    createdAt?: Date | string
  }

  export type WebhookDeliveryUncheckedCreateWithoutWebhookInput = {
    id?: string
    payload: JsonNullValueInput | InputJsonValue
    status: string
    statusCode?: number | null
    response?: string | null
    error?: string | null
    retries?: number
    createdAt?: Date | string
  }

  export type WebhookDeliveryCreateOrConnectWithoutWebhookInput = {
    where: WebhookDeliveryWhereUniqueInput
    create: XOR<WebhookDeliveryCreateWithoutWebhookInput, WebhookDeliveryUncheckedCreateWithoutWebhookInput>
  }

  export type WebhookDeliveryCreateManyWebhookInputEnvelope = {
    data: WebhookDeliveryCreateManyWebhookInput | WebhookDeliveryCreateManyWebhookInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutWebhooksInput = {
    update: XOR<OrganizationUpdateWithoutWebhooksInput, OrganizationUncheckedUpdateWithoutWebhooksInput>
    create: XOR<OrganizationCreateWithoutWebhooksInput, OrganizationUncheckedCreateWithoutWebhooksInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutWebhooksInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutWebhooksInput, OrganizationUncheckedUpdateWithoutWebhooksInput>
  }

  export type OrganizationUpdateWithoutWebhooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUpdateManyWithoutOrganizationNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutOrganizationNestedInput
    carbonEstimates?: CarbonEstimateUpdateManyWithoutOrganizationNestedInput
    billingRules?: BillingRuleUpdateManyWithoutOrganizationNestedInput
    billingTemplates?: BillingRuleTemplateUpdateManyWithoutOrganizationNestedInput
    orders?: OrderUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutWebhooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutOrganizationNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutOrganizationNestedInput
    carbonEstimates?: CarbonEstimateUncheckedUpdateManyWithoutOrganizationNestedInput
    billingRules?: BillingRuleUncheckedUpdateManyWithoutOrganizationNestedInput
    billingTemplates?: BillingRuleTemplateUncheckedUpdateManyWithoutOrganizationNestedInput
    orders?: OrderUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type WebhookDeliveryUpsertWithWhereUniqueWithoutWebhookInput = {
    where: WebhookDeliveryWhereUniqueInput
    update: XOR<WebhookDeliveryUpdateWithoutWebhookInput, WebhookDeliveryUncheckedUpdateWithoutWebhookInput>
    create: XOR<WebhookDeliveryCreateWithoutWebhookInput, WebhookDeliveryUncheckedCreateWithoutWebhookInput>
  }

  export type WebhookDeliveryUpdateWithWhereUniqueWithoutWebhookInput = {
    where: WebhookDeliveryWhereUniqueInput
    data: XOR<WebhookDeliveryUpdateWithoutWebhookInput, WebhookDeliveryUncheckedUpdateWithoutWebhookInput>
  }

  export type WebhookDeliveryUpdateManyWithWhereWithoutWebhookInput = {
    where: WebhookDeliveryScalarWhereInput
    data: XOR<WebhookDeliveryUpdateManyMutationInput, WebhookDeliveryUncheckedUpdateManyWithoutWebhookInput>
  }

  export type WebhookDeliveryScalarWhereInput = {
    AND?: WebhookDeliveryScalarWhereInput | WebhookDeliveryScalarWhereInput[]
    OR?: WebhookDeliveryScalarWhereInput[]
    NOT?: WebhookDeliveryScalarWhereInput | WebhookDeliveryScalarWhereInput[]
    id?: StringFilter<"WebhookDelivery"> | string
    webhookId?: StringFilter<"WebhookDelivery"> | string
    payload?: JsonFilter<"WebhookDelivery">
    status?: StringFilter<"WebhookDelivery"> | string
    statusCode?: IntNullableFilter<"WebhookDelivery"> | number | null
    response?: StringNullableFilter<"WebhookDelivery"> | string | null
    error?: StringNullableFilter<"WebhookDelivery"> | string | null
    retries?: IntFilter<"WebhookDelivery"> | number
    createdAt?: DateTimeFilter<"WebhookDelivery"> | Date | string
  }

  export type WebhookCreateWithoutDeliveriesInput = {
    id?: string
    url: string
    secret: string
    events?: WebhookCreateeventsInput | string[]
    status?: string
    retryConfig: JsonNullValueInput | InputJsonValue
    lastSuccess?: Date | string | null
    lastFailure?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutWebhooksInput
  }

  export type WebhookUncheckedCreateWithoutDeliveriesInput = {
    id?: string
    organizationId: string
    url: string
    secret: string
    events?: WebhookCreateeventsInput | string[]
    status?: string
    retryConfig: JsonNullValueInput | InputJsonValue
    lastSuccess?: Date | string | null
    lastFailure?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebhookCreateOrConnectWithoutDeliveriesInput = {
    where: WebhookWhereUniqueInput
    create: XOR<WebhookCreateWithoutDeliveriesInput, WebhookUncheckedCreateWithoutDeliveriesInput>
  }

  export type WebhookUpsertWithoutDeliveriesInput = {
    update: XOR<WebhookUpdateWithoutDeliveriesInput, WebhookUncheckedUpdateWithoutDeliveriesInput>
    create: XOR<WebhookCreateWithoutDeliveriesInput, WebhookUncheckedCreateWithoutDeliveriesInput>
    where?: WebhookWhereInput
  }

  export type WebhookUpdateToOneWithWhereWithoutDeliveriesInput = {
    where?: WebhookWhereInput
    data: XOR<WebhookUpdateWithoutDeliveriesInput, WebhookUncheckedUpdateWithoutDeliveriesInput>
  }

  export type WebhookUpdateWithoutDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    events?: WebhookUpdateeventsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    retryConfig?: JsonNullValueInput | InputJsonValue
    lastSuccess?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFailure?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutWebhooksNestedInput
  }

  export type WebhookUncheckedUpdateWithoutDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    events?: WebhookUpdateeventsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    retryConfig?: JsonNullValueInput | InputJsonValue
    lastSuccess?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFailure?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutRefreshTokensInput = {
    id?: string
    name?: string | null
    email: string
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: string
    notifications?: NotificationCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    retryAttempts?: RetryAttemptCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRefreshTokensInput = {
    id?: string
    name?: string | null
    email: string
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: string
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    retryAttempts?: RetryAttemptUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRefreshTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
  }

  export type UserUpsertWithoutRefreshTokensInput = {
    update: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRefreshTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    retryAttempts?: RetryAttemptUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    retryAttempts?: RetryAttemptUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPaymentsInput = {
    id?: string
    name?: string | null
    email: string
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: string
    notifications?: NotificationCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    retryAttempts?: RetryAttemptCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPaymentsInput = {
    id?: string
    name?: string | null
    email: string
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: string
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    retryAttempts?: RetryAttemptUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPaymentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
  }

  export type CustomerCreateWithoutPaymentsInput = {
    id?: string
    userId: string
    stripeCustomerId?: string | null
    name?: string | null
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subscription?: SubscriptionCreateNestedOneWithoutCustomerInput
    taxCalculations?: TaxCalculationCreateNestedManyWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutPaymentsInput = {
    id?: string
    userId: string
    stripeCustomerId?: string | null
    name?: string | null
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutCustomerInput
    taxCalculations?: TaxCalculationUncheckedCreateNestedManyWithoutCustomerInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutPaymentsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutPaymentsInput, CustomerUncheckedCreateWithoutPaymentsInput>
  }

  export type SubscriptionCreateWithoutPaymentsInput = {
    id?: string
    status: $Enums.SubscriptionStatus
    stripeSubscriptionId?: string | null
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    cancelledAt?: Date | string | null
    pausedAt?: Date | string | null
    resumesAt?: Date | string | null
    trialEndsAt?: Date | string | null
    billingCycleAnchor: Date | string
    proration?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutSubscriptionInput
    plan: PlanCreateNestedOneWithoutSubscriptionsInput
    usageRecords?: UsageRecordCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutPaymentsInput = {
    id?: string
    customerId: string
    status: $Enums.SubscriptionStatus
    planId: string
    stripeSubscriptionId?: string | null
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    cancelledAt?: Date | string | null
    pausedAt?: Date | string | null
    resumesAt?: Date | string | null
    trialEndsAt?: Date | string | null
    billingCycleAnchor: Date | string
    proration?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    usageRecords?: UsageRecordUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutPaymentsInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutPaymentsInput, SubscriptionUncheckedCreateWithoutPaymentsInput>
  }

  export type OrderCreateWithoutPaymentsInput = {
    id?: string
    amount: number
    currency: string
    status: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutOrdersInput
    customer: CustomerCreateNestedOneWithoutOrdersInput
  }

  export type OrderUncheckedCreateWithoutPaymentsInput = {
    id?: string
    organizationId: string
    customerId: string
    amount: number
    currency: string
    status: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateOrConnectWithoutPaymentsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutPaymentsInput, OrderUncheckedCreateWithoutPaymentsInput>
  }

  export type UserUpsertWithoutPaymentsInput = {
    update: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    retryAttempts?: RetryAttemptUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    retryAttempts?: RetryAttemptUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CustomerUpsertWithoutPaymentsInput = {
    update: XOR<CustomerUpdateWithoutPaymentsInput, CustomerUncheckedUpdateWithoutPaymentsInput>
    create: XOR<CustomerCreateWithoutPaymentsInput, CustomerUncheckedCreateWithoutPaymentsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutPaymentsInput, CustomerUncheckedUpdateWithoutPaymentsInput>
  }

  export type CustomerUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateOneWithoutCustomerNestedInput
    taxCalculations?: TaxCalculationUpdateManyWithoutCustomerNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUncheckedUpdateOneWithoutCustomerNestedInput
    taxCalculations?: TaxCalculationUncheckedUpdateManyWithoutCustomerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type SubscriptionUpsertWithoutPaymentsInput = {
    update: XOR<SubscriptionUpdateWithoutPaymentsInput, SubscriptionUncheckedUpdateWithoutPaymentsInput>
    create: XOR<SubscriptionCreateWithoutPaymentsInput, SubscriptionUncheckedCreateWithoutPaymentsInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutPaymentsInput, SubscriptionUncheckedUpdateWithoutPaymentsInput>
  }

  export type SubscriptionUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resumesAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billingCycleAnchor?: DateTimeFieldUpdateOperationsInput | Date | string
    proration?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutSubscriptionNestedInput
    plan?: PlanUpdateOneRequiredWithoutSubscriptionsNestedInput
    usageRecords?: UsageRecordUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    planId?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resumesAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billingCycleAnchor?: DateTimeFieldUpdateOperationsInput | Date | string
    proration?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usageRecords?: UsageRecordUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type OrderUpsertWithoutPaymentsInput = {
    update: XOR<OrderUpdateWithoutPaymentsInput, OrderUncheckedUpdateWithoutPaymentsInput>
    create: XOR<OrderCreateWithoutPaymentsInput, OrderUncheckedCreateWithoutPaymentsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutPaymentsInput, OrderUncheckedUpdateWithoutPaymentsInput>
  }

  export type OrderUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutOrdersNestedInput
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationCreateWithoutCarbonEstimatesInput = {
    id?: string
    name: string
    email?: string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationCreateNestedManyWithoutOrganizationInput
    webhooks?: WebhookCreateNestedManyWithoutOrganizationInput
    apiKeys?: ApiKeyCreateNestedManyWithoutOrganizationInput
    billingRules?: BillingRuleCreateNestedManyWithoutOrganizationInput
    billingTemplates?: BillingRuleTemplateCreateNestedManyWithoutOrganizationInput
    orders?: OrderCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutCarbonEstimatesInput = {
    id?: string
    name: string
    email?: string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrganizationInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutOrganizationInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutOrganizationInput
    billingRules?: BillingRuleUncheckedCreateNestedManyWithoutOrganizationInput
    billingTemplates?: BillingRuleTemplateUncheckedCreateNestedManyWithoutOrganizationInput
    orders?: OrderUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutCarbonEstimatesInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutCarbonEstimatesInput, OrganizationUncheckedCreateWithoutCarbonEstimatesInput>
  }

  export type OrganizationUpsertWithoutCarbonEstimatesInput = {
    update: XOR<OrganizationUpdateWithoutCarbonEstimatesInput, OrganizationUncheckedUpdateWithoutCarbonEstimatesInput>
    create: XOR<OrganizationCreateWithoutCarbonEstimatesInput, OrganizationUncheckedCreateWithoutCarbonEstimatesInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutCarbonEstimatesInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutCarbonEstimatesInput, OrganizationUncheckedUpdateWithoutCarbonEstimatesInput>
  }

  export type OrganizationUpdateWithoutCarbonEstimatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUpdateManyWithoutOrganizationNestedInput
    webhooks?: WebhookUpdateManyWithoutOrganizationNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutOrganizationNestedInput
    billingRules?: BillingRuleUpdateManyWithoutOrganizationNestedInput
    billingTemplates?: BillingRuleTemplateUpdateManyWithoutOrganizationNestedInput
    orders?: OrderUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutCarbonEstimatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutOrganizationNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutOrganizationNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutOrganizationNestedInput
    billingRules?: BillingRuleUncheckedUpdateManyWithoutOrganizationNestedInput
    billingTemplates?: BillingRuleTemplateUncheckedUpdateManyWithoutOrganizationNestedInput
    orders?: OrderUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationCreateWithoutBillingRulesInput = {
    id?: string
    name: string
    email?: string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationCreateNestedManyWithoutOrganizationInput
    webhooks?: WebhookCreateNestedManyWithoutOrganizationInput
    apiKeys?: ApiKeyCreateNestedManyWithoutOrganizationInput
    carbonEstimates?: CarbonEstimateCreateNestedManyWithoutOrganizationInput
    billingTemplates?: BillingRuleTemplateCreateNestedManyWithoutOrganizationInput
    orders?: OrderCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutBillingRulesInput = {
    id?: string
    name: string
    email?: string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrganizationInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutOrganizationInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutOrganizationInput
    carbonEstimates?: CarbonEstimateUncheckedCreateNestedManyWithoutOrganizationInput
    billingTemplates?: BillingRuleTemplateUncheckedCreateNestedManyWithoutOrganizationInput
    orders?: OrderUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutBillingRulesInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutBillingRulesInput, OrganizationUncheckedCreateWithoutBillingRulesInput>
  }

  export type OrganizationUpsertWithoutBillingRulesInput = {
    update: XOR<OrganizationUpdateWithoutBillingRulesInput, OrganizationUncheckedUpdateWithoutBillingRulesInput>
    create: XOR<OrganizationCreateWithoutBillingRulesInput, OrganizationUncheckedCreateWithoutBillingRulesInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutBillingRulesInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutBillingRulesInput, OrganizationUncheckedUpdateWithoutBillingRulesInput>
  }

  export type OrganizationUpdateWithoutBillingRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUpdateManyWithoutOrganizationNestedInput
    webhooks?: WebhookUpdateManyWithoutOrganizationNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutOrganizationNestedInput
    carbonEstimates?: CarbonEstimateUpdateManyWithoutOrganizationNestedInput
    billingTemplates?: BillingRuleTemplateUpdateManyWithoutOrganizationNestedInput
    orders?: OrderUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutBillingRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutOrganizationNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutOrganizationNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutOrganizationNestedInput
    carbonEstimates?: CarbonEstimateUncheckedUpdateManyWithoutOrganizationNestedInput
    billingTemplates?: BillingRuleTemplateUncheckedUpdateManyWithoutOrganizationNestedInput
    orders?: OrderUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationCreateWithoutBillingTemplatesInput = {
    id?: string
    name: string
    email?: string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationCreateNestedManyWithoutOrganizationInput
    webhooks?: WebhookCreateNestedManyWithoutOrganizationInput
    apiKeys?: ApiKeyCreateNestedManyWithoutOrganizationInput
    carbonEstimates?: CarbonEstimateCreateNestedManyWithoutOrganizationInput
    billingRules?: BillingRuleCreateNestedManyWithoutOrganizationInput
    orders?: OrderCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutBillingTemplatesInput = {
    id?: string
    name: string
    email?: string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrganizationInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutOrganizationInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutOrganizationInput
    carbonEstimates?: CarbonEstimateUncheckedCreateNestedManyWithoutOrganizationInput
    billingRules?: BillingRuleUncheckedCreateNestedManyWithoutOrganizationInput
    orders?: OrderUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutBillingTemplatesInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutBillingTemplatesInput, OrganizationUncheckedCreateWithoutBillingTemplatesInput>
  }

  export type OrganizationUpsertWithoutBillingTemplatesInput = {
    update: XOR<OrganizationUpdateWithoutBillingTemplatesInput, OrganizationUncheckedUpdateWithoutBillingTemplatesInput>
    create: XOR<OrganizationCreateWithoutBillingTemplatesInput, OrganizationUncheckedCreateWithoutBillingTemplatesInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutBillingTemplatesInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutBillingTemplatesInput, OrganizationUncheckedUpdateWithoutBillingTemplatesInput>
  }

  export type OrganizationUpdateWithoutBillingTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUpdateManyWithoutOrganizationNestedInput
    webhooks?: WebhookUpdateManyWithoutOrganizationNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutOrganizationNestedInput
    carbonEstimates?: CarbonEstimateUpdateManyWithoutOrganizationNestedInput
    billingRules?: BillingRuleUpdateManyWithoutOrganizationNestedInput
    orders?: OrderUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutBillingTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutOrganizationNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutOrganizationNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutOrganizationNestedInput
    carbonEstimates?: CarbonEstimateUncheckedUpdateManyWithoutOrganizationNestedInput
    billingRules?: BillingRuleUncheckedUpdateManyWithoutOrganizationNestedInput
    orders?: OrderUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationCreateWithoutOrdersInput = {
    id?: string
    name: string
    email?: string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationCreateNestedManyWithoutOrganizationInput
    webhooks?: WebhookCreateNestedManyWithoutOrganizationInput
    apiKeys?: ApiKeyCreateNestedManyWithoutOrganizationInput
    carbonEstimates?: CarbonEstimateCreateNestedManyWithoutOrganizationInput
    billingRules?: BillingRuleCreateNestedManyWithoutOrganizationInput
    billingTemplates?: BillingRuleTemplateCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutOrdersInput = {
    id?: string
    name: string
    email?: string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrganizationInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutOrganizationInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutOrganizationInput
    carbonEstimates?: CarbonEstimateUncheckedCreateNestedManyWithoutOrganizationInput
    billingRules?: BillingRuleUncheckedCreateNestedManyWithoutOrganizationInput
    billingTemplates?: BillingRuleTemplateUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutOrdersInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutOrdersInput, OrganizationUncheckedCreateWithoutOrdersInput>
  }

  export type CustomerCreateWithoutOrdersInput = {
    id?: string
    userId: string
    stripeCustomerId?: string | null
    name?: string | null
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentCreateNestedManyWithoutCustomerInput
    subscription?: SubscriptionCreateNestedOneWithoutCustomerInput
    taxCalculations?: TaxCalculationCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutOrdersInput = {
    id?: string
    userId: string
    stripeCustomerId?: string | null
    name?: string | null
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutCustomerInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutCustomerInput
    taxCalculations?: TaxCalculationUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutOrdersInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
  }

  export type PaymentCreateWithoutOrderInput = {
    id?: string
    amount: number
    currency?: string
    status: string
    stripePaymentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPaymentsInput
    customer?: CustomerCreateNestedOneWithoutPaymentsInput
    subscription?: SubscriptionCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutOrderInput = {
    id?: string
    amount: number
    currency?: string
    status: string
    stripePaymentId: string
    userId: string
    customerId?: string | null
    subscriptionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutOrderInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
  }

  export type PaymentCreateManyOrderInputEnvelope = {
    data: PaymentCreateManyOrderInput | PaymentCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutOrdersInput = {
    update: XOR<OrganizationUpdateWithoutOrdersInput, OrganizationUncheckedUpdateWithoutOrdersInput>
    create: XOR<OrganizationCreateWithoutOrdersInput, OrganizationUncheckedCreateWithoutOrdersInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutOrdersInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutOrdersInput, OrganizationUncheckedUpdateWithoutOrdersInput>
  }

  export type OrganizationUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUpdateManyWithoutOrganizationNestedInput
    webhooks?: WebhookUpdateManyWithoutOrganizationNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutOrganizationNestedInput
    carbonEstimates?: CarbonEstimateUpdateManyWithoutOrganizationNestedInput
    billingRules?: BillingRuleUpdateManyWithoutOrganizationNestedInput
    billingTemplates?: BillingRuleTemplateUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutOrganizationNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutOrganizationNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutOrganizationNestedInput
    carbonEstimates?: CarbonEstimateUncheckedUpdateManyWithoutOrganizationNestedInput
    billingRules?: BillingRuleUncheckedUpdateManyWithoutOrganizationNestedInput
    billingTemplates?: BillingRuleTemplateUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type CustomerUpsertWithoutOrdersInput = {
    update: XOR<CustomerUpdateWithoutOrdersInput, CustomerUncheckedUpdateWithoutOrdersInput>
    create: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutOrdersInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutOrdersInput, CustomerUncheckedUpdateWithoutOrdersInput>
  }

  export type CustomerUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUpdateManyWithoutCustomerNestedInput
    subscription?: SubscriptionUpdateOneWithoutCustomerNestedInput
    taxCalculations?: TaxCalculationUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutCustomerNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutCustomerNestedInput
    taxCalculations?: TaxCalculationUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type PaymentUpsertWithWhereUniqueWithoutOrderInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutOrderInput, PaymentUncheckedUpdateWithoutOrderInput>
    create: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutOrderInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutOrderInput, PaymentUncheckedUpdateWithoutOrderInput>
  }

  export type PaymentUpdateManyWithWhereWithoutOrderInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutOrderInput>
  }

  export type PlanCreateWithoutPriceHistoryInput = {
    id?: string
    name: string
    description?: string | null
    basePrice: number
    currentPrice: number
    currency?: string
    interval?: string
    stripePriceId?: string | null
    isActive?: boolean
    sortOrder?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    marketSegment?: string | null
    costBasis?: number | null
    churnRisk?: number | null
    features?: PlanFeatureCreateNestedManyWithoutPlanInput
    usageLimits?: UsageLimitCreateNestedManyWithoutPlanInput
    priceTests?: PriceTestCreateNestedManyWithoutPlanInput
    revenueRules?: RevenueRecognitionRuleCreateNestedManyWithoutPlanInput
    subscriptions?: SubscriptionCreateNestedManyWithoutPlanInput
  }

  export type PlanUncheckedCreateWithoutPriceHistoryInput = {
    id?: string
    name: string
    description?: string | null
    basePrice: number
    currentPrice: number
    currency?: string
    interval?: string
    stripePriceId?: string | null
    isActive?: boolean
    sortOrder?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    marketSegment?: string | null
    costBasis?: number | null
    churnRisk?: number | null
    features?: PlanFeatureUncheckedCreateNestedManyWithoutPlanInput
    usageLimits?: UsageLimitUncheckedCreateNestedManyWithoutPlanInput
    priceTests?: PriceTestUncheckedCreateNestedManyWithoutPlanInput
    revenueRules?: RevenueRecognitionRuleUncheckedCreateNestedManyWithoutPlanInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanCreateOrConnectWithoutPriceHistoryInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutPriceHistoryInput, PlanUncheckedCreateWithoutPriceHistoryInput>
  }

  export type PlanUpsertWithoutPriceHistoryInput = {
    update: XOR<PlanUpdateWithoutPriceHistoryInput, PlanUncheckedUpdateWithoutPriceHistoryInput>
    create: XOR<PlanCreateWithoutPriceHistoryInput, PlanUncheckedCreateWithoutPriceHistoryInput>
    where?: PlanWhereInput
  }

  export type PlanUpdateToOneWithWhereWithoutPriceHistoryInput = {
    where?: PlanWhereInput
    data: XOR<PlanUpdateWithoutPriceHistoryInput, PlanUncheckedUpdateWithoutPriceHistoryInput>
  }

  export type PlanUpdateWithoutPriceHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    interval?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    marketSegment?: NullableStringFieldUpdateOperationsInput | string | null
    costBasis?: NullableFloatFieldUpdateOperationsInput | number | null
    churnRisk?: NullableFloatFieldUpdateOperationsInput | number | null
    features?: PlanFeatureUpdateManyWithoutPlanNestedInput
    usageLimits?: UsageLimitUpdateManyWithoutPlanNestedInput
    priceTests?: PriceTestUpdateManyWithoutPlanNestedInput
    revenueRules?: RevenueRecognitionRuleUpdateManyWithoutPlanNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateWithoutPriceHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    interval?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    marketSegment?: NullableStringFieldUpdateOperationsInput | string | null
    costBasis?: NullableFloatFieldUpdateOperationsInput | number | null
    churnRisk?: NullableFloatFieldUpdateOperationsInput | number | null
    features?: PlanFeatureUncheckedUpdateManyWithoutPlanNestedInput
    usageLimits?: UsageLimitUncheckedUpdateManyWithoutPlanNestedInput
    priceTests?: PriceTestUncheckedUpdateManyWithoutPlanNestedInput
    revenueRules?: RevenueRecognitionRuleUncheckedUpdateManyWithoutPlanNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type PlanCreateWithoutPriceTestsInput = {
    id?: string
    name: string
    description?: string | null
    basePrice: number
    currentPrice: number
    currency?: string
    interval?: string
    stripePriceId?: string | null
    isActive?: boolean
    sortOrder?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    marketSegment?: string | null
    costBasis?: number | null
    churnRisk?: number | null
    features?: PlanFeatureCreateNestedManyWithoutPlanInput
    usageLimits?: UsageLimitCreateNestedManyWithoutPlanInput
    priceHistory?: PriceHistoryCreateNestedManyWithoutPlanInput
    revenueRules?: RevenueRecognitionRuleCreateNestedManyWithoutPlanInput
    subscriptions?: SubscriptionCreateNestedManyWithoutPlanInput
  }

  export type PlanUncheckedCreateWithoutPriceTestsInput = {
    id?: string
    name: string
    description?: string | null
    basePrice: number
    currentPrice: number
    currency?: string
    interval?: string
    stripePriceId?: string | null
    isActive?: boolean
    sortOrder?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    marketSegment?: string | null
    costBasis?: number | null
    churnRisk?: number | null
    features?: PlanFeatureUncheckedCreateNestedManyWithoutPlanInput
    usageLimits?: UsageLimitUncheckedCreateNestedManyWithoutPlanInput
    priceHistory?: PriceHistoryUncheckedCreateNestedManyWithoutPlanInput
    revenueRules?: RevenueRecognitionRuleUncheckedCreateNestedManyWithoutPlanInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanCreateOrConnectWithoutPriceTestsInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutPriceTestsInput, PlanUncheckedCreateWithoutPriceTestsInput>
  }

  export type PriceTestVariantCreateWithoutTestInput = {
    id?: string
    price: number
    name: string
    description?: string | null
    conversionRate?: number | null
    revenue?: number | null
    subscribers?: number
    isControl?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PriceTestVariantUncheckedCreateWithoutTestInput = {
    id?: string
    price: number
    name: string
    description?: string | null
    conversionRate?: number | null
    revenue?: number | null
    subscribers?: number
    isControl?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PriceTestVariantCreateOrConnectWithoutTestInput = {
    where: PriceTestVariantWhereUniqueInput
    create: XOR<PriceTestVariantCreateWithoutTestInput, PriceTestVariantUncheckedCreateWithoutTestInput>
  }

  export type PriceTestVariantCreateManyTestInputEnvelope = {
    data: PriceTestVariantCreateManyTestInput | PriceTestVariantCreateManyTestInput[]
    skipDuplicates?: boolean
  }

  export type PlanUpsertWithoutPriceTestsInput = {
    update: XOR<PlanUpdateWithoutPriceTestsInput, PlanUncheckedUpdateWithoutPriceTestsInput>
    create: XOR<PlanCreateWithoutPriceTestsInput, PlanUncheckedCreateWithoutPriceTestsInput>
    where?: PlanWhereInput
  }

  export type PlanUpdateToOneWithWhereWithoutPriceTestsInput = {
    where?: PlanWhereInput
    data: XOR<PlanUpdateWithoutPriceTestsInput, PlanUncheckedUpdateWithoutPriceTestsInput>
  }

  export type PlanUpdateWithoutPriceTestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    interval?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    marketSegment?: NullableStringFieldUpdateOperationsInput | string | null
    costBasis?: NullableFloatFieldUpdateOperationsInput | number | null
    churnRisk?: NullableFloatFieldUpdateOperationsInput | number | null
    features?: PlanFeatureUpdateManyWithoutPlanNestedInput
    usageLimits?: UsageLimitUpdateManyWithoutPlanNestedInput
    priceHistory?: PriceHistoryUpdateManyWithoutPlanNestedInput
    revenueRules?: RevenueRecognitionRuleUpdateManyWithoutPlanNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateWithoutPriceTestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    interval?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    marketSegment?: NullableStringFieldUpdateOperationsInput | string | null
    costBasis?: NullableFloatFieldUpdateOperationsInput | number | null
    churnRisk?: NullableFloatFieldUpdateOperationsInput | number | null
    features?: PlanFeatureUncheckedUpdateManyWithoutPlanNestedInput
    usageLimits?: UsageLimitUncheckedUpdateManyWithoutPlanNestedInput
    priceHistory?: PriceHistoryUncheckedUpdateManyWithoutPlanNestedInput
    revenueRules?: RevenueRecognitionRuleUncheckedUpdateManyWithoutPlanNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type PriceTestVariantUpsertWithWhereUniqueWithoutTestInput = {
    where: PriceTestVariantWhereUniqueInput
    update: XOR<PriceTestVariantUpdateWithoutTestInput, PriceTestVariantUncheckedUpdateWithoutTestInput>
    create: XOR<PriceTestVariantCreateWithoutTestInput, PriceTestVariantUncheckedCreateWithoutTestInput>
  }

  export type PriceTestVariantUpdateWithWhereUniqueWithoutTestInput = {
    where: PriceTestVariantWhereUniqueInput
    data: XOR<PriceTestVariantUpdateWithoutTestInput, PriceTestVariantUncheckedUpdateWithoutTestInput>
  }

  export type PriceTestVariantUpdateManyWithWhereWithoutTestInput = {
    where: PriceTestVariantScalarWhereInput
    data: XOR<PriceTestVariantUpdateManyMutationInput, PriceTestVariantUncheckedUpdateManyWithoutTestInput>
  }

  export type PriceTestVariantScalarWhereInput = {
    AND?: PriceTestVariantScalarWhereInput | PriceTestVariantScalarWhereInput[]
    OR?: PriceTestVariantScalarWhereInput[]
    NOT?: PriceTestVariantScalarWhereInput | PriceTestVariantScalarWhereInput[]
    id?: StringFilter<"PriceTestVariant"> | string
    testId?: StringFilter<"PriceTestVariant"> | string
    price?: FloatFilter<"PriceTestVariant"> | number
    name?: StringFilter<"PriceTestVariant"> | string
    description?: StringNullableFilter<"PriceTestVariant"> | string | null
    conversionRate?: FloatNullableFilter<"PriceTestVariant"> | number | null
    revenue?: FloatNullableFilter<"PriceTestVariant"> | number | null
    subscribers?: IntFilter<"PriceTestVariant"> | number
    isControl?: BoolFilter<"PriceTestVariant"> | boolean
    metadata?: JsonNullableFilter<"PriceTestVariant">
    createdAt?: DateTimeFilter<"PriceTestVariant"> | Date | string
    updatedAt?: DateTimeFilter<"PriceTestVariant"> | Date | string
  }

  export type PriceTestCreateWithoutVariantsInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    status: string
    targetMetric: string
    minConfidence: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    plan: PlanCreateNestedOneWithoutPriceTestsInput
  }

  export type PriceTestUncheckedCreateWithoutVariantsInput = {
    id?: string
    planId: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    status: string
    targetMetric: string
    minConfidence: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PriceTestCreateOrConnectWithoutVariantsInput = {
    where: PriceTestWhereUniqueInput
    create: XOR<PriceTestCreateWithoutVariantsInput, PriceTestUncheckedCreateWithoutVariantsInput>
  }

  export type PriceTestUpsertWithoutVariantsInput = {
    update: XOR<PriceTestUpdateWithoutVariantsInput, PriceTestUncheckedUpdateWithoutVariantsInput>
    create: XOR<PriceTestCreateWithoutVariantsInput, PriceTestUncheckedCreateWithoutVariantsInput>
    where?: PriceTestWhereInput
  }

  export type PriceTestUpdateToOneWithWhereWithoutVariantsInput = {
    where?: PriceTestWhereInput
    data: XOR<PriceTestUpdateWithoutVariantsInput, PriceTestUncheckedUpdateWithoutVariantsInput>
  }

  export type PriceTestUpdateWithoutVariantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    targetMetric?: StringFieldUpdateOperationsInput | string
    minConfidence?: FloatFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneRequiredWithoutPriceTestsNestedInput
  }

  export type PriceTestUncheckedUpdateWithoutVariantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    targetMetric?: StringFieldUpdateOperationsInput | string
    minConfidence?: FloatFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanCreateWithoutRevenueRulesInput = {
    id?: string
    name: string
    description?: string | null
    basePrice: number
    currentPrice: number
    currency?: string
    interval?: string
    stripePriceId?: string | null
    isActive?: boolean
    sortOrder?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    marketSegment?: string | null
    costBasis?: number | null
    churnRisk?: number | null
    features?: PlanFeatureCreateNestedManyWithoutPlanInput
    usageLimits?: UsageLimitCreateNestedManyWithoutPlanInput
    priceHistory?: PriceHistoryCreateNestedManyWithoutPlanInput
    priceTests?: PriceTestCreateNestedManyWithoutPlanInput
    subscriptions?: SubscriptionCreateNestedManyWithoutPlanInput
  }

  export type PlanUncheckedCreateWithoutRevenueRulesInput = {
    id?: string
    name: string
    description?: string | null
    basePrice: number
    currentPrice: number
    currency?: string
    interval?: string
    stripePriceId?: string | null
    isActive?: boolean
    sortOrder?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    marketSegment?: string | null
    costBasis?: number | null
    churnRisk?: number | null
    features?: PlanFeatureUncheckedCreateNestedManyWithoutPlanInput
    usageLimits?: UsageLimitUncheckedCreateNestedManyWithoutPlanInput
    priceHistory?: PriceHistoryUncheckedCreateNestedManyWithoutPlanInput
    priceTests?: PriceTestUncheckedCreateNestedManyWithoutPlanInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanCreateOrConnectWithoutRevenueRulesInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutRevenueRulesInput, PlanUncheckedCreateWithoutRevenueRulesInput>
  }

  export type PlanUpsertWithoutRevenueRulesInput = {
    update: XOR<PlanUpdateWithoutRevenueRulesInput, PlanUncheckedUpdateWithoutRevenueRulesInput>
    create: XOR<PlanCreateWithoutRevenueRulesInput, PlanUncheckedCreateWithoutRevenueRulesInput>
    where?: PlanWhereInput
  }

  export type PlanUpdateToOneWithWhereWithoutRevenueRulesInput = {
    where?: PlanWhereInput
    data: XOR<PlanUpdateWithoutRevenueRulesInput, PlanUncheckedUpdateWithoutRevenueRulesInput>
  }

  export type PlanUpdateWithoutRevenueRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    interval?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    marketSegment?: NullableStringFieldUpdateOperationsInput | string | null
    costBasis?: NullableFloatFieldUpdateOperationsInput | number | null
    churnRisk?: NullableFloatFieldUpdateOperationsInput | number | null
    features?: PlanFeatureUpdateManyWithoutPlanNestedInput
    usageLimits?: UsageLimitUpdateManyWithoutPlanNestedInput
    priceHistory?: PriceHistoryUpdateManyWithoutPlanNestedInput
    priceTests?: PriceTestUpdateManyWithoutPlanNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateWithoutRevenueRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    interval?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    marketSegment?: NullableStringFieldUpdateOperationsInput | string | null
    costBasis?: NullableFloatFieldUpdateOperationsInput | number | null
    churnRisk?: NullableFloatFieldUpdateOperationsInput | number | null
    features?: PlanFeatureUncheckedUpdateManyWithoutPlanNestedInput
    usageLimits?: UsageLimitUncheckedUpdateManyWithoutPlanNestedInput
    priceHistory?: PriceHistoryUncheckedUpdateManyWithoutPlanNestedInput
    priceTests?: PriceTestUncheckedUpdateManyWithoutPlanNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type ForecastResultCreateWithoutModelInput = {
    id?: string
    timestamp: Date | string
    value: number
    lowerBound?: number | null
    upperBound?: number | null
    confidence?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ForecastResultUncheckedCreateWithoutModelInput = {
    id?: string
    timestamp: Date | string
    value: number
    lowerBound?: number | null
    upperBound?: number | null
    confidence?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ForecastResultCreateOrConnectWithoutModelInput = {
    where: ForecastResultWhereUniqueInput
    create: XOR<ForecastResultCreateWithoutModelInput, ForecastResultUncheckedCreateWithoutModelInput>
  }

  export type ForecastResultCreateManyModelInputEnvelope = {
    data: ForecastResultCreateManyModelInput | ForecastResultCreateManyModelInput[]
    skipDuplicates?: boolean
  }

  export type TimeSeriesDataCreateWithoutModelInput = {
    id?: string
    timestamp: Date | string
    value: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TimeSeriesDataUncheckedCreateWithoutModelInput = {
    id?: string
    timestamp: Date | string
    value: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TimeSeriesDataCreateOrConnectWithoutModelInput = {
    where: TimeSeriesDataWhereUniqueInput
    create: XOR<TimeSeriesDataCreateWithoutModelInput, TimeSeriesDataUncheckedCreateWithoutModelInput>
  }

  export type TimeSeriesDataCreateManyModelInputEnvelope = {
    data: TimeSeriesDataCreateManyModelInput | TimeSeriesDataCreateManyModelInput[]
    skipDuplicates?: boolean
  }

  export type ForecastResultUpsertWithWhereUniqueWithoutModelInput = {
    where: ForecastResultWhereUniqueInput
    update: XOR<ForecastResultUpdateWithoutModelInput, ForecastResultUncheckedUpdateWithoutModelInput>
    create: XOR<ForecastResultCreateWithoutModelInput, ForecastResultUncheckedCreateWithoutModelInput>
  }

  export type ForecastResultUpdateWithWhereUniqueWithoutModelInput = {
    where: ForecastResultWhereUniqueInput
    data: XOR<ForecastResultUpdateWithoutModelInput, ForecastResultUncheckedUpdateWithoutModelInput>
  }

  export type ForecastResultUpdateManyWithWhereWithoutModelInput = {
    where: ForecastResultScalarWhereInput
    data: XOR<ForecastResultUpdateManyMutationInput, ForecastResultUncheckedUpdateManyWithoutModelInput>
  }

  export type ForecastResultScalarWhereInput = {
    AND?: ForecastResultScalarWhereInput | ForecastResultScalarWhereInput[]
    OR?: ForecastResultScalarWhereInput[]
    NOT?: ForecastResultScalarWhereInput | ForecastResultScalarWhereInput[]
    id?: StringFilter<"ForecastResult"> | string
    timestamp?: DateTimeFilter<"ForecastResult"> | Date | string
    value?: FloatFilter<"ForecastResult"> | number
    lowerBound?: FloatNullableFilter<"ForecastResult"> | number | null
    upperBound?: FloatNullableFilter<"ForecastResult"> | number | null
    confidence?: FloatNullableFilter<"ForecastResult"> | number | null
    metadata?: JsonNullableFilter<"ForecastResult">
    modelId?: StringFilter<"ForecastResult"> | string
  }

  export type TimeSeriesDataUpsertWithWhereUniqueWithoutModelInput = {
    where: TimeSeriesDataWhereUniqueInput
    update: XOR<TimeSeriesDataUpdateWithoutModelInput, TimeSeriesDataUncheckedUpdateWithoutModelInput>
    create: XOR<TimeSeriesDataCreateWithoutModelInput, TimeSeriesDataUncheckedCreateWithoutModelInput>
  }

  export type TimeSeriesDataUpdateWithWhereUniqueWithoutModelInput = {
    where: TimeSeriesDataWhereUniqueInput
    data: XOR<TimeSeriesDataUpdateWithoutModelInput, TimeSeriesDataUncheckedUpdateWithoutModelInput>
  }

  export type TimeSeriesDataUpdateManyWithWhereWithoutModelInput = {
    where: TimeSeriesDataScalarWhereInput
    data: XOR<TimeSeriesDataUpdateManyMutationInput, TimeSeriesDataUncheckedUpdateManyWithoutModelInput>
  }

  export type TimeSeriesDataScalarWhereInput = {
    AND?: TimeSeriesDataScalarWhereInput | TimeSeriesDataScalarWhereInput[]
    OR?: TimeSeriesDataScalarWhereInput[]
    NOT?: TimeSeriesDataScalarWhereInput | TimeSeriesDataScalarWhereInput[]
    id?: StringFilter<"TimeSeriesData"> | string
    timestamp?: DateTimeFilter<"TimeSeriesData"> | Date | string
    value?: FloatFilter<"TimeSeriesData"> | number
    metadata?: JsonNullableFilter<"TimeSeriesData">
    modelId?: StringFilter<"TimeSeriesData"> | string
  }

  export type ForecastModelCreateWithoutTimeSeriesDataInput = {
    id?: string
    name: string
    config: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    lastTraining?: Date | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    forecasts?: ForecastResultCreateNestedManyWithoutModelInput
  }

  export type ForecastModelUncheckedCreateWithoutTimeSeriesDataInput = {
    id?: string
    name: string
    config: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    lastTraining?: Date | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    forecasts?: ForecastResultUncheckedCreateNestedManyWithoutModelInput
  }

  export type ForecastModelCreateOrConnectWithoutTimeSeriesDataInput = {
    where: ForecastModelWhereUniqueInput
    create: XOR<ForecastModelCreateWithoutTimeSeriesDataInput, ForecastModelUncheckedCreateWithoutTimeSeriesDataInput>
  }

  export type ForecastModelUpsertWithoutTimeSeriesDataInput = {
    update: XOR<ForecastModelUpdateWithoutTimeSeriesDataInput, ForecastModelUncheckedUpdateWithoutTimeSeriesDataInput>
    create: XOR<ForecastModelCreateWithoutTimeSeriesDataInput, ForecastModelUncheckedCreateWithoutTimeSeriesDataInput>
    where?: ForecastModelWhereInput
  }

  export type ForecastModelUpdateToOneWithWhereWithoutTimeSeriesDataInput = {
    where?: ForecastModelWhereInput
    data: XOR<ForecastModelUpdateWithoutTimeSeriesDataInput, ForecastModelUncheckedUpdateWithoutTimeSeriesDataInput>
  }

  export type ForecastModelUpdateWithoutTimeSeriesDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastTraining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    forecasts?: ForecastResultUpdateManyWithoutModelNestedInput
  }

  export type ForecastModelUncheckedUpdateWithoutTimeSeriesDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastTraining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    forecasts?: ForecastResultUncheckedUpdateManyWithoutModelNestedInput
  }

  export type ForecastModelCreateWithoutForecastsInput = {
    id?: string
    name: string
    config: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    lastTraining?: Date | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    timeSeriesData?: TimeSeriesDataCreateNestedManyWithoutModelInput
  }

  export type ForecastModelUncheckedCreateWithoutForecastsInput = {
    id?: string
    name: string
    config: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    lastTraining?: Date | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    timeSeriesData?: TimeSeriesDataUncheckedCreateNestedManyWithoutModelInput
  }

  export type ForecastModelCreateOrConnectWithoutForecastsInput = {
    where: ForecastModelWhereUniqueInput
    create: XOR<ForecastModelCreateWithoutForecastsInput, ForecastModelUncheckedCreateWithoutForecastsInput>
  }

  export type ForecastModelUpsertWithoutForecastsInput = {
    update: XOR<ForecastModelUpdateWithoutForecastsInput, ForecastModelUncheckedUpdateWithoutForecastsInput>
    create: XOR<ForecastModelCreateWithoutForecastsInput, ForecastModelUncheckedCreateWithoutForecastsInput>
    where?: ForecastModelWhereInput
  }

  export type ForecastModelUpdateToOneWithWhereWithoutForecastsInput = {
    where?: ForecastModelWhereInput
    data: XOR<ForecastModelUpdateWithoutForecastsInput, ForecastModelUncheckedUpdateWithoutForecastsInput>
  }

  export type ForecastModelUpdateWithoutForecastsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastTraining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    timeSeriesData?: TimeSeriesDataUpdateManyWithoutModelNestedInput
  }

  export type ForecastModelUncheckedUpdateWithoutForecastsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastTraining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    timeSeriesData?: TimeSeriesDataUncheckedUpdateManyWithoutModelNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    name?: string | null
    email: string
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: string
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    retryAttempts?: RetryAttemptCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name?: string | null
    email: string
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: string
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    retryAttempts?: RetryAttemptUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type OrganizationCreateWithoutNotificationsInput = {
    id?: string
    name: string
    email?: string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    webhooks?: WebhookCreateNestedManyWithoutOrganizationInput
    apiKeys?: ApiKeyCreateNestedManyWithoutOrganizationInput
    carbonEstimates?: CarbonEstimateCreateNestedManyWithoutOrganizationInput
    billingRules?: BillingRuleCreateNestedManyWithoutOrganizationInput
    billingTemplates?: BillingRuleTemplateCreateNestedManyWithoutOrganizationInput
    orders?: OrderCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name: string
    email?: string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    webhooks?: WebhookUncheckedCreateNestedManyWithoutOrganizationInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutOrganizationInput
    carbonEstimates?: CarbonEstimateUncheckedCreateNestedManyWithoutOrganizationInput
    billingRules?: BillingRuleUncheckedCreateNestedManyWithoutOrganizationInput
    billingTemplates?: BillingRuleTemplateUncheckedCreateNestedManyWithoutOrganizationInput
    orders?: OrderUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutNotificationsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutNotificationsInput, OrganizationUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    retryAttempts?: RetryAttemptUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    retryAttempts?: RetryAttemptUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrganizationUpsertWithoutNotificationsInput = {
    update: XOR<OrganizationUpdateWithoutNotificationsInput, OrganizationUncheckedUpdateWithoutNotificationsInput>
    create: XOR<OrganizationCreateWithoutNotificationsInput, OrganizationUncheckedCreateWithoutNotificationsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutNotificationsInput, OrganizationUncheckedUpdateWithoutNotificationsInput>
  }

  export type OrganizationUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    webhooks?: WebhookUpdateManyWithoutOrganizationNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutOrganizationNestedInput
    carbonEstimates?: CarbonEstimateUpdateManyWithoutOrganizationNestedInput
    billingRules?: BillingRuleUpdateManyWithoutOrganizationNestedInput
    billingTemplates?: BillingRuleTemplateUpdateManyWithoutOrganizationNestedInput
    orders?: OrderUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    webhooks?: WebhookUncheckedUpdateManyWithoutOrganizationNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutOrganizationNestedInput
    carbonEstimates?: CarbonEstimateUncheckedUpdateManyWithoutOrganizationNestedInput
    billingRules?: BillingRuleUncheckedUpdateManyWithoutOrganizationNestedInput
    billingTemplates?: BillingRuleTemplateUncheckedUpdateManyWithoutOrganizationNestedInput
    orders?: OrderUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationCreateWithoutApiKeysInput = {
    id?: string
    name: string
    email?: string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationCreateNestedManyWithoutOrganizationInput
    webhooks?: WebhookCreateNestedManyWithoutOrganizationInput
    carbonEstimates?: CarbonEstimateCreateNestedManyWithoutOrganizationInput
    billingRules?: BillingRuleCreateNestedManyWithoutOrganizationInput
    billingTemplates?: BillingRuleTemplateCreateNestedManyWithoutOrganizationInput
    orders?: OrderCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutApiKeysInput = {
    id?: string
    name: string
    email?: string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrganizationInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutOrganizationInput
    carbonEstimates?: CarbonEstimateUncheckedCreateNestedManyWithoutOrganizationInput
    billingRules?: BillingRuleUncheckedCreateNestedManyWithoutOrganizationInput
    billingTemplates?: BillingRuleTemplateUncheckedCreateNestedManyWithoutOrganizationInput
    orders?: OrderUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutApiKeysInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutApiKeysInput, OrganizationUncheckedCreateWithoutApiKeysInput>
  }

  export type OrganizationUpsertWithoutApiKeysInput = {
    update: XOR<OrganizationUpdateWithoutApiKeysInput, OrganizationUncheckedUpdateWithoutApiKeysInput>
    create: XOR<OrganizationCreateWithoutApiKeysInput, OrganizationUncheckedCreateWithoutApiKeysInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutApiKeysInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutApiKeysInput, OrganizationUncheckedUpdateWithoutApiKeysInput>
  }

  export type OrganizationUpdateWithoutApiKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUpdateManyWithoutOrganizationNestedInput
    webhooks?: WebhookUpdateManyWithoutOrganizationNestedInput
    carbonEstimates?: CarbonEstimateUpdateManyWithoutOrganizationNestedInput
    billingRules?: BillingRuleUpdateManyWithoutOrganizationNestedInput
    billingTemplates?: BillingRuleTemplateUpdateManyWithoutOrganizationNestedInput
    orders?: OrderUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutApiKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutOrganizationNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutOrganizationNestedInput
    carbonEstimates?: CarbonEstimateUncheckedUpdateManyWithoutOrganizationNestedInput
    billingRules?: BillingRuleUncheckedUpdateManyWithoutOrganizationNestedInput
    billingTemplates?: BillingRuleTemplateUncheckedUpdateManyWithoutOrganizationNestedInput
    orders?: OrderUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type CustomerCreateWithoutTaxCalculationsInput = {
    id?: string
    userId: string
    stripeCustomerId?: string | null
    name?: string | null
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentCreateNestedManyWithoutCustomerInput
    subscription?: SubscriptionCreateNestedOneWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutTaxCalculationsInput = {
    id?: string
    userId: string
    stripeCustomerId?: string | null
    name?: string | null
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutCustomerInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutCustomerInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutTaxCalculationsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutTaxCalculationsInput, CustomerUncheckedCreateWithoutTaxCalculationsInput>
  }

  export type CustomerUpsertWithoutTaxCalculationsInput = {
    update: XOR<CustomerUpdateWithoutTaxCalculationsInput, CustomerUncheckedUpdateWithoutTaxCalculationsInput>
    create: XOR<CustomerCreateWithoutTaxCalculationsInput, CustomerUncheckedCreateWithoutTaxCalculationsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutTaxCalculationsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutTaxCalculationsInput, CustomerUncheckedUpdateWithoutTaxCalculationsInput>
  }

  export type CustomerUpdateWithoutTaxCalculationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUpdateManyWithoutCustomerNestedInput
    subscription?: SubscriptionUpdateOneWithoutCustomerNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutTaxCalculationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutCustomerNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutCustomerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type UserCreateWithoutRetryAttemptsInput = {
    id?: string
    name?: string | null
    email: string
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: string
    notifications?: NotificationCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRetryAttemptsInput = {
    id?: string
    name?: string | null
    email: string
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: string
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRetryAttemptsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRetryAttemptsInput, UserUncheckedCreateWithoutRetryAttemptsInput>
  }

  export type UserUpsertWithoutRetryAttemptsInput = {
    update: XOR<UserUpdateWithoutRetryAttemptsInput, UserUncheckedUpdateWithoutRetryAttemptsInput>
    create: XOR<UserCreateWithoutRetryAttemptsInput, UserUncheckedCreateWithoutRetryAttemptsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRetryAttemptsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRetryAttemptsInput, UserUncheckedUpdateWithoutRetryAttemptsInput>
  }

  export type UserUpdateWithoutRetryAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRetryAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    organizationId: string
    type: string
    message: string
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefreshTokenCreateManyUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateManyUserInput = {
    id?: string
    amount: number
    currency?: string
    status: string
    stripePaymentId: string
    customerId?: string | null
    subscriptionId?: string | null
    orderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RetryAttemptCreateManyUserInput = {
    id?: string
    invoiceId: string
    attempts?: number
    lastAttemptAt?: Date | string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutPaymentsNestedInput
    subscription?: SubscriptionUpdateOneWithoutPaymentsNestedInput
    order?: OrderUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RetryAttemptUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    lastAttemptAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RetryAttemptUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    lastAttemptAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RetryAttemptUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    lastAttemptAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyOrganizationInput = {
    id?: string
    userId: string
    type: string
    message: string
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebhookCreateManyOrganizationInput = {
    id?: string
    url: string
    secret: string
    events?: WebhookCreateeventsInput | string[]
    status?: string
    retryConfig: JsonNullValueInput | InputJsonValue
    lastSuccess?: Date | string | null
    lastFailure?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiKeyCreateManyOrganizationInput = {
    id?: string
    name: string
    key: string
    lastUsed?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CarbonEstimateCreateManyOrganizationInput = {
    id?: string
    amount: number
    unit: string
    source: string
    category: string
    timestamp?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillingRuleCreateManyOrganizationInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    conditions?: BillingRuleCreateconditionsInput | InputJsonValue[]
    actions?: BillingRuleCreateactionsInput | InputJsonValue[]
    priority?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillingRuleTemplateCreateManyOrganizationInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    conditions?: BillingRuleTemplateCreateconditionsInput | InputJsonValue[]
    actions?: BillingRuleTemplateCreateactionsInput | InputJsonValue[]
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateManyOrganizationInput = {
    id?: string
    customerId: string
    amount: number
    currency: string
    status: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    events?: WebhookUpdateeventsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    retryConfig?: JsonNullValueInput | InputJsonValue
    lastSuccess?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFailure?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveries?: WebhookDeliveryUpdateManyWithoutWebhookNestedInput
  }

  export type WebhookUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    events?: WebhookUpdateeventsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    retryConfig?: JsonNullValueInput | InputJsonValue
    lastSuccess?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFailure?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveries?: WebhookDeliveryUncheckedUpdateManyWithoutWebhookNestedInput
  }

  export type WebhookUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    events?: WebhookUpdateeventsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    retryConfig?: JsonNullValueInput | InputJsonValue
    lastSuccess?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFailure?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CarbonEstimateUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CarbonEstimateUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CarbonEstimateUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingRuleUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    conditions?: BillingRuleUpdateconditionsInput | InputJsonValue[]
    actions?: BillingRuleUpdateactionsInput | InputJsonValue[]
    priority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingRuleUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    conditions?: BillingRuleUpdateconditionsInput | InputJsonValue[]
    actions?: BillingRuleUpdateactionsInput | InputJsonValue[]
    priority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingRuleUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    conditions?: BillingRuleUpdateconditionsInput | InputJsonValue[]
    actions?: BillingRuleUpdateactionsInput | InputJsonValue[]
    priority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingRuleTemplateUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    conditions?: BillingRuleTemplateUpdateconditionsInput | InputJsonValue[]
    actions?: BillingRuleTemplateUpdateactionsInput | InputJsonValue[]
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingRuleTemplateUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    conditions?: BillingRuleTemplateUpdateconditionsInput | InputJsonValue[]
    actions?: BillingRuleTemplateUpdateactionsInput | InputJsonValue[]
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingRuleTemplateUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    conditions?: BillingRuleTemplateUpdateconditionsInput | InputJsonValue[]
    actions?: BillingRuleTemplateUpdateactionsInput | InputJsonValue[]
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyCustomerInput = {
    id?: string
    amount: number
    currency?: string
    status: string
    stripePaymentId: string
    userId: string
    subscriptionId?: string | null
    orderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxCalculationCreateManyCustomerInput = {
    id?: string
    amount: number
    taxRate: number
    taxAmount: number
    country: string
    state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateManyCustomerInput = {
    id?: string
    organizationId: string
    amount: number
    currency: string
    status: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPaymentsNestedInput
    subscription?: SubscriptionUpdateOneWithoutPaymentsNestedInput
    order?: OrderUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxCalculationUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxCalculationUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxCalculationUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutOrdersNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManySubscriptionInput = {
    id?: string
    amount: number
    currency?: string
    status: string
    stripePaymentId: string
    userId: string
    customerId?: string | null
    orderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsageRecordCreateManySubscriptionInput = {
    id?: string
    featureKey: string
    quantity: number
    timestamp?: Date | string
    billingPeriodStart: Date | string
    billingPeriodEnd: Date | string
    processed?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PaymentUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPaymentsNestedInput
    customer?: CustomerUpdateOneWithoutPaymentsNestedInput
    order?: OrderUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageRecordUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureKey?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    billingPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    billingPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    processed?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UsageRecordUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureKey?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    billingPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    billingPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    processed?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UsageRecordUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureKey?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    billingPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    billingPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    processed?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PlanFeatureCreateManyPlanInput = {
    id?: string
    name: string
    description?: string | null
    included?: boolean
    value?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsageLimitCreateManyPlanInput = {
    id?: string
    featureKey: string
    limit: number
    interval?: string
    overage?: boolean
    overagePrice?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PriceHistoryCreateManyPlanInput = {
    id?: string
    price: number
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    reason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PriceTestCreateManyPlanInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    status: string
    targetMetric: string
    minConfidence: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RevenueRecognitionRuleCreateManyPlanInput = {
    id?: string
    type: string
    deferralPeriod?: number | null
    conditions?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionCreateManyPlanInput = {
    id?: string
    customerId: string
    status: $Enums.SubscriptionStatus
    stripeSubscriptionId?: string | null
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    cancelledAt?: Date | string | null
    pausedAt?: Date | string | null
    resumesAt?: Date | string | null
    trialEndsAt?: Date | string | null
    billingCycleAnchor: Date | string
    proration?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanFeatureUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    included?: BoolFieldUpdateOperationsInput | boolean
    value?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanFeatureUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    included?: BoolFieldUpdateOperationsInput | boolean
    value?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanFeatureUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    included?: BoolFieldUpdateOperationsInput | boolean
    value?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageLimitUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureKey?: StringFieldUpdateOperationsInput | string
    limit?: FloatFieldUpdateOperationsInput | number
    interval?: StringFieldUpdateOperationsInput | string
    overage?: BoolFieldUpdateOperationsInput | boolean
    overagePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageLimitUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureKey?: StringFieldUpdateOperationsInput | string
    limit?: FloatFieldUpdateOperationsInput | number
    interval?: StringFieldUpdateOperationsInput | string
    overage?: BoolFieldUpdateOperationsInput | boolean
    overagePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageLimitUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureKey?: StringFieldUpdateOperationsInput | string
    limit?: FloatFieldUpdateOperationsInput | number
    interval?: StringFieldUpdateOperationsInput | string
    overage?: BoolFieldUpdateOperationsInput | boolean
    overagePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceHistoryUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceHistoryUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceHistoryUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceTestUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    targetMetric?: StringFieldUpdateOperationsInput | string
    minConfidence?: FloatFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variants?: PriceTestVariantUpdateManyWithoutTestNestedInput
  }

  export type PriceTestUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    targetMetric?: StringFieldUpdateOperationsInput | string
    minConfidence?: FloatFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variants?: PriceTestVariantUncheckedUpdateManyWithoutTestNestedInput
  }

  export type PriceTestUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    targetMetric?: StringFieldUpdateOperationsInput | string
    minConfidence?: FloatFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RevenueRecognitionRuleUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    deferralPeriod?: NullableIntFieldUpdateOperationsInput | number | null
    conditions?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RevenueRecognitionRuleUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    deferralPeriod?: NullableIntFieldUpdateOperationsInput | number | null
    conditions?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RevenueRecognitionRuleUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    deferralPeriod?: NullableIntFieldUpdateOperationsInput | number | null
    conditions?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resumesAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billingCycleAnchor?: DateTimeFieldUpdateOperationsInput | Date | string
    proration?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutSubscriptionNestedInput
    payments?: PaymentUpdateManyWithoutSubscriptionNestedInput
    usageRecords?: UsageRecordUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resumesAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billingCycleAnchor?: DateTimeFieldUpdateOperationsInput | Date | string
    proration?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutSubscriptionNestedInput
    usageRecords?: UsageRecordUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resumesAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billingCycleAnchor?: DateTimeFieldUpdateOperationsInput | Date | string
    proration?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookDeliveryCreateManyWebhookInput = {
    id?: string
    payload: JsonNullValueInput | InputJsonValue
    status: string
    statusCode?: number | null
    response?: string | null
    error?: string | null
    retries?: number
    createdAt?: Date | string
  }

  export type WebhookDeliveryUpdateWithoutWebhookInput = {
    id?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    retries?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookDeliveryUncheckedUpdateWithoutWebhookInput = {
    id?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    retries?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookDeliveryUncheckedUpdateManyWithoutWebhookInput = {
    id?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    retries?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyOrderInput = {
    id?: string
    amount: number
    currency?: string
    status: string
    stripePaymentId: string
    userId: string
    customerId?: string | null
    subscriptionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPaymentsNestedInput
    customer?: CustomerUpdateOneWithoutPaymentsNestedInput
    subscription?: SubscriptionUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceTestVariantCreateManyTestInput = {
    id?: string
    price: number
    name: string
    description?: string | null
    conversionRate?: number | null
    revenue?: number | null
    subscribers?: number
    isControl?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PriceTestVariantUpdateWithoutTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    conversionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    subscribers?: IntFieldUpdateOperationsInput | number
    isControl?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceTestVariantUncheckedUpdateWithoutTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    conversionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    subscribers?: IntFieldUpdateOperationsInput | number
    isControl?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceTestVariantUncheckedUpdateManyWithoutTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    conversionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    subscribers?: IntFieldUpdateOperationsInput | number
    isControl?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForecastResultCreateManyModelInput = {
    id?: string
    timestamp: Date | string
    value: number
    lowerBound?: number | null
    upperBound?: number | null
    confidence?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TimeSeriesDataCreateManyModelInput = {
    id?: string
    timestamp: Date | string
    value: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ForecastResultUpdateWithoutModelInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    lowerBound?: NullableFloatFieldUpdateOperationsInput | number | null
    upperBound?: NullableFloatFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ForecastResultUncheckedUpdateWithoutModelInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    lowerBound?: NullableFloatFieldUpdateOperationsInput | number | null
    upperBound?: NullableFloatFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ForecastResultUncheckedUpdateManyWithoutModelInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    lowerBound?: NullableFloatFieldUpdateOperationsInput | number | null
    upperBound?: NullableFloatFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TimeSeriesDataUpdateWithoutModelInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TimeSeriesDataUncheckedUpdateWithoutModelInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TimeSeriesDataUncheckedUpdateManyWithoutModelInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrganizationCountOutputTypeDefaultArgs instead
     */
    export type OrganizationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrganizationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomerCountOutputTypeDefaultArgs instead
     */
    export type CustomerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubscriptionCountOutputTypeDefaultArgs instead
     */
    export type SubscriptionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlanCountOutputTypeDefaultArgs instead
     */
    export type PlanCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlanCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WebhookCountOutputTypeDefaultArgs instead
     */
    export type WebhookCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WebhookCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderCountOutputTypeDefaultArgs instead
     */
    export type OrderCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PriceTestCountOutputTypeDefaultArgs instead
     */
    export type PriceTestCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PriceTestCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ForecastModelCountOutputTypeDefaultArgs instead
     */
    export type ForecastModelCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ForecastModelCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrganizationDefaultArgs instead
     */
    export type OrganizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrganizationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomerDefaultArgs instead
     */
    export type CustomerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubscriptionDefaultArgs instead
     */
    export type SubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlanDefaultArgs instead
     */
    export type PlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlanFeatureDefaultArgs instead
     */
    export type PlanFeatureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlanFeatureDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsageLimitDefaultArgs instead
     */
    export type UsageLimitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsageLimitDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceDefaultArgs instead
     */
    export type InvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsageRecordDefaultArgs instead
     */
    export type UsageRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsageRecordDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReportDefaultArgs instead
     */
    export type ReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MetricDefaultArgs instead
     */
    export type MetricArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MetricDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmailNotificationDefaultArgs instead
     */
    export type EmailNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmailNotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WebhookDefaultArgs instead
     */
    export type WebhookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WebhookDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WebhookDeliveryDefaultArgs instead
     */
    export type WebhookDeliveryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WebhookDeliveryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RefreshTokenDefaultArgs instead
     */
    export type RefreshTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RefreshTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentDefaultArgs instead
     */
    export type PaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FinancingOfferDefaultArgs instead
     */
    export type FinancingOfferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FinancingOfferDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CarbonEstimateDefaultArgs instead
     */
    export type CarbonEstimateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CarbonEstimateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BillingRuleDefaultArgs instead
     */
    export type BillingRuleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BillingRuleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BillingRuleTemplateDefaultArgs instead
     */
    export type BillingRuleTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BillingRuleTemplateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderDefaultArgs instead
     */
    export type OrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PriceHistoryDefaultArgs instead
     */
    export type PriceHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PriceHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PriceTestDefaultArgs instead
     */
    export type PriceTestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PriceTestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PriceTestVariantDefaultArgs instead
     */
    export type PriceTestVariantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PriceTestVariantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MarketBenchmarkDefaultArgs instead
     */
    export type MarketBenchmarkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MarketBenchmarkDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RevenueRecognitionRuleDefaultArgs instead
     */
    export type RevenueRecognitionRuleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RevenueRecognitionRuleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RevenueLedgerDefaultArgs instead
     */
    export type RevenueLedgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RevenueLedgerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChurnPredictionDefaultArgs instead
     */
    export type ChurnPredictionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChurnPredictionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CohortAnalysisDefaultArgs instead
     */
    export type CohortAnalysisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CohortAnalysisDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ForecastModelDefaultArgs instead
     */
    export type ForecastModelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ForecastModelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TimeSeriesDataDefaultArgs instead
     */
    export type TimeSeriesDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TimeSeriesDataDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ForecastResultDefaultArgs instead
     */
    export type ForecastResultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ForecastResultDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MarketTrendDefaultArgs instead
     */
    export type MarketTrendArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MarketTrendDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PredictionIntervalDefaultArgs instead
     */
    export type PredictionIntervalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PredictionIntervalDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ApiKeyDefaultArgs instead
     */
    export type ApiKeyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ApiKeyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaxCalculationDefaultArgs instead
     */
    export type TaxCalculationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaxCalculationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AlertDefaultArgs instead
     */
    export type AlertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AlertDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaxRateDefaultArgs instead
     */
    export type TaxRateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaxRateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BillDefaultArgs instead
     */
    export type BillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BillDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TransactionDefaultArgs instead
     */
    export type TransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TransactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RetryAttemptDefaultArgs instead
     */
    export type RetryAttemptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RetryAttemptDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RetryLogDefaultArgs instead
     */
    export type RetryLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RetryLogDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}