<<<<<<< HEAD
import { makeRe } from "next/dist/compiled/micromatch";
=======
import { makeRe } from "next/dist/compiled/picomatch";
// Modifying this function should also modify writeImagesManifest()
>>>>>>> 4f9d35bd5c5bf095848f6fc99f7e7bfe5212365f
export function matchRemotePattern(pattern, url) {
    if (pattern.protocol !== undefined) {
        const actualProto = url.protocol.slice(0, -1);
        if (pattern.protocol !== actualProto) {
            return false;
        }
    }
    if (pattern.port !== undefined) {
        if (pattern.port !== url.port) {
            return false;
        }
    }
    if (pattern.hostname === undefined) {
        throw new Error("Pattern should define hostname but found\n" + JSON.stringify(pattern));
    } else {
        if (!makeRe(pattern.hostname).test(url.hostname)) {
            return false;
        }
    }
<<<<<<< HEAD
    var _pattern_pathname;
    if (!makeRe((_pattern_pathname = pattern.pathname) != null ? _pattern_pathname : "**").test(url.pathname)) {
=======
    if (pattern.search !== undefined) {
        if (pattern.search !== url.search) {
            return false;
        }
    }
    var _pattern_pathname;
    // Should be the same as writeImagesManifest()
    if (!makeRe((_pattern_pathname = pattern.pathname) != null ? _pattern_pathname : "**", {
        dot: true
    }).test(url.pathname)) {
>>>>>>> 4f9d35bd5c5bf095848f6fc99f7e7bfe5212365f
        return false;
    }
    return true;
}
<<<<<<< HEAD
export function hasMatch(domains, remotePatterns, url) {
=======
export function hasRemoteMatch(domains, remotePatterns, url) {
>>>>>>> 4f9d35bd5c5bf095848f6fc99f7e7bfe5212365f
    return domains.some((domain)=>url.hostname === domain) || remotePatterns.some((p)=>matchRemotePattern(p, url));
}

//# sourceMappingURL=match-remote-pattern.js.map