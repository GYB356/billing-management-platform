"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
<<<<<<< HEAD
    log: null,
    init: null,
    getTs: null,
    getInfo: null,
    getTypeChecker: null,
    getSource: null,
    removeStringQuotes: null,
    isPositionInsideNode: null,
    isDefaultFunctionExport: null,
    isInsideApp: null,
    isAppEntryFile: null,
    isPageFile: null,
    getIsClientEntry: null
=======
    getEntryInfo: null,
    getInfo: null,
    getSource: null,
    getTs: null,
    getTypeChecker: null,
    init: null,
    isAppEntryFile: null,
    isDefaultFunctionExport: null,
    isInsideApp: null,
    isPageFile: null,
    isPositionInsideNode: null,
    log: null,
    removeStringQuotes: null
>>>>>>> 4f9d35bd5c5bf095848f6fc99f7e7bfe5212365f
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
<<<<<<< HEAD
    log: function() {
        return log;
    },
    init: function() {
        return init;
    },
    getTs: function() {
        return getTs;
=======
    getEntryInfo: function() {
        return getEntryInfo;
>>>>>>> 4f9d35bd5c5bf095848f6fc99f7e7bfe5212365f
    },
    getInfo: function() {
        return getInfo;
    },
<<<<<<< HEAD
    getTypeChecker: function() {
        return getTypeChecker;
    },
    getSource: function() {
        return getSource;
    },
    removeStringQuotes: function() {
        return removeStringQuotes;
    },
    isPositionInsideNode: function() {
        return isPositionInsideNode;
=======
    getSource: function() {
        return getSource;
    },
    getTs: function() {
        return getTs;
    },
    getTypeChecker: function() {
        return getTypeChecker;
    },
    init: function() {
        return init;
    },
    isAppEntryFile: function() {
        return isAppEntryFile;
>>>>>>> 4f9d35bd5c5bf095848f6fc99f7e7bfe5212365f
    },
    isDefaultFunctionExport: function() {
        return isDefaultFunctionExport;
    },
    isInsideApp: function() {
        return isInsideApp;
    },
<<<<<<< HEAD
    isAppEntryFile: function() {
        return isAppEntryFile;
    },
    isPageFile: function() {
        return isPageFile;
    },
    getIsClientEntry: function() {
        return getIsClientEntry;
=======
    isPageFile: function() {
        return isPageFile;
    },
    isPositionInsideNode: function() {
        return isPositionInsideNode;
    },
    log: function() {
        return log;
    },
    removeStringQuotes: function() {
        return removeStringQuotes;
>>>>>>> 4f9d35bd5c5bf095848f6fc99f7e7bfe5212365f
    }
});
const _path = /*#__PURE__*/ _interop_require_default(require("path"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
let ts;
let info;
let appDirRegExp;
function log(message) {
    info.project.projectService.logger.info(message);
}
function init(opts) {
    ts = opts.ts;
    info = opts.info;
    const projectDir = info.project.getCurrentDirectory();
    appDirRegExp = new RegExp("^" + (projectDir + "(/src)?/app").replace(/[\\/]/g, "[\\/]"));
    log("Starting Next.js TypeScript plugin: " + projectDir);
}
function getTs() {
    return ts;
}
function getInfo() {
    return info;
}
function getTypeChecker() {
    var _info_languageService_getProgram;
    return (_info_languageService_getProgram = info.languageService.getProgram()) == null ? void 0 : _info_languageService_getProgram.getTypeChecker();
}
function getSource(fileName) {
    var _info_languageService_getProgram;
    return (_info_languageService_getProgram = info.languageService.getProgram()) == null ? void 0 : _info_languageService_getProgram.getSourceFile(fileName);
}
function removeStringQuotes(str) {
    return str.replace(/^['"`]|['"`]$/g, "");
}
const isPositionInsideNode = (position, node)=>{
    const start = node.getFullStart();
    return start <= position && position <= node.getFullWidth() + start;
};
const isDefaultFunctionExport = (node)=>{
    if (ts.isFunctionDeclaration(node)) {
        let hasExportKeyword = false;
        let hasDefaultKeyword = false;
        if (node.modifiers) {
            for (const modifier of node.modifiers){
                if (modifier.kind === ts.SyntaxKind.ExportKeyword) {
                    hasExportKeyword = true;
                } else if (modifier.kind === ts.SyntaxKind.DefaultKeyword) {
                    hasDefaultKeyword = true;
                }
            }
        }
        // `export default function`
        if (hasExportKeyword && hasDefaultKeyword) {
            return true;
        }
    }
    return false;
};
const isInsideApp = (filePath)=>{
    return appDirRegExp.test(filePath);
};
const isAppEntryFile = (filePath)=>{
    return appDirRegExp.test(filePath) && /^(page|layout)\.(mjs|js|jsx|ts|tsx)$/.test(_path.default.basename(filePath));
};
const isPageFile = (filePath)=>{
    return appDirRegExp.test(filePath) && /^page\.(mjs|js|jsx|ts|tsx)$/.test(_path.default.basename(filePath));
};
<<<<<<< HEAD
function getIsClientEntry(fileName, throwOnInvalidDirective) {
    const source = getSource(fileName);
    if (source) {
        let isClientEntry = false;
        let isDirective = true;
=======
function getEntryInfo(fileName, throwOnInvalidDirective) {
    const source = getSource(fileName);
    if (source) {
        let isDirective = true;
        let isClientEntry = false;
        let isServerEntry = false;
>>>>>>> 4f9d35bd5c5bf095848f6fc99f7e7bfe5212365f
        ts.forEachChild(source, (node)=>{
            if (ts.isExpressionStatement(node) && ts.isStringLiteral(node.expression)) {
                if (node.expression.text === "use client") {
                    if (isDirective) {
                        isClientEntry = true;
                    } else {
                        if (throwOnInvalidDirective) {
                            const e = {
                                messageText: 'The `"use client"` directive must be put at the top of the file.',
                                start: node.expression.getStart(),
                                length: node.expression.getWidth()
                            };
                            throw e;
                        }
                    }
<<<<<<< HEAD
=======
                } else if (node.expression.text === "use server") {
                    if (isDirective) {
                        isServerEntry = true;
                    } else {
                        if (throwOnInvalidDirective) {
                            const e = {
                                messageText: 'The `"use server"` directive must be put at the top of the file.',
                                start: node.expression.getStart(),
                                length: node.expression.getWidth()
                            };
                            throw e;
                        }
                    }
                }
                if (isClientEntry && isServerEntry) {
                    const e = {
                        messageText: 'Cannot use both "use client" and "use server" directives in the same file.',
                        start: node.expression.getStart(),
                        length: node.expression.getWidth()
                    };
                    throw e;
>>>>>>> 4f9d35bd5c5bf095848f6fc99f7e7bfe5212365f
                }
            } else {
                isDirective = false;
            }
        });
<<<<<<< HEAD
        return isClientEntry;
    }
    return false;
=======
        return {
            client: isClientEntry,
            server: isServerEntry
        };
    }
    return {
        client: false,
        server: false
    };
>>>>>>> 4f9d35bd5c5bf095848f6fc99f7e7bfe5212365f
}

//# sourceMappingURL=utils.js.map